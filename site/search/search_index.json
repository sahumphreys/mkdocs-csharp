{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Preface","text":"<p>The aim of this text is to introduce both the general principles of programming in C# and cover some of the theory behind introductory computer science.  The target audience are students studying A Level Computer Science who are either learning a new language<sup>1</sup> or starting to program for the first time, no prior knowledge is assumed.  Included in the text are references to an A Level specification in the UK but these can be ignored for self-learners.  </p> <p>The catalyst for writing this text arose when the author took on a new job that required teaching C#.  Some fresh learning had to take place, trying out of examples, application of previously known concepts and constructs from other languages but applied to a new platform.  Lots of notes were made, lots of programs written to test out the new concepts and many questions asked.  The bulk of this text is drawn from those notes and from my colleagues as Hills Road Sixth Form College, Cambridge. </p> <p>Fundamentally, the most important skill for any computer scientist is problem-solving, that is, how to formulate problems, consider solutions and to describe those solutions clearly and unambiguously in a programming language.  It's a skill that draws variously on Maths, Engineering, Science, Art and even philosophy - that's what make its fun!  It's not just about the code however, understanding how the computer works alongside the practical application of programming is important and this text endeavours to draw some lines between the theory and the practical.</p> <p>The text is divided into twelve chapters, with a final thirteenth chapter bringing together many of the constructs and concepts learned.  The text could be covered during a first term of a programming class or worked through individually.  Each chapter introduces a number of topics based on an overarching theme.  Each new topic uses example programs to illustrate the new syntax and includes one or more practical programming tasks to complete during the sessions with extensions for self-study and homework.</p> <p>Additionally, each chapter contains a section called Extended Theory.  Here we dig into some of the theoretical topics underpinning, where appropriate, the programming concepts from the chapter.  They may cover aspects of computer science that are unfamiliar but for students taking a course, e.g. A Level Computer Science, they provide useful supplementary material, explanation and, importantly, further example code.  These topics are indicated by a trailing asterisk in the left-hand menu.</p> <p>This text deals exclusively with console programming.  For many this will be an unusual environment as graphical user interfaces are increasingly the norm for our interactions with a computer.  This is sometimes known as computation as calculation (a GUI would be computation by interaction) which has three steps:  INPUT, PROCESS, OUTPUT and the flow of control to the program is top-down as determined by the program logic.  With a GUI the flow of control is determined by when the user e.g. clicks a button, i.e. it captures events.</p> <p>We deliberately do not cover the object-oriented paradigm, leaving that to a supplementary text.   Similarly, we stop short at advanced data structures. For experienced programmers this may seem an unusual decision particularly as C# is an object oriented language and using data structures i.e. stacks, graphs etc. make solving some problems considerably easier.  From the author's experience getting a solid foundation in the fundamental constructs of programming from an imperative/procedural context lays good foundations upon which to build for further development.  Thus, this text should be regarded very much as an introduction to the world of programming with C#.</p> <p>C#,  was developed by Microsoft in 2000 as part of the .NET framework and some twenty years later it remains one of the most popular and widely used programming languages in the world.  In June 2019 it was 5th in the popularity rankings published by TIOBE, behind C, Java, Python and C++.  It can be used for web application development, Windows desktop applications and gaming.  It was developed by Microsoft for Windows so understandably you will need access to the Windows operating system to take advantage of all it can offer.  Microsoft has embraced the open-source movement of late so it is possible to develop on e.g. Linux systems.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>To get started with the examples and exercises you will need access to an Integrated Development Environment, this is software that includes a text editor and a compiler to convert the code we write into an executable program.  One such tool is Visual Studio, the Community edition is available as a free download for Windows.  Alternatively, Microsoft produce a more lightweight environment Visual Studio Code which takes a bit more to set up and requires a C# extension but is available for both Windows and Linux.  All source code in this text will run on either of these platforms.</p> <p>Note</p> <p>Applications written in C# use the .NET Framework.  There are plenty of web sites, including the support documentation from Microsoft, that explain how to install either of these environments to get started with C# so this will not be repeated here.</p>"},{"location":"#tips-for-success","title":"Tips for success","text":"<ol> <li>From the moment you start through to when you finish any computer science course new technologies will have been developed, it is advisable therefore to keep as up to date as you can by reading blogs and articles about programming and C# in particular.</li> <li>Practice, practice, practice (and then do some more practice)!  Programming is like learning a musical instrument, it takes time, it takes a lot of practice</li> <li> <p>Develop good coding habits e.g.</p> </li> <li> <p>Make your code self-documenting i.e. name all files and variables so they are descriptive</p> </li> <li>Format your code, make use of line breaks and indentation</li> <li>Plan before you program</li> <li> <p>Keep the length of functions/subroutines to a \"screen full\"</p> </li> <li> <p>Spend time with the IDE (Integrated Development Environment) you are using to write your programs, esp. the debugger</p> </li> <li>Document your code, keep a README.md file in your project explaining what the program does and how to get it up and running</li> <li>Use Git (and GitHub) for repositories of your projects</li> <li>Always think who else might read your code, does it make sense?</li> <li>Never stop learning!</li> <li>It's OK to ask for help</li> <li>Did I mention practice ...?</li> </ol>"},{"location":"#for-information","title":"For information","text":"<ul> <li>All code for this text was written using Visual Studio Code</li> <li>The text itself was written in Markdown, again using Visual Studio Code</li> <li>A print version is available and was built using Pandoc</li> <li>This site was built using Material for MkDocs</li> <li>The text and all code samples, plus sample answers to selected exercises are all available in a Git Hub repository: https://github.com/sahumphreys/csharpprogramming.git</li> </ul> <ol> <li> <p>If you have programmed before in Python Appendix 7 provides a summary of the differences in syntax between the two languages.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/","title":"About Programming in C","text":"<p>The aim of this text is to introduce both the general principles of programming in C# and cover some of the theory behind introductory computer science.  The target audience are students studying A Level Computer Science who are either learning a new language[^1] or starting to program for the first time, no prior knowledge is assumed.  Included in the text are references to an A Level specification in the UK but these can be ignored for self-learners.  </p> <p>The catalyst for writing this text arose when the author took on a new job that required teaching C#.  Some fresh learning had to take place, trying out of examples, application of previously known concepts and constructs from other languages but applied to a new platform.  Lots of notes were made, lots of programs written to test out the new concepts and many questions asked.  The bulk of this text is drawn from those notes and from my colleagues as Hills Road Sixth Form College, Cambridge. </p> <p>Each chapter explains the syntax of the C# language with plenty of example code.  Also a series of programming tasks to reinforce the concepts covered in that chapter and additional questions.</p> <p>Additionally, each chapter contains a section called Extended Theory.  Here we dig into some of the theoretical topics underpinning, where appropriate, the programming concepts from the chapter.  They may cover aspects of computer science that are unfamiliar but for students taking a course, e.g. A Level Computer Science, they provide useful supplementary material, explanation and, importantly, further example code.  These topics are indicated by a trailing asterisk in the left-hand menu.</p> <p>The text does not cover object oriented programming, a companion set of notes is being worked on and will be available shortly.</p>"},{"location":"chapters/01_introduction/01_introductionToCSharp/","title":"What does it mean to program?","text":"<p>In this chapter</p> <ul> <li>What does it mean to program?</li> <li>Compiling source code into object (machine) code</li> <li>Software development process</li> <li>Use Visual Studio to build a first program</li> <li>Getting data from the keyboard and printing to the screen</li> </ul> <p>To program means to create sequences of instructions in a programming language that organize the work of the computer to carry out a specific task. The sequence of steps required to achieve this task is called an algorithm. An algorithm is then expressed in a programming language, or code, which is subsequently converted into machine code for execution by the computer.</p> <p>C# is a high-level language. High-level languages enable the programmer to focus on the problem being solved without worrying about the specific architecture of the machine. The syntax of high-level languages is closer to English, making them easier to read, write, and maintain.</p> <p>By contrast, a low-level language is much closer to the machine code of the target computer. Machine code is written using binary (1s and 0s) and is specific to a particular CPU architecture. </p> <p>High-level languages need to be either compiled or interpreted into machine code for a specific CPU platform. A compiler converts the source code into a separate, stand-alone, executable file that can be distributed and executed. The compiler checks if the instructions are syntactically and semantically correct before converting them into machine code. This process includes verifying correct punctuation, keyword usage, and logical consistency of the instructions.</p> <p>From the syllabus</p> <p>AQA: Understand the role of a compiler; understand the difference between source code and object (executable) code (3.6.3.1/4.6.3.1).</p> <ul> <li>A compiler takes the source code written in a high-level programming language and converts it into executable code (the machine code that can be run by a processor). It translates a program from a human-readable format to a machine-readable format.</li> </ul>"},{"location":"chapters/01_introduction/01_introductionToCSharp/#stages-in-software-development","title":"Stages in Software Development","text":"<p>Writing software can be complex and time-consuming. In the professional world, software is usually developed by teams and goes through several stages. When learning to program, you may not work in a team, but it's still important to follow these stages as you build your solutions:</p> <ol> <li> <p>Gather the Requirements: </p> <ul> <li>What is the software supposed to do? What will the user be required to do when they interact with your software? This usually includes a list of measurable objectives. Before a problem can be solved, it has to be clearly defined with the objectives of the solution determined, often with input from the intended users.</li> </ul> </li> <li> <p>Planning:</p> <ul> <li>What type of application is being developed (e.g., console, desktop, web app, mobile, etc.)? What data will the program need to handle, and what are their types and structures? What are the algorithms that will operate on this data? What inputs and outputs will the program need? Time spent thinking through the organization of your application will save a lot of effort when it comes to programming, debugging, and maintaining the solution.</li> </ul> </li> <li> <p>Implementation:</p> <ul> <li>At this stage, the source code is written according to the objectives from stage 1 and the design from stage 2. This is usually an iterative process, often involving prototyping to refine the solution.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Have all the requirements been met? Does the program work as intended? Testing should be carried out with well-chosen test data, covering normal, boundary, and erroneous cases to ensure the program behaves correctly in all situations.</li> </ul> </li> <li> <p>Deployment:</p> <ul> <li>This stage involves releasing the software for use by others. While not usually relevant for small learning projects, in professional settings, deployment is a crucial phase where the software is made available to users.</li> </ul> </li> <li> <p>Documentation:</p> <ul> <li>This is not a separate stage but should be integrated throughout the process. Keeping good documentation habits\u2014recording what you are doing, what has worked, what went wrong, and what tests you have run\u2014is invaluable for maintaining and updating your software.</li> </ul> </li> </ol> <p>From the syllabus</p> <p>AQA: Systematic approach to problem solving (4.13.1).</p> <ul> <li>There are several approaches to developing software, including Agile and Waterfall, but all processes include stages like Analysis, Design, Implementation, Testing, and Evaluation.</li> <li>The timing and manner of these stages may vary depending on the process, but they will always be present.</li> <li>Use even small programming tasks to practice each of these stages.</li> </ul> <p>Thus, programming is much more than just writing code; it is part of a larger process. Always remember, we write code to be used, often by others. As beginners, we take on the roles of both the designer/programmer and the user. It's important to get used to separating these roles when designing and executing your programs.</p>"},{"location":"chapters/01_introduction/02_some_history/","title":"Some background on the C# language","text":""},{"location":"chapters/01_introduction/02_some_history/#a-brief-history","title":"A Brief History","text":"<p>C# is a modern, general-purpose, object-oriented, high-level programming language. Its syntax is similar to both C and C++, but it is designed to be easier to use than either of those languages. C# was developed in 2000 by Anders Hejlsberg as a direct competitor to Java. Anders also created Turbo Pascal and was the chief architect behind Delphi.</p> <p>Each C# program consists of one or more files with the <code>.cs</code> extension. These files are combined by the compiler to create an executable file.</p>"},{"location":"chapters/01_introduction/02_some_history/#the-net-framework","title":"The .NET Framework","text":"<p>C# is part of the .NET Framework, which also includes other languages like VB.NET, F#, and C++. The .NET Framework provides a vast collection of libraries and data types that are shared across these different languages.</p> <p>At the core of the .NET Framework is the Common Language Runtime (CLR), which is responsible for executing .NET programs. When you write code in C# (or another .NET language), it is first compiled into an intermediate form called the Common Intermediate Language (CIL). This intermediate code is then managed and executed by the CLR.</p> <p>This process is similar to how Java works, where source code is compiled into bytecode. However, C# takes this a step further by linking the intermediate code with the necessary libraries to create a program that can run efficiently on the target machine. While the compiled code is fast and efficient, it is still platform-independent because it needs to be recompiled to run on different operating systems.</p> <p>From the syllabus</p> <p>AQA: Understand why an intermediate language such as bytecode is produced (3.6.3.1/4.6.3.1).</p> <ul> <li>Bytecode is program code compiled from source code into an intermediate language that is designed for a software interpreter.</li> </ul> <p>If this seems a bit complex, don\u2019t worry. Most of this happens \"under the hood,\" but it\u2019s useful to have a basic understanding of the compilation process.</p>"},{"location":"chapters/01_introduction/02_some_history/#net-framework-vs-net-core","title":".NET Framework vs .NET Core","text":"<p>You might encounter both .NET Framework and .NET Core. In short, .NET Core is the open-source, cross-platform successor to .NET Framework. It is more versatile and designed to run on different operating systems. However, we will be using the .NET Framework by default in this course, as it is simpler to set up and use on Windows.</p>"},{"location":"chapters/01_introduction/02_some_history/#can-i-use-another-ide","title":"Can I Use Another IDE?","text":"<p>While we recommend using Visual Studio or VSCode for this course, you can write and compile your C# programs without these IDEs as long as the .NET Framework is installed on your computer. There are resources online that explain how to do this, but since the IDE makes the process much easier, we suggest sticking with it, especially as you\u2019re learning the basics.</p>"},{"location":"chapters/01_introduction/03_first_program/","title":"Your first program","text":"<p>It is traditional to begin by writing a simple program that displays a string to the screen. We\u2019ll use this exercise to explore some fundamental aspects of C# programming and get acquainted with using an Integrated Development Environment (IDE) like Visual Studio to create, save, compile, and run a basic program.</p>"},{"location":"chapters/01_introduction/03_first_program/#getting-started-with-visual-studio","title":"Getting Started with Visual Studio","text":"<p>Visual Studio is a professional-grade IDE, which stands for Integrated Development Environment. An IDE provides a suite of tools for building applications, including a text editor, compiler, and debugger. Although Visual Studio may seem overwhelming at first, don't be discouraged. With practice, it will become a powerful tool that simplifies your coding experience.</p> <p>You can download Visual Studio from visualstudio.com/downloads. Choose the Community edition, which is free and available for both Windows and Mac. If you\u2019re using Linux, download Visual Studio Code, along with the latest version of .NET. Visual Studio Code, together with the OmniSharp extension, will work fine for all the examples and exercises in this tutorial.</p>"},{"location":"chapters/01_introduction/03_first_program/#creating-your-first-c-console-application","title":"Creating Your First C# Console Application","text":"<ol> <li> <p>Start Visual Studio Community and go to <code>File -&gt; New -&gt; Project</code>. Select \u201cCreate New Project\u201d.</p> <p> Create New Project in Visual Studio 2019 </p> </li> <li> <p>In the next window, search for the Console App template:</p> <p> Select Console application template </p> </li> <li> <p>Configure the project by specifying the name and location where it will be stored:</p> <p> Configure the console application </p> </li> <li> <p>Click Create. The new project is now set up and includes a C# source code file named <code>Program.cs</code>.</p> </li> </ol>"},{"location":"chapters/01_introduction/03_first_program/#understanding-the-default-program-structure","title":"Understanding the Default Program Structure","text":"<p>By default, the <code>Program.cs</code> file contains the following code:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // YOUR CODE GOES HERE\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>The lines at the top of the file will be greyed out, except for <code>using System;</code>. You can safely delete the others as they are not needed for this simple program.</p> <p>Replace the comment <code>// YOUR CODE GOES HERE</code> with the following code:</p> <pre><code>Console.WriteLine(\"Hello, World!\");\nConsole.ReadKey();\n</code></pre>"},{"location":"chapters/01_introduction/03_first_program/#breaking-down-the-code","title":"Breaking Down the Code","text":"<p>There are five key components in this simple program:</p> <ol> <li> <p>Using Statements: These statements import namespaces that contain classes and methods for use in your program. For this basic example, only the <code>System</code> namespace is needed.</p> </li> <li> <p>Namespace: This is a way to organize code and avoid naming conflicts. The default namespace in this program matches the project name you chose earlier.</p> </li> <li> <p>Class: C# is an object-oriented language, and all code must be contained within a class. Here, <code>Program</code> is the name of our class.</p> </li> <li> <p>Main Method: This is the entry point of the program. Every C# console application must have a <code>Main</code> method. The <code>static</code> keyword indicates that it is a class method, and <code>void</code> means it does not return any value. The <code>args</code> parameter can hold command-line arguments, though we won\u2019t be using it in this example.</p> </li> <li> <p>Code Block: This is where your program logic goes, between the curly braces <code>{ ... }</code>.</p> </li> </ol> <p>Our program is just two lines long:</p> <ul> <li><code>Console.WriteLine(\"Hello, World!\");</code> - This line prints the text \"Hello, World!\" to the console.</li> <li><code>Console.ReadKey();</code> - This line waits for the user to press any key before closing the console window.</li> </ul>"},{"location":"chapters/01_introduction/03_first_program/#running-the-program","title":"Running the Program","text":"<p>Click the Start button in the toolbar (the green arrow) or press <code>F5</code>. If everything is correct, a console window will appear displaying the message \"Hello, World!\". Press any key to exit.</p> <p>If you see a red underline under <code>Console</code>, it means the <code>System</code> namespace is missing. Add <code>using System;</code> at the top of your file to resolve this.</p>"},{"location":"chapters/01_introduction/03_first_program/#task-enhancing-the-hello-world-application","title":"Task: Enhancing the Hello World Application","text":"<p>Enhance your application to prompt the user for their name and display it along with the date and time.</p> <p>To do this, replace the code inside the <code>Main</code> method with the following:</p> <pre><code>Console.WriteLine(\"\\nWhat is your name?\");\nvar name = Console.ReadLine();\nConsole.WriteLine(\"Hello, \" + name);\nConsole.WriteLine(\"Press any key to exit...\");\nConsole.ReadKey();\n</code></pre> <p>Can you predict what the program will now do?</p> <p>This code will prompt the user to enter their name, store it in a variable called <code>name</code>, and then greet the user with their name. It will also display a message explaining how to exit the program.</p>"},{"location":"chapters/01_introduction/03_first_program/#explanation-of-the-new-code","title":"Explanation of the New Code","text":"<ul> <li>The <code>\\n</code> is an escape sequence that moves the cursor to the next line.</li> <li><code>var name</code> declares a variable. The type of <code>name</code> will be determined at runtime, based on what the user enters.</li> <li>The <code>+</code> operator concatenates (joins) two strings together.</li> </ul> <p>Run the modified program to ensure it behaves as expected. If you copied and pasted the code, check for any incorrect quote marks, which may cause errors.</p> <p>Congratulations, you've created and run your first C# application!</p> <p>From the syllabus</p> <p>Understand and know how to declare and use a variable (3.1.1.2/4.1.1.2).</p> <ul> <li>A variable is a named area of memory. Each variable in C# is given a specific type, which determines the size and layout of the assigned memory, as well as the range of values that can be stored.</li> </ul>"},{"location":"chapters/01_introduction/04_printing_to_the_screen/","title":"Printing to the screen","text":"<p>From the syllabus</p> <p>Understand the differences between string concatenation, composite formatting, and string interpolation. Practice each method to become comfortable with displaying variables in formatted output.</p> <p>There are multiple ways to display content on the screen in C#. Let's explore some of the most commonly used methods:</p> <pre><code>string name = \"Mark\";\nvar date = DateTime.Now;\n\n// String concatenation:\nConsole.WriteLine(\"Hello \" + name);\n// Using composite formatting:\nConsole.WriteLine(\"Hello, {0}! Today is {1}, it's {2:HH:mm} now.\", name, date.DayOfWeek, date);\n// Using string interpolation:\nConsole.WriteLine($\"Hello, {name}! Today is {date.DayOfWeek}, it's {date:HH:mm} now.\");\n</code></pre> <p>In this example, we demonstrate three different techniques to print text to the console. Let\u2019s break down each approach:</p>"},{"location":"chapters/01_introduction/04_printing_to_the_screen/#understanding-the-code","title":"Understanding the Code","text":"<ol> <li> <p>Comments:    Lines beginning with <code>//</code> are comments. These lines are ignored by the compiler and serve to explain what the code is doing. Comments are invaluable for anyone reading your code, including your future self! Use comments to clarify complex logic or to note significant code sections. For multi-line comments, use the <code>/* ... */</code> syntax.</p> </li> <li> <p>String Concatenation: <pre><code>Console.WriteLine(\"Hello \" + name);\n</code></pre>    This method combines, or \"concatenates,\" multiple strings together using the <code>+</code> operator. In this example, the string <code>\"Hello \"</code> is joined with the value of the <code>name</code> variable. It\u2019s a straightforward technique but can become cumbersome when dealing with multiple variables.</p> </li> <li> <p>Composite Formatting: <pre><code>Console.WriteLine(\"Hello, {0}! Today is {1}, it's {2:HH:mm} now.\", name, date.DayOfWeek, date);\n</code></pre>    Here, numeric placeholders <code>{0}</code>, <code>{1}</code>, and <code>{2:HH:mm}</code> are used inside the string. They are replaced by the variables <code>name</code>, <code>date.DayOfWeek</code>, and <code>date</code> respectively, provided in the same order after the comma. This method allows for clear formatting but requires careful ordering of variables.</p> </li> <li> <p>String Interpolation: <pre><code>Console.WriteLine($\"Hello, {name}! Today is {date.DayOfWeek}, it's {date:HH:mm} now.\");\n</code></pre>    This is the most modern and flexible way to format strings in C#. The <code>$</code> symbol before the string allows variables to be directly embedded inside curly braces <code>{ }</code>. This technique makes the code more readable and less error-prone.</p> </li> <li> <p>Using DateTime:    In the example above, <code>DateTime.Now</code> retrieves the current date and time, storing it in the <code>date</code> variable. This allows us to display the current day and time dynamically.</p> </li> </ol>"},{"location":"chapters/01_introduction/04_printing_to_the_screen/#task-experimenting-with-print-methods","title":"Task: Experimenting with Print Methods","text":"<p>Modify the code to include additional information such as the user's age and the current year.</p> <ol> <li> <p>Declare two new variables, <code>age</code> and <code>currentYear</code>, and assign appropriate values:</p> <pre><code>int age = 25;\nvar currentYear = DateTime.Now.Year;\n</code></pre> </li> <li> <p>Use all three print methods to display a message including the user\u2019s name, age, and the current year. Add these lines to your code:</p> <pre><code>// String concatenation\nConsole.WriteLine(\"Hello \" + name + \", you are \" + age + \" years old.\");\n\n// Composite formatting\nConsole.WriteLine(\"Hello, {0}! You are {1} years old. The year is {2}.\", name, age, currentYear);\n\n// String interpolation\nConsole.WriteLine($\"Hello, {name}! You are {age} years old. The year is {currentYear}.\");\n</code></pre> </li> <li> <p>Run the code to observe how each method outputs the message.</p> </li> </ol>"},{"location":"chapters/01_introduction/04_printing_to_the_screen/#explanation-of-new-code","title":"Explanation of New Code","text":"<ul> <li>The variable <code>age</code> is declared as an <code>int</code> (integer) and assigned a value of 25.</li> <li><code>currentYear</code> is assigned the current year using <code>DateTime.Now.Year</code>.</li> <li>Each print statement includes both the name and age variables, and each uses a different formatting method.</li> </ul>"},{"location":"chapters/01_introduction/04_printing_to_the_screen/#conclusion","title":"Conclusion","text":"<p>You\u2019ve now explored three methods for printing to the console in C#. Each method has its use case and can be chosen based on the complexity and readability of the code you\u2019re working with.</p>"},{"location":"chapters/01_introduction/05_questions/","title":"Questions","text":""},{"location":"chapters/01_introduction/05_questions/#questions","title":"Questions","text":"<ul> <li>Open Visual Studio and create a new project for the Hello World application  </li> <li> <p>Enter the source code from the \"Hello World\" example:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello, World!);\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> </li> <li> <p>Compile and run</p> </li> <li>Enhance the program to store your name in two variables, one for your first name and the other your last name</li> <li>Print your name to the screen using these variables using each of the approaches suggested above.  Compile and run your program</li> <li> <p>Study the following program, and answer the questions below:</p> <pre><code>using System;\n\nnamespace volume\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int length;\n            int height;\n            int width;\n            int volume;\n\n            Console.Clear();\n            Console.Write(\"Enter length &gt;\");\n            length = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"Enter height &gt; \");\n            height = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"Enter width &gt; \");\n            width = Convert.ToInt32(Console.ReadLine());\n\n            volume = length * height * width;\n\n            Console.WriteLine($\"The volume of the box ({length}x{width}x{height}) is {volume}\");\n            Console.WriteLine(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ul> <li>What does the program do?</li> <li>What does <code>Console.ReadLine()</code> do?</li> <li>The variables, <code>length</code>, <code>width</code> etc are preceded by the keyword <code>int</code>.  What is the purpose of <code>int</code> in this context?</li> <li><code>Convert.ToInt32</code> is easy to read as \"Convert to a 32 bit integer\", but why is this necessary here?</li> <li>What is the meaning of <code>=</code> in this context?</li> <li>The \"Hello World\" program used <code>Console.WriteLine()</code>, this program uses <code>Console.Write()</code>.  What is the difference between them?</li> </ul> </li> </ul> <p>Create a new project for the program in question 5, enter the code, compile and run.  Add a title to print to the screen and add comments to identify the following features of the source code:</p> <ul> <li>program header</li> <li>statement to include a C# namespace (library)</li> <li>variable declarations</li> <li>output statement</li> <li>input statement</li> <li>assignment statement</li> </ul>"},{"location":"chapters/01_introduction/05_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Install Visual Studio Community Edition on a home computer  </li> <li>Create a directory on your computer for your programming projects  </li> <li>Set up a GitHub account </li> <li>Write a program to calculate the area of a triangle.  (The formula is \\(\\frac{height \\times base}{2}\\))</li> <li>Follow the Microsoft \"numbers in C#\" tutorial</li> </ol>"},{"location":"chapters/01_introduction/06_high_vs_low/","title":"High Level and Low Level Languages","text":"<p>In this section, we'll delve into the distinction between high-level and low-level languages, and explore how they relate to computer architecture and programming.</p> <p>From the syllabus</p> <p>Familiarize yourself with the concepts of high-level and low-level languages, and understand how code translation is performed by compilers and interpreters. Explore disassembly to see the machine's perspective on your code.</p>"},{"location":"chapters/01_introduction/06_high_vs_low/#high-level-vs-low-level-languages","title":"High-Level vs. Low-Level Languages","text":"<p>The chapter began with a comparison between high-level languages, which are designed for human readability, and low-level languages, which are closer to the hardware level and more challenging for humans to understand.</p>"},{"location":"chapters/01_introduction/06_high_vs_low/#high-level-languages","title":"High-Level Languages","text":"<p>High-level languages are designed to be easy for humans to read and write. These languages abstract away the complex details of the computer's hardware, allowing programmers to focus on solving problems without needing to know the intricacies of the underlying architecture. Examples include C#, Python, and Java.</p>"},{"location":"chapters/01_introduction/06_high_vs_low/#low-level-languages","title":"Low-Level Languages","text":"<p>Low-level languages, on the other hand, are closely tied to the specific hardware of a target machine. They include:</p> <ul> <li>Machine Code: The actual binary instructions executed by the processor.</li> <li>Assembly Language: A more human-readable version of machine code that still requires an assembler to convert it into machine code.</li> </ul> <p>These languages are rarely used except in scenarios where direct hardware control is needed, such as for systems programming, or when performance and memory efficiency are critical.</p>"},{"location":"chapters/01_introduction/06_high_vs_low/#key-differences","title":"Key Differences","text":"High-Level Language Low-Level Language Programmer Friendly: Easier to read and write Machine Friendly: Difficult for humans, easier for machines Portable: Can run on different types of hardware with minimal changes Non-Portable: Tied to specific hardware Requires Compiler/Interpreter: Needs to be translated into machine code Requires Assembler: Needs to be translated into machine code Memory Use: Less efficient Memory Use: More efficient Execution Speed: Typically slower due to abstraction Execution Speed: Faster due to closer hardware interaction"},{"location":"chapters/01_introduction/06_high_vs_low/#translating-high-level-code","title":"Translating High-Level Code","text":"<p>High-level languages must be translated into machine code for the processor to execute them. This is done using either a compiler or an interpreter:</p>"},{"location":"chapters/01_introduction/06_high_vs_low/#compilers","title":"Compilers","text":"<p>A compiler translates the entire source code into an executable machine code file. This file can then be run on the target machine without the need for the original source code.</p> <ul> <li> <p>Advantages:</p> <ul> <li>Faster execution time after compilation.</li> <li>Source code remains private once compiled.</li> <li>Errors are caught during the compilation phase.</li> </ul> </li> <li> <p>Disadvantages:</p> <ul> <li>Takes longer to compile large programs.</li> <li>Platform-specific: A compiled program may need recompilation for different systems.</li> </ul> </li> </ul> Overview of Compiler Process"},{"location":"chapters/01_introduction/06_high_vs_low/#interpreters","title":"Interpreters","text":"<p>An interpreter directly executes the source code line by line, without generating an intermediate machine code file.</p> <ul> <li> <p>Advantages:</p> <ul> <li>Easier debugging, as errors are caught as the code runs.</li> <li>Platform-independent: Source code can be run on any system with the appropriate interpreter.</li> </ul> </li> <li> <p>Disadvantages:</p> <ul> <li>Slower execution due to line-by-line interpretation.</li> <li>Source code needs to be available for execution.</li> </ul> </li> </ul> Overview of Interpreter Process"},{"location":"chapters/01_introduction/06_high_vs_low/#key-differences_1","title":"Key Differences","text":"Compiler Interpreter Translates entire source code at once Executes source code line by line Catches syntax errors before execution Errors are caught during execution Generates an independent executable file No standalone file; requires source code Faster execution after compilation Slower due to real-time interpretation Source code remains private Source code must be available"},{"location":"chapters/01_introduction/06_high_vs_low/#disassembling-high-level-code","title":"Disassembling High-Level Code","text":"<p>To further illustrate the differences, let's examine how high-level C# code is converted into low-level assembly code using Visual Studio's disassembler. Here\u2019s a simple C# program that sums two numbers and prints the result:</p> <pre><code>static void Main(string[] args)\n{\n    int a = 3;\n    int b = 4;\n    int sum = a + b;\n\n    Console.WriteLine(sum);\n    Console.ReadKey();\n}\n</code></pre>"},{"location":"chapters/01_introduction/06_high_vs_low/#viewing-the-assembly-code","title":"Viewing the Assembly Code","text":"<p>To view the low-level version of this code:</p> <ol> <li>Set a breakpoint in Visual Studio by clicking in the grey gutter next to a line of code.</li> <li>Run the program in Debug mode. It will pause at the breakpoint.</li> <li>From the Debug &gt; Windows menu, select Disassembly.</li> </ol> <p>You\u2019ll see the disassembled code, which looks like this:</p> <pre><code>static void Main(string[] args)\n{\n    // more code here\n02750881  nop  \n    int a = 3;\n02750882  mov         dword ptr [ebp-40h],3  \n    int b = 4;\n02750889  mov         dword ptr [ebp-44h],4  \n    int sum = a + b;\n02750890  mov         eax,dword ptr [ebp-40h]  \n02750893  add         eax,dword ptr [ebp-44h]  \n02750896  mov         dword ptr [ebp-48h],eax  \n\n    Console.WriteLine(sum);\n02750899  mov         ecx,dword ptr [ebp-48h]  \n0275089C  call        System.Console.WriteLine(Int32) (6C191938h)  \n027508A1  nop  \n    Console.ReadKey();\n027508A2  lea         ecx,[ebp-54h]  \n027508A5  call        System.Console.ReadKey() (6C190EE0h)  \n027508AA  nop  \n}\n</code></pre>"},{"location":"chapters/01_introduction/06_high_vs_low/#understanding-the-assembly-code","title":"Understanding the Assembly Code","text":"<ul> <li><code>mov</code> Instruction: Moves a value into a memory location. For example, the line <code>02750882  mov dword ptr [ebp-40h],3</code> stores the value <code>3</code> in a specific memory location.</li> <li>Registers: <code>eax</code>, <code>ecx</code>, etc., are registers in the CPU, used for quick access to data.</li> <li>Memory Addresses: <code>ebp-40h</code> is a memory address, and the <code>dword</code> keyword indicates that 32 bits (4 bytes) are being moved.</li> <li><code>call</code> Instruction: Calls a method or function. Here, it calls <code>Console.WriteLine()</code> and <code>Console.ReadKey()</code>.</li> </ul>"},{"location":"chapters/01_introduction/06_high_vs_low/#insights-from-assembly-code","title":"Insights from Assembly Code","text":"<ul> <li>High-level statements are broken down into multiple low-level instructions.</li> <li>Writing and understanding assembly code is more complex and hardware-specific.</li> <li>Assembly code operations are not English-like and require an understanding of the CPU\u2019s architecture.</li> </ul>"},{"location":"chapters/01_introduction/06_high_vs_low/#viewing-the-machine-code","title":"Viewing the Machine Code","text":"<p>The instructions can also be displayed in machine code (binary) format. Right-click in the disassembly window and select Show Code Bytes. For example, the instruction to store <code>3</code> in memory:</p> <pre><code>01420882 C7 45 C0 03 00 00 00 mov dword ptr [ebp-40h],3\n</code></pre> <ul> <li>The <code>03</code> is the value being moved.</li> <li>The remaining bytes correspond to the instruction and the memory address.</li> </ul>"},{"location":"chapters/01_introduction/06_high_vs_low/#conclusion","title":"Conclusion","text":"<p>This example demonstrates the complexity of low-level code compared to high-level code. Understanding the underlying machine operations is essential for tasks that require optimization or direct hardware interaction. However, for most programming tasks, high-level languages provide a more efficient and accessible approach.</p>"},{"location":"chapters/02_datatypes_and_variables/","title":"Introduction","text":"<p>In this chapter, you will learn to:</p> <ul> <li>Identify the difference between variables and constants.</li> <li>Use assignment to store values in variables and constants.</li> <li>Describe the use of data types and casting.</li> <li>Learn the difference between a value type and a reference type.</li> <li>Use comments effectively and understand their importance.</li> </ul> <p>C# is an explicitly, statically-typed language. This means that every variable must be assigned a data type when it is declared, and that type cannot change later in the program. In C#, it\u2019s not possible for a variable to exist without a defined type.</p> <p>To understand why this matters, consider the following examples:</p> <ul> <li><code>4</code></li> <li><code>\"4\"</code></li> <li><code>\"four\"</code></li> <li><code>4.0</code></li> </ul> <p>Each of these represents the value 4, but in a different way. They use different types of data to represent this value, so they need to be defined using different data types in our program, so the computer knows how to handle them correctly:</p> <ul> <li>The first, <code>4</code>, is a positive whole number with a numeric value, an integer (<code>int</code>).</li> <li>The second, <code>\"4\"</code>, is a single character, which has no numeric value, a character (<code>char</code>).</li> <li>The third, <code>\"four\"</code>, is a sequence of individual characters that spell out the word \"four\", but again, it has no numeric value, a string (<code>string</code>).</li> <li>The last, <code>4.0</code>, is a number that could include a fractional component; it has a numeric value, a floating-point number (<code>double</code>).</li> </ul> <p>Although the values of the first and last examples are numerically the same, they will be interpreted differently by the computer because they are different data types.</p> <p>This is true for all data types: each requires a different storage format and a different amount of memory. This affects how they are processed by the computer.</p> <p>The value of the data is stored in a variable, which is a named portion of the computer's memory. In C#, when we declare a variable, we also specify its data type:</p> <pre><code>int myInt = 4;\nchar myChar = '4';\nstring myString = \"four\";\nfloat myFloat = 4.0f;\n</code></pre> <p>Remember, each of these data items is just a pattern of binary digits (bits) when stored in the computer. The data type declared by the programmer determines how these bits are to be interpreted and what operations can be performed on them. For example, adding two integers with the <code>+</code> operator will yield a different result than adding two strings.</p> <p>When writing programs, it is important to first think about the data you will be working with and processing. Consider the type of data you need: Are they whole numbers, characters, strings of characters, or fractional numbers? Choosing the right data type is crucial for accurate and efficient data processing.</p> <p>This chapter will explore how variables are declared in C# and the importance of specifying their data type.</p>"},{"location":"chapters/02_datatypes_and_variables/01_variables/","title":"Variables and Constants","text":"<p>C# requires variables to be declared before they can be used, and they must be declared with a specific data type. This ensures that the correct amount of memory is allocated to store the expected data, especially for primitive (value) types.</p> <p>Data used in programs is given a name, or more formally, an identifier. It\u2019s good practice to choose a meaningful name that helps anyone reading the code, including yourself, understand what the data represents. For example, <code>firstName</code> is a more informative identifier than <code>fn</code> for a variable that stores someone's first name.</p> <p>During the course of a program, the value of a data item may change, which is why it's called a variable. In contrast, a constant represents a value that remains the same throughout the program\u2019s execution. Both variables and constants have a name, a defined data type, and a value.</p> <p>A constant is a data item with a fixed value, set by the programmer, which never changes while the program is running. For example:</p> <pre><code>const double PI = 3.14159;\n</code></pre> <p>Using constants is beneficial when a value is used multiple times in a program. This avoids having to type out the value each time, reducing the risk of errors and inconsistencies. Defining it once at the beginning of the code also makes it easier to update if needed.</p>"},{"location":"chapters/02_datatypes_and_variables/01_variables/#what-is-a-variable","title":"What is a Variable?","text":"<p>A variable is a named storage location in memory where data can be stored. </p> <p>From the syllabus</p> <p>Be able to explain the differences between a variable and a constant; Be able to explain the advantages of using named constants (3.1.1.6/4.1.1.6).</p> <ul> <li>A variable\u2019s value can change during the execution of a program, whereas a constant\u2019s value remains fixed. Constants make code easier to read, help avoid using \"magic numbers\", and allow for easier updates, reducing errors.</li> </ul> <p>All programs use named variables. A variable is associated with a location in memory, and its actual storage location is managed by the operating system. As programmers, we interact with the variable using its name to get or set its value.</p> <p>Understanding the concept of a variable is fundamental. We need to know how to create, assign a value to, modify, use, and eventually remove variables. At any point, the current values of all variables in a program make up the program state, which changes with each step of the program.</p> <p>All variables have:</p> <ul> <li>A Name: e.g., <code>age</code>, <code>isStudent</code>.</li> <li>A Type: e.g., <code>int</code> (integer), <code>bool</code> (boolean).</li> <li>A Value: e.g., 25, true.</li> </ul> <p>Unlike some other programming languages, like Python, C# requires a variable to be defined with a name and data type before it can be used.</p> <p>When naming a variable, use a name that clearly describes the data it holds, so it\u2019s easy to understand when reading the code. There are guidelines and rules for naming variables, but for now, remember that variable names cannot start with a digit, and they cannot be a keyword reserved by the language.</p> <p>From the syllabus</p> <p>AQA: Use meaningful identifier names and know why it is important to use them. (3.1.1.2/4.1.1.2).</p> <p>Consistent naming is important. There are two main naming conventions: Pascal Case (e.g., <code>FirstName</code>, <code>DateOfBirth</code>) and camelCase (e.g., <code>firstName</code>, <code>dateOfBirth</code>). Typically, local variables use camelCase. This is summarized in the table below:</p> Identifier Type Naming Convention Example Local variables, parameters camelCase <code>firstName</code>, <code>age</code> Methods, properties, classes Pascal Case <code>PackOfCards</code>, <code>Person</code>"},{"location":"chapters/02_datatypes_and_variables/01_variables/#declaring-and-using-variables","title":"Declaring and Using Variables","text":"<p>To declare a new variable in your code, you need to:</p> <ul> <li>Specify a type: e.g., <code>int</code>.</li> <li>Provide a name: e.g., <code>age</code>.</li> <li>Optionally, provide an initial value: e.g., <code>19</code> (this is called initialization).</li> </ul> <p>Variables are assigned values using the <code>=</code> operator:</p> <pre><code>string firstName;\nint age;\n\nfirstName = \"Peter\";\nage = 17;\n</code></pre> <p>In this code, we declare two variables: <code>firstName</code> (a <code>string</code>) and <code>age</code> (an <code>int</code>). Their purpose is clear from their names. Then we assign the value \"Peter\" to the first and 17 to the second. Note that the <code>=</code> operator should be read as \"is assigned to,\" so it means \"the value 'Peter' is assigned to the variable <code>firstName</code>,\" rather than \"firstName equals Peter\" (which wouldn\u2019t make sense mathematically).</p>"},{"location":"chapters/02_datatypes_and_variables/01_variables/#local-vs-global-variables","title":"Local vs Global Variables","text":"<p>Variables can be local or global. Local variables can only be used in the block of code where they are declared, such as a method (we\u2019ll cover methods in Chapter 9). This is known as variable scope. In contrast, global variables can be used anywhere in the program.</p>"},{"location":"chapters/02_datatypes_and_variables/01_variables/#value-and-reference-types","title":"Value and Reference Types","text":"<p>Data types in C# can be categorized as either <code>value</code> types or <code>reference</code> types. This may seem challenging initially, but it\u2019s important to understand the distinction, and we\u2019ll revisit this concept throughout the course.</p> <p>Value Types store their actual values in the program\u2019s stack memory and exist while they are in scope. For example, a variable declared in <code>main()</code> is stored in the stack, an area of memory allocated for the program, until the program ends. Primitive data types such as <code>int</code>, <code>float</code>, and <code>bool</code> are value types.</p> <p>Reference Types store a reference or address in the stack, pointing to memory allocated on the heap. The heap is an area of memory managed by the operating system, dynamically allocated as needed by the program.</p> <p>This distinction makes sense: when an <code>int</code> is declared, the system allocates a fixed 32 bits of memory to store that data. However, when a <code>string</code> is declared, the system doesn\u2019t know its length in advance, so memory is allocated dynamically from the heap.</p> <p>Note: Some languages have an explicit pointer type, which points to a location in memory. While pointers can be used in C#, they are considered unsafe, so we\u2019ll avoid them. Strictly speaking, a reference in C# is not a pointer but a constant pointer. This distinction is complex, so remember that a reference type does not store its value directly; it stores the address where the value is stored.</p> <p>To illustrate, consider the following:</p> <pre><code>int age = 45;\nchar gender = 'M';\nstring firstName = \"Peter\";\n</code></pre> Value and Reference Types <p>If the following changes are made to our variables:</p> <pre><code>age = 27;\ngender = 'M';\nfirstName = \"Harry\";\n</code></pre> <p>The memory map now looks like:</p> Value and Reference Types <p>Changing a value type modifies its value directly in the stack, but changing a reference type (such as a string) creates a new section of memory for the new value, and the address (reference) is updated. </p> <p>The previously allocated block of memory will be cleaned up by the garbage collector.</p> <p>If a reference type variable has not been allocated memory on the heap, it is assigned a value of null, indicating that the reference type object has no value.</p> <p>From the syllabus</p> <p>Variables declared as a pointer or reference data type are used as stores for memory addresses of objects created at runtime, i.e., dynamically.</p>"},{"location":"chapters/02_datatypes_and_variables/01_variables/#the-var-keyword","title":"The <code>var</code> Keyword","text":"<p>Although variables should generally be declared with a data type, C# allows the data type to be determined automatically at runtime if the <code>var</code> keyword is used:</p> <pre><code>var firstName = \"Harry\";\nvar age = 17;\n</code></pre> <p>In this example, the compiler infers the type of <code>firstName</code> as <code>string</code> because it is initialized with a string value, and the type of <code>age</code> as <code>int</code> because it is initialized with an integer.</p> <p>When using <code>var</code>, the variable must be initialized with a value.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/","title":"Data Types","text":"<p>From the syllabus</p> <p>Understand the concept of a data type (3.1.1.1/4.1.1.1); Understand and use integer, real/float, Boolean, character, string, date/time, pointer/reference, records/structs, arrays/lists (3.1.1.1/4.1.1.1).</p> <p>A data type describes the kind of data being stored or processed by a program, such as character or numeric values. Different programming languages define different data types, and many allow users to create their own custom types from these built-in ones.</p> <p>A data type is a set of values that share similar characteristics, such as:</p> <ul> <li>Name: e.g., <code>int</code> or <code>bool</code>.</li> <li>Size: the amount of memory they occupy, measured in bytes or bits.</li> <li>Default Value: the initial value they take, e.g., <code>0</code> for integers.</li> </ul>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#primitive-data-types-in-c","title":"Primitive Data Types in C","text":"<p>The following are the basic, or primitive, data types used in C#:</p> <ul> <li>Integer types: <code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code></li> <li>Real floating-point types: <code>float</code>, <code>double</code></li> <li>Real type with decimal precision: <code>decimal</code></li> <li>Boolean type: <code>bool</code></li> <li>Character type: <code>char</code></li> <li>String: <code>string</code></li> <li>Object type: <code>object</code></li> </ul> <p>These are called primitive data types<sup>1</sup> because they are built into the C# language. The following table summarizes their characteristics:</p> Type Default Value Minimum Maximum Size (bytes) sbyte 0 -128 127 1 byte 0 0 255 1 short 0 -32768 32767 2 ushort 0 0 65535 2 int 0 -2147483648 2147483647 4 uint 0u 0 4294967295 4 long 0L -9223372036854775808 9223372036854775807 8 ulong 0UL 0 18446744073709551615 8 float 0.0f \u00b11.5 \u00d7 10<sup>-45</sup> \u00b13.4 \u00d7 10<sup>38</sup> 4 double 0.0d \u00b15.0 \u00d7 10<sup>-324</sup> \u00b11.7 \u00d7 10<sup>308</sup> 8 decimal 0.0m \u00b11.0 \u00d7 10<sup>-28</sup> \u00b17.9 \u00d7 10<sup>28</sup> 16 bool false true false 1 bit char '\\u0000' '\\u0000' '\\uffff' 2 string null - - - object null - - -"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#integer-types","title":"Integer Types","text":"<p>Integer types are used for whole numbers. Each type varies by the range of values it can hold, depending on the amount of memory allocated and whether the numbers are signed (both positive and negative) or unsigned (positive only). Of these, the most commonly used is <code>int</code>, which uses 32 bits.</p> <p>Note</p> <p>Integer values can be represented in different notations:  - Decimal (base 10): <code>int num = 20;</code> - Hexadecimal (base 16): <code>int num = 0x14;</code> - Binary (base 2): <code>int num = 0b10100;</code></p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#real-floating-point-types","title":"Real Floating-Point Types","text":"<p>Real floating-point types are used for numbers with a fractional component. C# provides three such types:</p> <ul> <li>float (single precision)</li> <li>double (double precision, default for floating-point numbers)</li> <li>decimal (decimal precision, often used for financial calculations)</li> </ul> <p>Because all floating-point numbers default to <code>double</code> in C#, you need to use the 'f' suffix for <code>float</code> and 'm' for <code>decimal</code>:</p> <pre><code>float myFloat = 3.14f;\ndecimal myDecimal = 3.14m;\n</code></pre> <p>Floating-point numbers are an approximation of mathematical real numbers, meaning that there are an infinite number of values between any two real numbers. However, computers use a fixed number of bits to represent them, which can lead to precision issues.</p> <p>Example: Precision Differences</p> <pre><code>// Declare some variables\nfloat floatPI = 3.141592653589793238f;\ndouble doublePI = 3.141592653589793238;\n\n// Print the results on the console\nConsole.WriteLine(\"Float PI is: \" + floatPI);\nConsole.WriteLine(\"Double PI is: \" + doublePI);\n\n// Console output:\n// Float PI is: 3.141593\n// Double PI is: 3.14159265358979\n</code></pre> <p>Here, the <code>float</code> value is rounded to 7 digits, whereas the <code>double</code> retains up to 15 digits. If you require this level of precision, use <code>double</code>.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#floating-point-precision-errors","title":"Floating-Point Precision Errors","text":"<p>Floating-point arithmetic can produce unexpected results due to precision limitations. Consider the following example:</p> <pre><code>float f = 0.1f;\nConsole.WriteLine(f); // 0.1\n\ndouble d = 0.1f;\nConsole.WriteLine(d); // 0.100000001490116\n\nfloat ff = 1.0f / 3;\nConsole.WriteLine(ff); // 0.3333333\n\ndouble dd = ff;\nConsole.WriteLine(dd); // 0.333333343267441\n</code></pre> <p>These rounding errors can be avoided by using the <code>decimal</code> type, which uses more memory (16 bytes) and performs calculations with the decimal system rather than binary. This makes <code>decimal</code> ideal for financial applications where precision is critical. However, because they require more memory and processing power, operations with <code>decimal</code> are slower than with <code>double</code>.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#boolean-type","title":"Boolean Type","text":"<p>The <code>bool</code> type has only two values: <code>true</code> and <code>false</code>. It is primarily used for logical expressions and decision-making.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#character-type","title":"Character Type","text":"<p>The <code>char</code> type represents a single character, using 16-bit Unicode encoding. Characters are enclosed in single quotes, e.g., <code>'a'</code>, <code>'r'</code>. Each <code>char</code> has a corresponding binary code, either ASCII or Unicode.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#string-type","title":"String Type","text":"<p>A <code>string</code> is a sequence of characters enclosed in double quotes, e.g., <code>\"Hello\"</code>. <code>strings</code> in C# are actually objects and are more complex than primitive types.</p>"},{"location":"chapters/02_datatypes_and_variables/02_data_types/#object-type","title":"Object Type","text":"<p>The <code>object</code> type is the base type for all .NET types. Any type in C# can be assigned to an <code>object</code> variable. This makes it very flexible but also more memory-intensive.</p> <p>We'll explore how these various types can be organized into data structures such as arrays, lists, structs, and classes in future lessons.</p> <ol> <li> <p>Strictly speaking, the <code>string</code> and <code>object</code> types are not primitive but reference data types. Primitive data types are also called value types because their values are stored directly on the program stack. Reference types, on the other hand, store a memory address pointing to the actual data, which is located in dynamic memory (the heap).\u00a0\u21a9</p> </li> </ol>"},{"location":"chapters/02_datatypes_and_variables/03_questions/","title":"Questions","text":"<p>Study the following program and answer the questions below:</p> <pre><code>using System;\n\nnamespace circle\n{\n    class circle\n    {\n        /* Program to calculate the circumference of a circle when the radius is known.\n        NB. This program will not compile - you need to correct the errors */\n        static void Main(string[] args)\n        {\n            const double PI = 3.14159;  // Corrected value of PI\n            int radius;\n            double diam;\n            double circ; // Corrected type for circumference\n\n            Console.WriteLine(\"Program to calculate the circumference of a circle\");\n            Console.Write(\"Enter circle radius: \");\n            radius = Convert.ToInt32(Console.ReadLine()); // Added conversion\n            diam = radius + 2;\n            diam = PI * diam; // Added missing semicolon\n            circ = diam; // Assigning value to circ\n            Console.WriteLine(\"The circumference of the circle = \" + circ.ToString()); // Corrected output line\n            Console.ReadLine(); // Added closing parenthesis\n        }\n    }\n}\n</code></pre> <ol> <li>The program contains a number of syntax errors. Can you spot them? </li> <li>The program contains a number of logic errors. Can you spot them?</li> <li>What runtime errors might occur?</li> <li>Explain how the program outputs to the console window, specifically mentioning the methods used.</li> <li>Explain how user input is processed and converted into the correct data type.</li> <li>Why might the input(s) need to be converted into another type of data?</li> <li>Modify the program to output the area of the circle, as well as the circumference.</li> <li>A teacher is planning to write a program to store test marks for their pupils. What data types should be chosen for the following values?<ul> <li>Surname of the student</li> <li>Raw score for the test</li> <li>Percentage mark for the test</li> <li>Final grade awarded</li> <li>Whether the student has passed or failed the test</li> </ul> </li> </ol>"},{"location":"chapters/02_datatypes_and_variables/03_questions/#programming-task-temperature-conversion","title":"Programming Task: Temperature Conversion","text":"<ol> <li> <p>Write a program that converts a temperature in degrees Fahrenheit into Celsius. </p> <p>Tip</p> <p>What variables will you need? What should you call them, and what type should they be? How can you test the program? What runtime errors might occur?</p> </li> <li> <p>Extend the program to reverse the operation, i.e., convert Celsius into Fahrenheit.</p> </li> <li> <p>What is the value of the integer variable <code>answer</code> after executing each of the following statements (% is the modulus operator)?     a. <code>answer = 35 / 7</code>;     b. <code>answer = 17 / 2</code>;     c. <code>answer = 17 % 2</code>;  </p> </li> <li> <p>How would the value stored in <code>answer</code> differ if it was of type <code>double</code>?     a. <code>answer = 35 / 7</code>;     b. <code>answer = 17 / 2</code>;     c. <code>answer = 17 % 2</code>;  </p> </li> <li> <p>Look up the following terms: \"Syntax error,\" \"Logic error,\" and \"Runtime error.\" Given the statement <code>CelTemp = (FahrTemp - 32) * 5 / 9;</code>, make changes to the statement to generate each of the three different types of error:</p> </li> </ol> Type of error Modified statement Effect of error Syntax error Logic error Runtime error"},{"location":"chapters/02_datatypes_and_variables/03_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li> <p>What data types would be most appropriate for the following values:    a. 52     b. -115     c. 97     d. 12.345     e. 8923.123456     f. 3456.091124875956542151256683467</p> </li> <li> <p>Write a program that compares two real numbers accurately to at least 0.000001.</p> </li> <li> <p>Declare two variables of type <code>int</code>. Assign them the values 8 and 5. Swap their values and print them to the screen.</p> </li> <li> <p>A college system wants to keep track of their students. Each student record will have both first name and last name recorded, their age, their gender, and a unique student number in the range 20210000 through to 20219999. Declare appropriate variables to hold this data.</p> </li> <li> <p>Write a program that inputs the length and width of a rectangular garden. Calculate the area of the garden and the cost of turfing a lawn if a 1m un-turfed border is around the perimeter of the garden. Assume the cost of turf is 10 currency units per square meter.</p> </li> </ol>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/","title":"Crash Course in Binary","text":"<p>Everything that takes place in a computer depends on two-state switches. Each switch can be either on or off, which can be represented as either a \\(0\\) or a \\(1\\) (False or True).</p> <p>We are familiar with the decimal (or denary) system, where each digit occupies a place equivalent to a power of \\(10\\) (base \\(10\\)). In contrast, a two-state switch only needs a two-number system, known as binary (base \\(2\\)), where each digit occupies a place equivalent to a power of \\(2\\).</p> <p>Regardless of the base we are using, the digit with the greatest impact on the value is known as the most significant digit, while the digit with the least impact is referred to as the least significant digit.</p> <p>Let\u2019s start with denary and take the number \\(245_{10}\\) as an example. This number consists of:</p> <ul> <li>\\(2\\) hundreds</li> <li>\\(4\\) tens</li> <li>\\(5\\) ones (units)</li> </ul> <p>Thus, \\((2 \\times 100) + (4 \\times 10) + (5 \\times 1) = 245\\).</p> <p>That is:</p> \\(10^{3}\\) \\(10^{2}\\) \\(10^{1}\\) \\(10^{0}\\) 0 2 4 5 <p>Our number system also accommodates numbers with fractional parts. Thus, \\(245.68_{10}\\) would be represented as:</p> <p>\\((2 \\times 100) + (4 \\times 10) + (5 \\times 1) + (6 \\times \\frac{1}{10}) + (8 \\times \\frac{1}{100}) = 245.68\\)</p> <p>That is:</p> \\(10^{3}\\) \\(10^{2}\\) \\(10^{1}\\) \\(10^{0}\\) . \\(10^{-1}\\) \\(10^{-2}\\) \\(10^{-3}\\) 0 2 4 5 . 6 8 0 <p>Now, let's compare the principle of positional value with the binary representation of the decimal number \\(13_{10}\\).</p> <p>The column headings for our binary system and their respective values are:</p> \\(2^{7}\\) \\(2^{6}\\) \\(2^{5}\\) \\(2^{4}\\) \\(2^{3}\\) \\(2^{2}\\) \\(2^{1}\\) \\(2^{0}\\) 128 64 32 16 8 4 2 1 <p>Thus, \\(13\\) will be one lot of \\(8\\), one lot of \\(4\\), and one lot of \\(1\\):</p> <p>Hence, \\((1 \\times 8) + (1 \\times 4) + (1 \\times 1) = 13\\).</p> <p>That is:</p> \\(2^{3}\\) \\(2^{2}\\) \\(2^{1}\\) \\(2^{0}\\) 1 1 0 1"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#range-of-values","title":"Range of Values","text":"<p>This has significant implications for our data types, memory allocation, and the range of values that can be stored in memory. Clearly, if we have only a single bit, then only two different values can be stored: \\(0\\) and \\(1\\). This is all we need for a <code>bool</code> data type.</p> <p>How many different values can we store in \\(8\\) bits? The answer is \\(2^{8}\\), or \\(256\\). Accounting for zero, this means a byte of memory can have a range of values between \\(0\\) and \\(255\\). Referring to the table of C# data types, we can see this is the case with the <code>byte</code> data type. The <code>sbyte</code> includes both negative and positive numbers, thus allowing the same range of values but with different magnitudes.</p> <p>Consequently, our <code>int</code> data type, which has \\(4\\) bytes (or \\(32\\) bits) allocated to it, will have a range of \\(2^{32}\\) different values, both negative and positive.</p>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#signed-and-unsigned-numbers","title":"Signed and Unsigned Numbers","text":"<p>Using the binary number system to represent voltages (on or off) presents a challenge when needing a third symbol to represent a minus sign ('-'). We must use the two symbols we have, '0' and '1', to represent both the size and the sign of any number. There are various methods to do this, but here we will consider the two's complement method. Two's complement representation uses the most significant bit as the sign bit, which is always negative. Consider the following table:</p> \\(2^{-2}\\) \\(2^{1}\\) \\(2^{0}\\) Decimal 0 0 0 0 0 0 1 1 0 1 0 2 0 1 1 3 1 0 0 -4 1 0 1 -3 1 1 0 -2 1 1 1 -1 <p>Each of the negative numbers now has a \\(1\\) as its most significant bit, while the positive numbers have \\(0\\) in that position. Take note of some other observations:</p> <ul> <li>The most negative value has \\(1\\) in the most significant bit, and all other values are set to \\(0\\).</li> <li>For \\(-1\\), every bit is set to \\(1\\).</li> <li>The most positive value has \\(1\\) in every position except for the most significant bit, which is \\(0\\).</li> <li>Using \\(3\\) bits, the number of values possible is \\(2^3 = 8\\), but the range is \\(-4\\) to \\(+3\\).</li> </ul>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#converting-decimal-to-twos-complement-binary","title":"Converting Decimal to Two's Complement Binary","text":"<p>There are two methods for converting decimal to two's complement. Before using either method, convert the decimal integer to binary. Ignore whether the decimal number is negative; treat it as positive and follow either method 1 or 2 below:</p> <ul> <li>Method 1: Invert all of the binary values, and then add \\(1\\).</li> <li>Method 2: Start with the least significant bit, copy down all values up to and including the first \\(1\\) encountered, and then flip the remaining digits.</li> </ul> <p>For example, using Method 1, let\u2019s convert \\(-23\\):</p> <ol> <li>Convert \\(23\\) to binary: \\(00010111_2\\)</li> <li>Invert all the digits: \\(11101000_2\\)</li> <li>Add \\(1\\): \\(11101001_2\\)</li> </ol> <p>This can be illustrated with some C# code:</p> <pre><code>static void Main(string[] args)\n{\n    int value = 23;\n    Console.WriteLine($\"{value} in binary is: {Convert.ToString(value,2)}\");\n    value = ~value;\n    Console.WriteLine($\"Flip the bits  : {Convert.ToString(value,2)} ({value})\");\n    value++;\n    Console.WriteLine($\"Add 1          : {Convert.ToString(value,2)} ({value})\");\n}\n</code></pre> <p>This code gives the following output:</p> <pre><code>23 in binary is: 10111\nFlip the bits  : 11111111111111111111111111101000 (-24)\nAdd 1          : 11111111111111111111111111101001 (-23)\n</code></pre> <p>The bitwise operator <code>~</code> (see chapter 3) performs a NOT operation on each bit, changing a <code>1</code> to a <code>0</code> and vice versa.</p>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#fractional-numbers","title":"Fractional Numbers","text":"<p>Similar to denary, binary numbers with fractional parts work in the same way, where the column headings after the binary point will be \\(\\frac{1}{2}\\), \\(\\frac{1}{4}\\), \\(\\frac{1}{8}\\), etc.</p> \\(2^{3}\\) \\(2^{2}\\) \\(2^{1}\\) \\(2^{0}\\) . \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) \\(2^{-4}\\) 8 4 2 1 0.5 0.25 0.125 0.0625 <p>Consider the binary value \\(1001.1100_{2}\\):</p> \\(2^{3}\\) \\(2^{2}\\) \\(2^{1}\\) \\(2^{0}\\) . \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) \\(2^{-4}\\) 1 0 0 <pre><code>|    1    | . |    1    |    1    |    0    |    0    |\n</code></pre> <p>This can be calculated as follows:</p> <p>\\(1 \\times 8 + 0 \\times 4 + 0 \\times 2 + 1 \\times 1 + 1 \\times 0.5 + 1 \\times 0.25 + 0 \\times 0.125 + 0 \\times 0.0625 = 9.75_{10}\\).</p>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#fixed-and-floating-point-representation","title":"Fixed and Floating Point Representation","text":"<p>With fixed-point representation, the binary point is placed at a fixed position, typically to the right of the whole number. This restricts the range of values that can be stored, as moving the binary point affects the scale.</p> <p>In contrast, floating-point representation uses a formula for dynamic placement of the binary point, allowing for a much wider range of values. A floating-point number is typically expressed in the form of <code>sign \u00d7 significand \u00d7 base^exponent</code>.</p> <p>While this allows for greater flexibility, floating-point arithmetic can introduce rounding errors. This is an important consideration when performing calculations in programming.</p>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#hexadecimal-system","title":"Hexadecimal System","text":"<p>The hexadecimal (or hex) system provides a convenient shorthand for binary representation. Since \\(16\\) is \\(2^4\\), each hex digit corresponds to \\(4\\) binary digits. Thus, the binary representation can be easily converted to hex and vice versa.</p> <p>For example, the binary number \\(11010101_2\\) can be grouped into sets of four digits from the right:</p> Binary Hex 1101 D 0101 5 <p>Thus, \\(11010101_2\\) is equal to \\(D5_{16}\\).</p>"},{"location":"chapters/02_datatypes_and_variables/04_crash_course_in_binary/#exercises","title":"Exercises","text":"<ol> <li>Write a C# program to convert a decimal number to binary.</li> <li>Convert the binary number \\(1011.0110_2\\) to decimal.</li> <li>Write a program to demonstrate signed and unsigned overflow for an integer.</li> </ol>"},{"location":"chapters/03_operators_errors/","title":"Operators and Handling Errors","text":"<p>In this chapter</p> <ul> <li>Apply arithmetic operators to values</li> <li>Learn other operators including comparison, logical and binary operators</li> <li>Describe syntax errors, logic errors, and runtime errors</li> <li>Learn how to cast one data type to another\u200b</li> </ul> <p>At its heart the computer is really just a very big calculator, taking in data and processing that data using a variety of different operators.  These operators include:</p> <ul> <li>Arithmetic: plus, minus, multiply etc.</li> <li>Assignment: assigning values to variables</li> <li>Comparison: comparing two literal values or variables</li> <li>Logical: operators that work on Boolean data types</li> <li>Binary: to carry out operations on binary digits (bits)</li> <li>Type conversion: to convert from one data type to another</li> </ul> <p>There is an order or precedence with these operators. Just as in Maths multiplication takes precedence over addition but when using complex expressions it is advisable to use brackets to force precedence:  brackets, division and multiplication, addition and subtraction.</p> <p>Here we will review each of these operators categories and how they are used with C#.</p>"},{"location":"chapters/03_operators_errors/01_arithmetic_operators/","title":"Arithmetic Operators","text":"<p>From the syllabus</p> <p>AQA: Be familiar with and be able to use ... (3.1.1.3/4.1.1.3)</p> <ul> <li>Addition, subtraction, multiplication, real/float division, integer division (including remainders), exponentiation, rounding, truncation</li> </ul> <p>The table summarises the standard set of arithmetic operators:</p> Operator Description Example + Adds two values <code>int n = a + b;</code> - Subtracts two values <code>int n = a - b;</code> * Multiplies two values <code>int n = a * b;</code> / Divides dividend by divisor <code>int n = a / b;</code> % Modulus, remainder after integer division <code>int n = a % b;</code> ++ Increment by one <code>int n = a++;</code> -- Decrement by one <code>int n = a--;</code> <p>The operators for addition, subtraction, and multiplication should present no problems as these work just the same as in Mathematics. However, division is less straightforward. When you divide an integer by another integer in C#, the result is also an integer, specifically the integer part of the answer, ignoring anything after the decimal point. The result is always truncated (rounded down), not rounded to the nearest integer.</p> <p>For example:</p> <pre><code>int cake = 15;\ncake = cake / 4; // cake will be 3\n</code></pre> <p>In this case, the variable <code>cake</code> will contain <code>3</code>, not <code>3.75</code>. Conversely, if you use a <code>double</code> type:</p> <pre><code>double cake = 15;\ncake = cake / 4; // cake will be 3.75\n</code></pre> <p>Now, <code>cake</code> will correctly hold <code>3.75</code> as it can store decimal values.</p> <p>The modulus operator <code>%</code> performs integer division but returns the remainder. For instance, <code>9 % 2</code> yields <code>1</code>.</p> <p>Warning</p> <p>Integer division by <code>0</code> will result in a runtime error, so always ensure your divisor is not zero.</p> <p>For incrementing and decrementing, C# offers convenient operators:</p> <pre><code>int age = 45;\nage++; // age is now 46\nint x = 3;\nx--; // x is now 2\n</code></pre> <p>The <code>++</code> operator increments a variable, while <code>--</code> decrements it. These operators can be used either as postfix or prefix, yielding different results:</p> <pre><code>int a = 4;\nint b = 5;\nConsole.WriteLine(a + (b++));   // Outputs 9\nConsole.WriteLine(a + b);       // Outputs 10 (b is now 6)\nConsole.WriteLine(a + (++b));   // Outputs 11 (b is incremented before the addition)\nConsole.WriteLine(a + b);       // Outputs 11\n</code></pre> <p>What will be printed to the screen after each operation? If you\u2019re uncertain, write the code and check!</p> <p>C# does not have an operator for exponentiation. Instead, we use the <code>Math</code> class:</p> <pre><code>double Result = Math.Pow(2, 3); // Result is 8\n</code></pre> <p>Both parameters must be <code>double</code>, and the result is also a <code>double</code>.</p> <p>To round or truncate values, we utilize methods from the <code>Math</code> class. Here\u2019s an illustration:</p> <pre><code>float Number = 3.456789f;\nConsole.WriteLine(Number);                  // Outputs 3.456789\nConsole.WriteLine(Math.Round(Number, 2));   // Outputs 3.46\nConsole.WriteLine(Math.Truncate(Number));    // Outputs 3\n</code></pre>"},{"location":"chapters/03_operators_errors/02_comparison_operators/","title":"Comparison Operators","text":"<p>From the syllabus</p> <p>AQA: Be familiar with and be able to use ... (3.1.1.4/4.1.1.4)}</p> <ul> <li>equal to, not equal to, less than, greater than, less than or equal to, greater than or equal to</li> </ul> <p>Comparison operators are used to compare two or more values/variables returning either <code>true</code> or <code>false</code> (boolean values).  They work as you would expect from Maths, in the table below we'll assume <code>a = 4</code> and <code>b = 5</code>:</p> Operator Description Example <code>&gt;</code> greater than <code>a &gt; b</code> -&gt; False <code>&lt;</code> less than <code>a &lt; b</code> -&gt; True <code>&gt;=</code> greater than, or equal to <code>a &gt;= b</code> -&gt; False <code>&lt;=</code> less than, or equal to <code>a &lt;= b</code> -&gt; True <code>==</code> equal to <code>a == b</code> -&gt; False <code>!=</code> not equal to <code>a != b</code> -&gt; True <p>Be careful with <code>==</code> and do not confuse it with the assignment operator <code>=</code>.</p>"},{"location":"chapters/03_operators_errors/03_assignment_operator/","title":"Assignment operator","text":"<p>As noted this is the <code>=</code> operator.  Be careful with the difference between assignment and equality:</p> <pre><code>int a = 10;     // setting an initialiser (using =)\nint b = a;      // a and b are equal (using =)\nif (a == b)     // testing for equality using ==\n{\n    //\n}         \n</code></pre> <p>The same variable can be assigned a different value during the program, the old value being lost when the new value is assigned.  When the variable is declared it can be given a start value, an initialiser.  Compound initialisation is permitted:</p> <pre><code>    int a, b, c;\n    a = b = c = 10;\n</code></pre> <p>An assignment statement evaluates the right-hand size of the expression first producing a value, before assigning (copying) that value to the variable.  If we try to read the value of the variable before it has been assigned the default value for that variable, according to its data type, will be returned (see table in Chapter 2).</p> <p>Some more syntactic sugar is abbreviated assignment e.g.</p> <pre><code>    int a = 12;\n    a += 2;         // same as a = a + 2, a is now 12\n    a *= 3;         // same as a = a * 3, a is now 36\n    a /= 3;         // same as a = a /3, a is now 4\n</code></pre>"},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/","title":"Logical and Bitwise Operators","text":""},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/#logical-operators","title":"Logical Operators","text":"<p>From the syllabus</p> <p>AQA: Be familiar with and be able to use ... (3.1.1.4/4.1.1.4)</p> <ul> <li>NOT, AND, OR, XOR</li> </ul> <p>Logical operators work on Boolean values (true or false), returning a Boolean result. In the table below, assume <code>a = true</code> and <code>b = false</code>:</p> Operator Description Example <code>&amp;&amp;</code> AND <code>a &amp;&amp; b</code> -&gt; False <code>\\|\\|</code> OR <code>a \\|\\| b</code> -&gt; True <code>!</code> NOT <code>!a</code> -&gt; False <p>Example</p> <pre><code>bool a = true;\nbool b = false;\nConsole.WriteLine(a &amp;&amp; b);              // false\nConsole.WriteLine(a || b);              // true\nConsole.WriteLine(!a);                  // false\nConsole.WriteLine(b || true);           // true\n</code></pre>"},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operators are similar to logical operators but operate at the bit level (0 and 1). These operators can be challenging to understand but are essential in various applications, especially in low-level programming and performance optimization.</p> <p>In the table below, assume <code>a = 5</code> (binary <code>0101</code>) and <code>b = 9</code> (binary <code>1001</code>):</p> Operator Description Example <code>&amp;</code> Bitwise AND <code>a &amp; b</code> -&gt; <code>1</code> <code>\\|</code> Bitwise OR <code>a \\| b</code> -&gt; <code>13</code> <code>^</code> Bitwise XOR <code>a ^ b</code> -&gt; <code>12</code> <code>~</code> Bitwise NOT <code>~a</code> -&gt; <code>-6</code> <p>Also, two shift operators:</p> Operator Description Example <code>&lt;&lt; n</code> Shift bits to the left by <code>n</code> places <code>a &lt;&lt; 1</code> -&gt; <code>10</code> (equivalent to <code>a * 2</code>) <code>&gt;&gt; n</code> Shift bits to the right by <code>n</code> places <code>b &gt;&gt; 2</code> -&gt; <code>2</code> (equivalent to <code>b / 4</code>) <p>Truth Tables</p> <p>Understanding the outcomes of bitwise operations can be simplified by using truth tables. Below is a truth table for the logical operations AND, OR, and XOR:</p> <code>a</code> <code>b</code> <code>a &amp; b</code> <code>a \\| b</code> <code>a ^ b</code> 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 <p>Example</p> <pre><code>byte a = 5; // 0101 in binary\nbyte b = 9; // 1001 in binary\nConsole.WriteLine(a &amp; b);       // 1 (binary 0001)\nConsole.WriteLine(a | b);       // 13 (binary 1101)\nConsole.WriteLine(a ^ b);       // 12 (binary 1100)\nConsole.WriteLine(~a);          // -6 (in two's complement)\nConsole.WriteLine(a &lt;&lt; 1);      // 10 (binary 1010)\nConsole.WriteLine(b &gt;&gt; 2);      // 2 (binary 0010)\n</code></pre> <p>If you are unsure why these are the results, do the calculations on paper, referencing the binary representations of <code>a</code> and <code>b</code>.</p>"},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/#common-uses","title":"Common Uses","text":"<p>Bitwise operations are often used for \"bit twiddling,\" such as masking certain bits. For example, you can check if a value is odd or even by masking the least significant bit:</p> <pre><code>int number = 6;\nif ((number &amp; 1) == 0)\n{\n    Console.WriteLine($\"{number} is even.\");\n}\nelse\n{\n    Console.WriteLine($\"{number} is odd.\");\n}\n</code></pre> <p>The XOR operator is also handy for swapping values without needing a temporary variable:</p> <pre><code>static void Main(string[] args)\n{\n    int a = 5;\n    int b = 9;\n    Console.WriteLine($\"Before swap: a = {a}, b = {b}\");\n    a ^= b;\n    b ^= a;\n    a ^= b;\n    Console.WriteLine($\"After swap: a = {a}, b = {b}\");\n}\n</code></pre>"},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/#checking-for-powers-of-2","title":"Checking for Powers of 2","text":"<p>To check if a number is a power of <code>2</code>, you can use the following method:</p> <pre><code>int n = 256;\nif ((n &amp; (n - 1)) == 0 &amp;&amp; n != 0)\n    Console.WriteLine($\"{n} is a power of 2\");\nelse\n    Console.WriteLine($\"{n} is not a power of 2\");\n</code></pre> <p>This works because a power of <code>2</code> has exactly one bit set in its binary representation. For example, <code>256</code> in binary is <code>100000000</code>, and <code>255</code> (which is <code>256 - 1</code>) is <code>011111111</code>, thus <code>n &amp; (n - 1)</code> results in <code>0</code>.</p>"},{"location":"chapters/03_operators_errors/04_logical_bitwise_operators/#multiplication-and-division-via-shifts","title":"Multiplication and Division via Shifts","text":"<p>Shifting bits left or right is equivalent to multiplying or dividing by <code>2</code>, respectively. For example:</p> <ul> <li><code>a &lt;&lt; 1</code> doubles <code>a</code> (shifts left by one bit).</li> <li><code>b &gt;&gt; 2</code> divides <code>b</code> by <code>4</code> (shifts right by two bits).</li> </ul>"},{"location":"chapters/03_operators_errors/05_type_conversion/","title":"Type Conversion","text":"<p>In programming, it is often necessary to change the value of a variable from one data type to another. For example, converting an <code>int</code> to a <code>double</code>. There are two primary approaches for this: casting and conversion.</p>"},{"location":"chapters/03_operators_errors/05_type_conversion/#casting","title":"Casting","text":"<p>Casting is a method of explicitly changing one data type to another, where permissible. To perform an explicit cast, precede the variable with the new type in parentheses, as illustrated below:</p> <pre><code>float height = 4.23f;\ndouble maxHeight = height;              // Implicit cast; no need to specify\ndouble minHeight = (double)height;      // Explicit cast\nfloat realHeight = (float)minHeight;    // Explicit cast\n</code></pre> <p>In this example: - The variable <code>maxHeight</code> is assigned the value of <code>height</code> without explicit casting since a <code>float</code> can be implicitly converted to a <code>double</code>. - The variable <code>minHeight</code> is explicitly cast to a <code>double</code>. - The variable <code>realHeight</code> demonstrates an explicit cast back to <code>float</code>.</p> <p>It is safe to cast from an <code>int</code> to a <code>double</code> since there is no risk of data loss. However, casting from a <code>decimal</code> to an <code>int</code> may lead to loss of precision, as the <code>decimal</code> type is more precise than <code>int</code>. This type of cast should be approached cautiously.</p>"},{"location":"chapters/03_operators_errors/05_type_conversion/#conversion-with-the-convert-class","title":"Conversion with the Convert Class","text":"<p>Alternatively, we can use the <code>Convert</code> class, which provides methods to convert any primitive type into another primitive type. Notably, converting from a <code>float</code> to an <code>int</code> will truncate any decimal values:</p> <pre><code>int i = 42;\ndouble f = Convert.ToDouble(i);         // Converts int to double\ndecimal m = 4.99m;\nint im = Convert.ToInt32(m);            // Converts decimal to int, truncating the value\nConsole.WriteLine(\"{0} {1} {2} {3}\", i, f, m, im); // Outputs: 42 42 4.99 4\nConsole.WriteLine(im.ToString());       // Outputs: \"4\"\n</code></pre> <p>In this example: - The value of <code>m</code> is converted to an <code>int</code>, resulting in a truncation of the decimal part, yielding <code>4</code> instead of <code>5</code>.</p> <p>In general, using the <code>Convert</code> class is safer than casting and is more likely to succeed without causing exceptions.</p>"},{"location":"chapters/03_operators_errors/05_type_conversion/#converting-from-strings","title":"Converting from Strings","text":"<p>When converting from a <code>string</code> to another data type, more careful handling is required. If the conversion fails, an exception will be thrown. To handle this more gracefully, you can use either the <code>Parse()</code> method or, preferably, the <code>TryParse()</code> method.</p> <pre><code>int i = int.Parse(Console.ReadLine());  // Throws an exception if input is not numeric\n\nint result;\nbool isValid = int.TryParse(Console.ReadLine(), out result);\nif (isValid)\n    Console.WriteLine(result);            // Outputs the converted integer\nelse\n    Console.WriteLine(\"Input is not in the correct format.\");\n</code></pre> <p>In this code: - The <code>Parse()</code> method will throw an exception if the user input is not a valid numeric value. - The <code>TryParse()</code> method returns a <code>bool</code>, indicating whether the conversion was successful. If successful, the converted value is stored in the <code>out</code> parameter, <code>result</code>.</p>"},{"location":"chapters/03_operators_errors/05_type_conversion/#summary","title":"Summary","text":"<ul> <li>Casting is an explicit way to convert types when there is no risk of data loss.</li> <li>Conversion using the <code>Convert</code> class is generally safer and more flexible.</li> <li>Always handle string conversions carefully, using <code>TryParse()</code> to avoid exceptions from invalid inputs.</li> </ul> <p>By understanding and utilizing these type conversion methods effectively, you can write more robust and error-free code in C#.</p>"},{"location":"chapters/03_operators_errors/06_errors_exceptions/","title":"Errors and Exceptions","text":"<p>In programming, it is crucial to ensure that the program functions as intended and that the data being processed is accurate. Correct data is vital because organizations rely on it, data protection laws require it, and incorrect data can lead to unexpected behavior or crashes in the program.</p>"},{"location":"chapters/03_operators_errors/06_errors_exceptions/#types-of-errors","title":"Types of Errors","text":"<p>There are several types of errors that can occur during programming:</p> <ul> <li> <p>Syntax Error: The program does not adhere to the rules of the programming language. These errors prevent the program from compiling and are detected by the compiler during the build process.</p> </li> <li> <p>Logic Error: The code compiles successfully, and the program runs, but the output is incorrect. This type of error indicates a flaw in the algorithm or logic used in the program.</p> </li> <li> <p>Runtime Error: An error that occurs while the program is running, often causing the application (and sometimes the operating system) to crash. For example, entering a string when a numeric input is expected in a temperature conversion program can lead to a runtime error.</p> </li> </ul> <p>Each type of error is detected in different ways:</p> <ul> <li> <p>Syntax errors are identified by the compiler, though the error messages it produces can be cryptic.</p> </li> <li> <p>Logic errors must be detected and corrected by the programmer through careful testing and debugging.</p> </li> <li> <p>Runtime errors require the programmer to anticipate potential issues and handle them appropriately.</p> </li> </ul>"},{"location":"chapters/03_operators_errors/06_errors_exceptions/#validation-of-data-entry","title":"Validation of Data Entry","text":"<p>To minimize runtime and logic errors when users enter data, programmers can implement various checks:</p> <ul> <li> <p>Checking the Length of a String: Input data may need to conform to a fixed length (e.g., bank account numbers). This can be easily validated using the <code>Length</code> property of the string.</p> </li> <li> <p>Checking the Data Format: Ensure the input meets specific format criteria, such as being all uppercase, lowercase, or following a specific pattern. Regular expressions are particularly useful for this purpose.</p> </li> <li> <p>Checking the Range of Data: For example, students in a school are usually 18 years old or younger. When a date of birth is entered, the range of acceptable dates can be validated.</p> </li> <li> <p>Checking Required Fields: Data entry forms often have fields that must be completed. If the user omits any required data, the program should alert them to provide it.</p> </li> <li> <p>Checking Data Types: This is best handled through exception handling.</p> </li> </ul>"},{"location":"chapters/03_operators_errors/06_errors_exceptions/#exception-handling","title":"Exception Handling","text":"<p>From the syllabus</p> <p>AQA: Exception handling (3.1.1.9/4.1.1.9)}</p> <ul> <li>Be familiar with the concept of exception handling; Know how to use exception handling in a programming language.</li> </ul> <p>Most programming languages feature Exception Handling to manage potential runtime errors that could cause the program to crash during execution. Examples include:</p> <ul> <li>Attempting to convert a non-numeric string into an integer or floating-point number.</li> <li>Trying to read data from a non-existent file.</li> <li>Dividing by zero.</li> <li>Performing calculations with non-numeric data.</li> </ul> <p>When a runtime error occurs, the system generates an exception. Programmers can include instructions in the code to define how the system should respond to such exceptions. It is usually possible to identify the type of exception, enabling different handling for various errors.</p> <p>Consider the example program below, where a user can inadvertently crash the program by entering a non-numeric value (e.g., \"sheep\") for the radius of a circle. The program cannot convert \"sheep\" into a number, triggering an exception:</p> <pre><code>Console.WriteLine(\"Program to calculate the circumference of a circle\");\nConsole.Write(\"Enter circle radius: \");\ntry\n{\n    double radius = Convert.ToDouble(Console.ReadLine());\n    double diam = radius * 2;\n    double circ = Math.PI * diam; // Use Math.PI for consistency\n    Console.WriteLine(\"The circumference of the circle = \" + circ.ToString());\n}\ncatch (System.FormatException ex) // Use 'ex' as a common abbreviation\n{\n    Console.WriteLine(ex.Message);\n    Console.WriteLine(\"Please enter a valid number.\");\n}\nConsole.ReadLine();\n</code></pre> <p>In this code: - The <code>try { ... } catch { ... }</code> block first attempts to handle the user's input. If it encounters unexpected data, it catches the exception and handles it gracefully, preventing a crash. - Using <code>Math.PI</code> is preferable to using a hardcoded value for \u03c0, ensuring greater accuracy.</p> <p>While there is much more to exception handling (such as customizing actions based on the type of error), this overview provides a solid starting point for understanding its importance in robust programming.</p>"},{"location":"chapters/03_operators_errors/07_programming_task/","title":"Programming Task - Pick a Card","text":"<p>This problem will give you practice in using a range of variable types and the arithmetic operations you can perform on them.</p> <p>The problem:</p> <p>Write a program that will display the rank and suit of a card chosen randomly from a standard pack.</p> <p>You are provided with an incomplete Card Game program (code below).</p> <p>It already includes the statement to generate a random number and some incomplete code to output the rank and suit for the card.</p> <p>Your tasks are to:</p> <ul> <li>add in the operations to generate the rank and suit of the card (this is the part that uses \\(\\%\\) and \\(/\\))</li> <li>complete the selection (<code>if</code> and <code>case</code>) statements (you can read about these in the next chapter)</li> <li>test your algorithm by running the program, revising the algorithm where necessary</li> </ul> <pre><code>using System;\n\nnamespace CardGameIncomplete\n{\n    public class CardGameIncomplete\n    {\n        public static void Main(string[] args)\n        {\n            int number, ranknum, suitnum;\n            string rank = \"\";\n            string suit = \"\";\n\n            // \"seeds\" (initialises) the random number generator\n            Random random = new Random();\n\n            //selects a random number between 0 and 51,\n            //adds one to it and assigns the result to number\n            number = random.Next(52) + 1;\n\n            // ???  complete this \n            ranknum =\n            suitnum =\n\n            // ??? complete this case statement for the other ranks\n            switch (ranknum)\n            {\n                case 1:\n                    rank = \"Ace\";\n                    break;\n                case 2:\n                    rank = \"Two\";\n                    break;\n                case 3:\n                    rank = \"Three\";\n                    break;\n            }\n\n            // add if statements for the other suits\n            if (suitnum == 0)\n            {\n                suit = \"Clubs\";\n            }\n            // output using an interpolated string\n            Console.WriteLine($\"Your card is the {rank} of {suit}\u201d);\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/03_operators_errors/07_programming_task/#extension-tasks","title":"Extension Tasks","text":"<p>(These require the use of loops and are optional. You can find out how to use loops by looking further ahead in the text)</p> <ol> <li>Add code to enable a user to \"Pick a Card\", add exception handling to this block of your program</li> <li>Extend the program so that it repeatedly chooses a random card until the user enters 'q'</li> <li>Extend the program so that it shows every card in a standard pack in order from the two of clubs to the ace of spades.</li> </ol> <p>Tip</p> <p>HINT: Adding these extensions to the same program will produce a lot of repetition.  Either, read ahead and look up how to implement a method, or use three separate projects</p> <ol> <li>Look up the Unicode representation for suits of cards and adapt your program to print those to the console rather than the word \"Spades\" or \"Hearts\" etc..</li> </ol>"},{"location":"chapters/03_operators_errors/08_questions/","title":"Questions","text":"<p>A primary school teacher wants a program to test their pupils' knowledge of times tables (2 - 12).  Read through the code for this problem and answer the following questions.</p> <pre><code>using System;\n\nnamespace timesTable\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n           const int NUM_OF_QUESTIONS = 10;\n            const int LOWER = 2;\n            const int UPPER = 12;\n            string name;\n            int correct = 0;\n\n            Console.Clear();\n            Console.WriteLine(\"Test: Times Tables\");\n\n            Console.Write(\"What is your name? \");\n            name = Console.ReadLine();\n\n            Random rnd = new Random();\n            for (int i = 1; i &lt;= NUM_OF_QUESTIONS; i++)\n            {\n                int first = rnd.Next(LOWER,UPPER);\n                int second = rnd.Next(LOWER,UPPER);\n                int answer = first * second;\n                Console.Write($\"{i} : {first} * {second} = \");\n                int myAnswer = Convert.ToInt32(Console.ReadLine());\n                if (answer == myAnswer)\n                {\n                    correct++;\n                    Console.WriteLine($\"Correct! {correct}/{i}\");\n                }\n                else\n                {\n                    Console.WriteLine($\"The correct answer was {answer} ({correct}/{i})\");\n                }\n            }\n            Console.WriteLine($\"{name}, you scored {correct}!\");\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <ol> <li>Why is it a good idea to use a constant for the number of questions being asked?</li> <li>How are constants different from variables?</li> <li>Explain, with reference to the code, how a random number is being generated.</li> <li>The program uses a loop (see chapter 6).  Can you explain how this loop works?</li> <li>Explain the line <code>correct++</code></li> <li>Modify the code to output the percentage of correct answers</li> <li>Explain what is meant by exception handling, how and where might exception handling be used in this program?</li> </ol>"},{"location":"chapters/03_operators_errors/08_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Using a bitwise operator write a program that checks if an integer is odd or even.  </li> <li>The gravitational field of the Moon is approximately 17% that of the Earth.  Write a program that calculates your weight on the Moon.  </li> <li>Write a program that takes as input a four digit number and calculates the sum of the digits</li> <li>EXTENSION: Write a program that checks if a given number input from the keyboard is a prime number.  (This requires a loop.)</li> </ol>"},{"location":"chapters/03_operators_errors/09_random_number_generation/","title":"Extended Theory - Random Number Generation","text":"<p>Following the in-depth exploration of binary in the last chapter, this section will briefly consider random numbers. While one might get sidetracked by philosophical questions about the nature of randomness, what we seek when generating a sequence of random numbers is for each value to be produced by chance, independent of any other numbers in the sequence. A common application of this concept can be found in our \"Pick a Card\" program, where we need the program to select one of the 52 cards. When we run it again, we would generally expect a different card to be selected.</p> <p>The topic of random number generation has a long history, and today there are two primary approaches:</p> <ul> <li>True Random Numbers</li> <li>Pseudo Random Numbers</li> </ul> <p>The \"Pick A Card\" program relied on a random number generator class built into C#. This class is a pseudo-random number generator, meaning it relies on an algorithm to produce random numbers. The algorithm requires a seed value; using the same seed will generate the same set of random numbers. Therefore, if you know the seed and the algorithm used, you can reproduce the seemingly random results. For most applications, this approach is sufficient. However, when generating a seed for encrypting sensitive information, such as credit card details, a stronger method is needed. C# addresses this with the <code>RNGCryptoServiceProvider</code> class.</p> <p>For reference, the algorithm used by the <code>Random</code> class in C# is a subtractive random number generator, with the seed derived from the system clock.</p> <p>To generate true random numbers, specialized additional hardware is required to read environmental noise or some other physical phenomenon that is inherently random.</p> <p>While it is unlikely you will need to write your own random number generator, understanding some of the underlying issues can be beneficial:</p> <pre><code>static int RandomSeed(int n, int m, int a)\n{\n    return n = m * n % a; \n}\n</code></pre> <p>In this code snippet, we define a function that returns an <code>int</code> value and accepts several parameters in the parentheses following the function name. We will explore methods in more detail in Chapter 9.</p> <p>This function takes an input value <code>n</code>, multiplies it by <code>m</code>, and returns the remainder after dividing by <code>a</code>. Thus, the value of <code>a</code> determines our range. For example, if <code>a = 11</code>, our range will be between 1 and 10. We can use this function to generate a sequence of 10 random numbers, where each successive number is derived from the previous one:</p> <pre><code>static void Main(string[] args)\n{\n    int start = 1;\n    for (int i = 0; i &lt; 10; i++)\n    {\n        int n = RandomSeed(start, 7, 11);\n        Console.Write(n + \" \");\n        start = n;\n    }\n}\n// Example Output: 7 5 2 3 10 4 6 9 8 1\n</code></pre> <p>In our <code>Main()</code> method, we use a loop to generate 10 values. We will cover loops in more detail in Chapter 6.</p> <p>The output from this loop appears random, as there is no immediately obvious pattern in the generated values. However, if we run it again with the same seed, we will get the exact same sequence of values. Note also how we use the previous value to generate the next number in the sequence, thus passing the state.</p> <p>However, this method is relatively weak because we can begin to predict the next number based on the preceding ones. To improve this, we can introduce a value outside the specified range and then apply the modulo operator to ensure the result falls within our desired range:</p> <pre><code>static void Main(string[] args)\n{\n    int start = 1;\n    for (int i = 0; i &lt; 10; i++)\n    {\n        (int n, int state) = RandomSeed(start, 7, 101, 10);\n        Console.Write($\"({n},{state}) \");\n        start = state;\n    }\n}\n\nstatic (int, int) RandomSeed(int n, int m, int a, int b)\n{\n    int j = m * n % a;\n    return ((j - 1) % b + 1, j); \n}\n</code></pre> <p>In this example, we return two values, utilizing a tuple. The first value represents our random number in the range of 1 to 10, while the second value serves as the revised state for our intermediate value. The output will appear as follows:</p> <pre><code>(7,7) (9,49) (10,40) (8,78) (1,41) (5,85) (10,90) (4,24) (7,67) (5,65)\n</code></pre> <p>The first value in each pair is part of our random number sequence. The generator now selects some previously used values, making it harder to predict the next number in the sequence. This unpredictability increases significantly if we utilize a much larger prime number than 101.</p> <p>Before concluding our discussion on random number generation, it\u2019s important to address one further issue: if a program depends on random numbers, testing becomes more challenging, as the expected values are unknown. The solution is straightforward: set the seed for the random number generator so that each sequence of values remains consistent across runs.</p> <p>When using the <code>Random()</code> class in C#, we can specify the seed value during initialization:</p> <pre><code>Random rnd = new Random(100);\nint a = rnd.Next(0, 10);\nint b = rnd.Next(0, 10);\nConsole.WriteLine(a);\nConsole.WriteLine(b);\n</code></pre> <p>Running this program multiple times will produce the same values for <code>a</code> and <code>b</code>. Once testing is complete, remove the seed parameter and allow C# to choose the seed value based on the system clock.</p>"},{"location":"chapters/04_using_the_console/","title":"Using the Console","text":"<p>In this chapter</p> <ul> <li>get familiar with command line operations</li> <li>display formatted text to the screen</li> <li>read input from the keyboard</li> <li>understand how character data is stored as a code, ASCII and Unicode</li> <li>convert characters to their numeric equivalent</li> </ul> <p>Whilst using the console is becoming less and less common for most users it is an ideal environment for getting started with introductory programming.  There are other advantages too for writing console applications, they're usually simpler, we do not need to get bogged down in issues of user interface design and we can focus on the algorithms.  Getting familiar with the console or terminal (the terms are largely synonymous) is a good thing too if you're looking for more control over your computer environment and can be an essential skill for any aspiring programmer.  </p> <p>The system console only displays text and expects the user to enter text, numbers or other data via the keyboard.  In Windows the console, or terminal or command prompt, can be accessed by entering the command <code>cmd.exe</code>.  To be pedantic, <code>cmd.exe</code> is really a shell, a program that is running in the terminal.  It processes commands and returns output.  The shell contains commands that help us interact with the operating system (OS) and each OS will have its own selection shells we can use.  Learning about the available commands on different systems is not our priority here but getting familiar with the available commands is useful e.g. on Windows here are some of the more common commands you can run:</p> Command Action <code>dir</code> Show contents of current directory <code>cd &lt;dir&gt;</code> change to new directory <code>&lt;dir&gt;</code> <code>mkdir &lt;dir&gt;</code> Create new directory <code>&lt;dir&gt;</code> <code>mov &lt;src&gt; &lt;dest&gt;</code> Move <code>&lt;src&gt;</code> to <code>&lt;dest&gt;</code> <code>del &lt;file&gt;</code> Delete <code>&lt;file&gt;</code> <p>Find out more here.  You can find similar tutorials for getting to know the Linux shells e.g. Bash.</p>"},{"location":"chapters/04_using_the_console/01_output/","title":"System.Console (Output)","text":"<p>In C#, reading from the keyboard and writing to the screen is accomplished using the <code>System.Console</code> namespace. This namespace provides numerous methods and properties for interacting with the console, facilitating both input and output operations.</p>"},{"location":"chapters/04_using_the_console/01_output/#consolewrite-and-consolewriteline","title":"Console.Write and Console.WriteLine","text":"<p>We have used both <code>Console.Write()</code> and <code>Console.WriteLine()</code> to display content on the screen. The key difference between them is that <code>Console.WriteLine()</code> moves the cursor to the beginning of the next line after printing, whereas <code>Console.Write()</code> keeps the cursor at the end of the current line. Both methods accept a string argument to display on the screen.</p> <p>The strings being printed can be concatenated using the <code>+</code> operator, allowing us to print data of different types within the same string. For example:</p> <pre><code>int age = 17;\nConsole.WriteLine(\"Peter is aged \" + age + \" years old\");\n</code></pre> <p>This will print: <code>Peter is aged 17 years old</code>.</p> <p>No casting or conversion is necessary when using the <code>+</code> operator for string concatenation. </p> <p>However, be cautious when concatenating values; make your intentions clear by using parentheses where necessary:</p> <pre><code>Console.WriteLine(\"Five: \" + 2 + 3);    // Output: Five: 23\nConsole.WriteLine(\"Five: \" + (2 + 3));  // Output: Five: 5\n</code></pre> <p>The <code>+</code> operator behaves differently depending on the data types of its operands. If both operands are numeric, it performs addition; if at least one operand is a string, it concatenates them into a single string.</p>"},{"location":"chapters/04_using_the_console/01_output/#formatting-output","title":"Formatting Output","text":"<p>We can provide both string literals, enclosed in double quotes, and variables in our output. There are several ways to embed these variables into strings. The choice of method is largely a matter of preference. For example:</p> <pre><code>string name = \"Sally\";\nstring town = \"Heston\";\nint age = 17;\nConsole.WriteLine(\"{0} is from {1}, she is {2} years old\", name, town, age);\n</code></pre> <p>In this statement, the output string includes numbered placeholders, followed by the corresponding variables. You can also specify the number of spaces for the variable output; for instance, <code>{0,10}</code> will print the first argument right-aligned in a space of 10 characters. To left-align, use a negative width specifier.</p> <p>These placeholders can also be combined with format specifiers, which are letters followed by an optional precision value. Here are some examples:</p> <pre><code>Console.WriteLine(\"{0:C2}\", 14.99); // Output: \u00a314.99 (currency)\nConsole.WriteLine(\"{0:D8}\", 19);    // Output: 00000019 (decimal)\nConsole.WriteLine(\"{0:E3}\", 245);   // Output: 2.450E+002 (scientific notation)\nConsole.WriteLine(\"{0:X}\", 255);    // Output: FF (hexadecimal)\nConsole.WriteLine(\"{0:P1}\", 0.112);  // Output: 11.2% (percentage)\n</code></pre> <p>Alternatively, we can use string interpolation for formatting:</p> <pre><code>Console.WriteLine($\"{name} is from {town}, she is {age} years old\");\n</code></pre> <p>The <code>$</code> preceding the string indicates that it is an interpolated string. This syntax is more convenient and readable for creating formatted strings, and it is the preferred method in this text. The same format specifiers apply to interpolated strings.</p>"},{"location":"chapters/04_using_the_console/01_output/#formatting-dates","title":"Formatting Dates","text":"<p>Dates can also be formatted in various ways. Here are some examples:</p> <pre><code>DateTime now = DateTime.Now;\nConsole.WriteLine(now);               // Output: 19/05/2021 16:25:07\nConsole.WriteLine(\"{0:D}\", now);      // Output: 19 May 2021\nConsole.WriteLine(\"{0:Y}\", now);      // Output: May 2021\nConsole.WriteLine(\"{0:d/MM/y}\", now); // Output: 19/05/21\n</code></pre> <p>We can similarly use string interpolation for dates:</p> <pre><code>DateTime now = DateTime.Now;\nConsole.WriteLine($\"{now:D}\");              // Output: 19 May 2021\nConsole.WriteLine($\"{now:Y}\");              // Output: May 2021\nConsole.WriteLine($\"{now:d/MM/y}\");         // Output: 19/05/21\n</code></pre>"},{"location":"chapters/04_using_the_console/02_input/","title":"System.Console (Input)","text":"<p>The keyboard is the standard input device in C#, and the <code>System.Console</code> class provides the method <code>Console.ReadLine()</code> for reading user input.</p> <p>When <code>Console.ReadLine()</code> is called, the system waits for the user to type something on the keyboard. The entered data can be assigned to a variable or ignored:</p> <pre><code>Console.WriteLine(\"Enter your name: \");\nstring name = Console.ReadLine();               // Data entered is assigned to a variable\nConsole.WriteLine($\"Hello {name}\");\nConsole.WriteLine(\"Press any key to quit...\");\nConsole.ReadLine();                             // Data entered is ignored\n</code></pre> <p>Data entered through the keyboard is always treated as a string. If you need the data to be numeric, it must be converted before any processing can be performed. As mentioned earlier, there are two common approaches for this conversion:</p> <ul> <li>Using <code>int.Parse()</code> or <code>int.TryParse()</code></li> <li>Using <code>Convert.ToInt32()</code></li> </ul> <p>If you're reading data from a trusted source (e.g., when you expect to read an integer), using <code>Parse()</code> is generally safe. However, if you're getting the data from a user, it's advisable to use <code>TryParse()</code> to avoid exceptions.</p> <p>Here are examples of both methods for reading numeric input:</p> <pre><code>Console.WriteLine(\"Enter your age: \");\nint age = int.Parse(Console.ReadLine()); // Using Parse\n\n// or\n\nConsole.Write(\"Enter your age: \");\nint age1 = Convert.ToInt32(Console.ReadLine()); // Using Convert\n</code></pre> <p>Note</p> <p>There is very little difference in behavior between <code>Convert</code> and <code>Parse()</code>. However, it's worth mentioning that <code>Convert.ToInt32()</code> will return <code>0</code> if the argument is <code>null</code>. </p> <p>Be aware that exception errors may still occur during conversion and should be handled appropriately.</p> <p>If you're only expecting a single key to be input (for example, when displaying a prompt like \"Press any key to continue...\"), you can use <code>Console.ReadKey()</code> instead:</p> <pre><code>Console.WriteLine(\"Press any key to continue...\");\nConsole.ReadKey(); // Waits for a key press\n</code></pre>"},{"location":"chapters/04_using_the_console/03_ascii_unicode/","title":"ASCII and Unicode","text":"<p>From the syllabus</p> <p>AQA: Describe ASCII and Unicode coding systems for coding character data and explain why Unicode was introduced. (3.5.5.2/4.5.5.2)</p> <p>In ASCII, every letter, punctuation mark, digit, etc., is assigned a 7-bit code. .NET uses a 16-bit standard, but Unicode also includes 8-bit and 32-bit code units. Unicode can support a much wider range of characters from various languages, including Arabic, Greek, mathematical symbols, historical scripts, and even emojis.</p> <p>One of the exercises from the end of the last chapter was:</p> <ul> <li>Write a program that takes as input a four-digit number and calculates the sum of its digits.</li> </ul> <p>For instance, if the number entered is 1234, we calculate \\(1 + 2 + 3 + 4\\).</p> <p>From mathematics, we know that dividing by 10 and taking the remainder works for extracting digits. For example:</p> <pre><code>int num = Convert.ToInt32(Console.ReadLine());\nint a = num % 10;\nint b = (num / 10) % 10;\nint c = (num / 100) % 10;\nint d = (num / 1000) % 10;\n</code></pre> <p>While this is a valid solution, let's briefly explore character data entered at the keyboard and see what happens \"under the hood.\"</p> <p>In this example, we want to read a single character from the keyboard. We know <code>Console.ReadLine()</code> reads a string (a sequence of characters), and we can obtain the first character from that input string using its index <code>[0]</code>. Thus, to get the first character from the string, we use <code>Console.ReadLine()[0]</code>.</p> <p>Here's a code sample using this command. Can you predict what will be displayed on the screen if the user enters '3'?</p> <pre><code>char ch;\nConsole.Write(\"Enter a character &gt; \");\nch = Console.ReadLine()[0];\nint n = 4 + ch;                 // Implicitly casting to an integer\nConsole.WriteLine(n);\n</code></pre> <p>What about in this example?</p> <pre><code>char ch;\nConsole.Write(\"Enter a character &gt; \");\nch = Console.ReadLine()[0];\nint n = 4 + (int)ch;            // Explicitly casting character to an integer\nConsole.WriteLine(n);\n</code></pre> <p>In both cases, the output will be 55. If you were expecting it to be 7, you might be surprised.</p> <p>\"Under the hood,\" all character data is represented to the processor as a numeric code. The processor can only process binary data, so letters need to be converted into binary. This conversion applies to numeric characters '0' - '9' as well. Originally, the ASCII (American Standard Code for Information Interchange) was developed. This used a byte to encode the alphabet, digits, punctuation, and some control codes and non-printing characters (such as 'TAB' and 'LINE FEED'). This approach worked well for English but was less effective for other languages like Greek or Arabic. Consequently, a different code was developed: Unicode, which uses 16 bits (with 8-bit and 32-bit options available as well).</p>"},{"location":"chapters/04_using_the_console/03_ascii_unicode/#ascii-codes-for-digits","title":"ASCII Codes for Digits","text":"<p>Here is the ASCII code for the digits:</p> Decimal Hex Char 48 30 0 49 31 1 50 32 2 51 33 3 52 34 4 53 35 5 54 36 6 55 37 7 56 38 8 57 39 9 <p>This table explains why 55 is the output from our program: it displays the ASCII code for the character '7'!</p> <p>To convert the character '2' to its integer value, we need to subtract 48 from the input (or subtract '0', which also works).</p> <pre><code>char ch;\nConsole.Write(\"Enter a character &gt; \");\nch = Console.ReadLine()[0];         // Read just the first character of input\nint n = 4 + (ch - 48);              // Subtracting ASCII code for '0' to get value\nConsole.WriteLine(n);\n</code></pre> <p>C# allows us to cast a character to its integer ASCII value and vice versa:</p> <pre><code>char letter = (char)97;         // 'a'     \n</code></pre> <pre><code>char letter = 'a';\nint asciiValue = (int)letter;\n</code></pre> <p>To work with an entire string, we can use the <code>GetBytes()</code> method from the <code>Encoding.ASCII</code> namespace, which converts a string into an array of bytes:</p> <pre><code>string fullName = \"Harry Lime\";\nbyte[] bytes = Encoding.ASCII.GetBytes(fullName);\nforeach (byte b in bytes)\n{\n    Console.WriteLine(b);\n}\n</code></pre> <p>Unicode characters can be displayed using their hexadecimal code preceded by <code>\\u</code>. For instance, the Unicode for 'A' is <code>\\u0041</code>, and for 'a' it is <code>\\u0061</code>. All four digits must be present after the <code>\\u</code> indicator since .NET uses 16-bit Unicode, with each code symbol representing one byte.</p> <p>Note</p> <p>Not all Unicode characters will print to your console; you need to have a font installed that can display certain characters. If a character cannot be displayed, a question mark will be used instead.</p> <p>To learn more about Unicode, check out the absolute minimum every software developer absolutely positively must know about Unicode and character sets.</p>"},{"location":"chapters/04_using_the_console/04_programming_task/","title":"Programming Task -  Formatting data to the console","text":"<p>Write a program that asks the user for three numbers then prints these numbers in three virtual columns on the console.</p> <ul> <li>Each column should have a width of 10 characters and the numbers should be left aligned.</li> <li>The first number should be an integer in hexadecimal;</li> <li>the second should be fractional positive;</li> <li>and the third a negative fraction.</li> <li>The last two numbers have to be rounded to the second decimal place.</li> </ul> <p>The following table summaries the format specifiers:</p> Code Name Example C, c Currency <code>Console.WriteLine(\"{0:C2}\", 14.99); // \u00a314.99</code> D, d Digits <code>Console.WriteLine(\"{0:D8}\", 19);    // 00000019</code> E, e Exponential <code>Console.WriteLine(\"{0:E3}\", 245);   // 2.450E+002</code> F, f Float <code>Console.WriteLine(\"{0:F4}\", 42);     // 42.0000</code> N, n Number <code>Console.WriteLine(\"{0:N0}\", 42.3);    // 42</code> P, p Percentage <code>Console.WriteLine(\"{0:P1}\",0.112);  // 11.2%</code> X, x Hexadecimal <code>Console.WriteLine(\"{0:X}\", 255);    // FF</code>"},{"location":"chapters/04_using_the_console/05_questions/","title":"Questions","text":"<p>Study the ASCII table.  </p> <ol> <li>What do you notice about the distribution, grouping, of characters in the table?</li> <li>What do you notice about the codes assigned to the lower and upper case characters?</li> <li>What is the binary equivalent for the character 'a'?</li> <li>What is the binary equivalent for the character 'A'?</li> <li>Write a program that accepts a single lower case character from the user and prints its upper case equivalent without using the built-in method <code>ToUpper()</code> </li> </ol>"},{"location":"chapters/04_using_the_console/05_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write a program that reads from the console the radius \"r\" of a circle and prints its area and circumference.</li> <li>Write a program that reads two numbers from the console and prints the greater of them. Can you solve this problem without using conditional statements? (Hint:  The library <code>Math</code> contains methods for <code>Max</code> and <code>Min</code>)</li> <li>Write a program that reads five integer numbers and prints their sum. If an invalid number is entered the program should prompt the user to enter another number.</li> <li>Research how to print Unicode characters to the console using .NET (C#).</li> <li>Read and do the tutorial on selection in C# </li> </ol>"},{"location":"chapters/04_using_the_console/06_input_output/","title":"Extended Theory - Input/Output","text":"<p>One of the most important roles of an operating system (OS) is to manage the various devices connected to a computer, such as the mouse, keyboard, screen, touchpad, storage devices, printers, and network connections. These devices can either provide input to the system, receive output from the system, or perform both functions. The OS relies on I/O controllers to handle data entering and leaving the system, with the I/O subsystem of the OS packaging the data appropriately before passing it on to the controller.</p> <p>C# includes several classes designed to handle I/O operations from a variety of devices. This chapter has primarily focused on the <code>System.Console</code> class for reading from and writing to the console using the default input and output devices (keyboard and screen). Other classes, such as <code>System.IO</code>, are used for file handling, while <code>System.Net</code> is employed for network communications. We will explore these namespaces in later chapters.</p> <p>We can also utilize additional classes to gather information about our computer system, such as <code>System.Environment</code> and <code>System.Management</code>. For instance, to determine which operating system you are using, you can run:</p> <pre><code>Console.WriteLine(System.Environment.OSVersion);\n</code></pre>"},{"location":"chapters/04_using_the_console/06_input_output/#additional-system-information","title":"Additional System Information","text":"<p>Here\u2019s a sample program that demonstrates how to access various system properties:</p> <pre><code>static void Main(string[] args)\n{\n    Console.WriteLine($\"Operating system: {System.Environment.OSVersion}\");\n    Console.WriteLine($\"64-bit OS: {System.Environment.Is64BitOperatingSystem}\");\n    Console.WriteLine($\"Machine Name: {System.Environment.MachineName}\");\n    Console.WriteLine($\"Current Directory: {System.Environment.CurrentDirectory}\");\n\n    string[] myDrives = Environment.GetLogicalDrives();\n    Console.Write(\"Connected logical drives: \");\n    foreach (string drive in myDrives)\n    {\n        Console.Write(drive + \" \");\n    }\n\n    Console.WriteLine($\"\\nNumber of processors: {System.Environment.ProcessorCount}\");\n    Console.WriteLine($\"User name: {System.Environment.UserName}\");\n\n    Console.ReadKey();\n}\n</code></pre>"},{"location":"chapters/04_using_the_console/06_input_output/#using-systemmanagement-for-detailed-information","title":"Using System.Management for Detailed Information","text":"<p>The <code>System.Management</code> class can provide in-depth details about your CPU:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Management;\n\nnamespace ViewAssembly\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ManagementClass myCPU = new ManagementClass(\"Win32_Processor\");\n            ManagementObjectCollection myCPUCollection = myCPU.GetInstances();\n            PropertyDataCollection pdc = myCPU.Properties;\n            Dictionary&lt;string, object&gt; myCPUResults = new Dictionary&lt;string, object&gt;();\n\n            foreach (var obj in myCPUCollection)\n            {\n                foreach (var prop in pdc)\n                {\n                    myCPUResults.Add(prop.Name, obj.Properties[prop.Name].Value);\n                }\n            }\n\n            foreach (var result in myCPUResults)\n            {\n                Console.WriteLine($\"{result.Key}: {result.Value}\");\n            }\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre> <p>This example uses more advanced C# features than we have covered so far, but it illustrates the capabilities available for exploring the architecture of your computer system. By reading the code and comparing it with the output, you should gain insights into what the code is accomplishing.</p> <p>Note</p> <p>To try out this last example in Visual Studio, a reference needs to be added. Right-click on \"References\" in the Solution Explorer window, select \"Add Reference,\" and then choose \"System.Management\" from the list of \"Assemblies.\"</p>"},{"location":"chapters/05_decisions/","title":"Making Decisions","text":"<p>In this chapter:</p> <ul> <li>Describe the term selection\u200b</li> <li>Learn to use relational operators and logical operators\u200b</li> <li>Write if\u2026else if\u2026else statements\u200b</li> <li>Use switch statements</li> <li>Use flowcharts to describe and algorithm</li> </ul> <p>In each of the short programs thus far each instruction has been executed sequentially, one after the other.  Each statement will alter the state of the program so the order in which they are executed does matter.  This order is also known as the flow of control.  Designing the right algorithm to solve a problem is all about planning the steps needed to arrive at the solution, and ensuring those steps are in the right order.</p> <p>This flow of control can be altered through the use of selection, iteration, methods and events.  </p> <p>In this chapter we will see how this flow of control can be changed using selection.  That is, either one statement (or block of statements) will be executed or another statement (or block of statements).</p> <p>We will be making extensive use of the comparison operators from Chapter 3 (<code>&lt;</code>, <code>&gt;=</code>, <code>!=</code> etc.) as these are used in the conditional statements that are used to determine the outcome of a decision.  Depending on the result of this decision (or condition), one path or another is followed in a program.  </p> <p>For example, in the following extract, the <code>Console.WriteLine()</code> statement will only be executed if the value of the variable, <code>score</code>, is greater than or equal to \\(75\\):</p> <pre><code>    if (score &gt;= 75)\n    {\n        Console.WriteLine(\"Congratulations! You got an A*\");\n    }\n</code></pre> <p>Comparison operators can be used to compare expressions, such as two values, two expressions, or a number and a variable.<sup>1</sup>  The result will be a boolean value (true or false).  These expressions may also make use of one or more logical operators (AND, OR etc).</p> <ol> <li> <p>Not every pair of data types can be compared with each other directly e.g. you cannot compare a string to a number.\u00a0\u21a9</p> </li> </ol>"},{"location":"chapters/05_decisions/01_making_a_choice/","title":"Making a Choice","text":"<p>From the syllabus</p> <p>AQA: Use, understand, and know how the following statement types can be combined in programs; Use nested selection structures (3.1.1.2/4.1.1.2).</p> <p>Selection is a programming construct where a section of code is executed only if a specified condition is met. The outcome of the condition determines the next path the program will take.</p>"},{"location":"chapters/05_decisions/01_making_a_choice/#basic-conditional-statement","title":"Basic Conditional Statement","text":"<p>The format of the <code>if</code> statement is:</p> <pre><code>if (conditional expression)\n{\n    // body if true\n}\n</code></pre> <p>The conditional expression must evaluate to either <code>True</code> or <code>False</code>. The body of the statement must be enclosed in curly braces <code>{ ... }</code>. Although these braces can be omitted if there is only one statement, it is recommended to include them for improved readability.</p>"},{"location":"chapters/05_decisions/01_making_a_choice/#example-1-payrollcs","title":"Example 1: Payroll.cs","text":"<p>Let\u2019s review the following code example, where the highlighted lines are discussed beneath the code:</p> <pre><code>using System;\n\nnamespace payroll\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const double PAY_RATE = 5.45;\n            const int BASIC = 40;\n            int hours, overtime;\n            double pay;\n\n            Console.Write(\"Enter number of hours worked: \");\n            hours = Convert.ToInt32(Console.ReadLine());\n\n            // calculate basic pay \n            pay = hours * PAY_RATE;\n\n            // calculate overtime and add to basic pay \n            if (hours &gt; BASIC)\n            {\n                overtime = hours - BASIC;\n                pay = pay + (overtime * PAY_RATE);\n            }\n            // display total pay \n            Console.WriteLine($\"Total pay due is \u00a3{pay.ToString(\"N2\")}\");\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();  \n        }\n    }\n}\n</code></pre> <ul> <li>Line 9: Two constants are declared for the hourly pay rate and the number of hours in a standard workweek, followed by two variables for calculating the employee's weekly wage.</li> <li>Line 18: After obtaining the number of hours worked from the user, the base pay is calculated.</li> <li>Line 21: If the employee works more than 40 hours, the <code>BASIC</code> rate triggers overtime calculation and adds it to the total pay. If this condition is <code>false</code>, no overtime is included.</li> </ul> <p>Curly Braces</p> <p>Note the use of curly braces, as the <code>if</code> contains a compound statement. While single statements following <code>if()</code> can omit the braces, it is advisable to keep them for clarity and to prevent unforeseen errors. Omitting them may save typing but can lead to confusion.</p>"},{"location":"chapters/05_decisions/01_making_a_choice/#avoiding-magic-numbers","title":"Avoiding Magic Numbers","text":"<p>Constants are used for both the pay rate and the threshold number of hours (before overtime applies) to avoid using magic numbers\u2014values with no meaningful context. Consider this alternative:</p> <pre><code>if (hours &gt; 40)\n{\n    ...\n}\n</code></pre> <p>What does the number <code>40</code> signify? If this value changes, you would need to locate and modify every instance, risking the chance of missing one. Always prefer named constants for clarity.</p>"},{"location":"chapters/05_decisions/01_making_a_choice/#example-2-trianglecs","title":"Example 2: Triangle.cs","text":"<p>In this example, we introduce an <code>else</code> clause to create a 2-way decision construct, allowing for two separate execution paths based on the condition\u2019s truth value.</p> <p>The format of the <code>if</code> statement with an <code>else</code> is:</p> <pre><code>if (conditional expression)\n{\n    // body if true\n}\nelse \n{\n    // body if false\n}\n</code></pre> <p>This program reads three integers representing the sides of a triangle and checks if it forms a right-angled triangle using Pythagoras' Theorem.</p> <pre><code>using System;\n\nnamespace triangle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            // get three sides of the triangle \n            Console.Write(\"Enter shortest side   &gt; \");\n            int sideA = Convert.ToInt32(Console.ReadLine());\n\n            Console.Write(\"Enter mid-length side &gt; \");\n            int sideB = Convert.ToInt32(Console.ReadLine());\n\n            Console.Write(\"Enter longest side    &gt; \");\n            int sideC = Convert.ToInt32(Console.ReadLine());\n\n            // Test for right-angled triangle and output result \n            if ((sideC * sideC) == ((sideA * sideA) + (sideB * sideB)))\n            {\n                Console.WriteLine(\"A right-angled triangle\");\n            }\n            else\n            {\n                Console.WriteLine(\"Not a right-angled triangle\");\n            }\n            Console.Write(\"Press any key to exit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>The <code>else</code> clause executes if the condition evaluates to <code>false</code>, establishing two possible execution paths.</p> <p>We can visualize this algorithm with a flowchart:</p> Flow chart example <p>The flowchart serves as a useful graphical representation of an algorithm, helping to sketch out the problem and describe the final algorithm in documentation. </p> <ul> <li>Terminators are represented by ellipses/ovals.</li> <li>Input/Output by parallelograms.</li> <li>Decisions by diamonds.</li> <li>Processing by rectangles.</li> <li>Flow indicated by arrows.</li> </ul>"},{"location":"chapters/05_decisions/01_making_a_choice/#example-3-gradescs","title":"Example 3: Grades.cs","text":"<p>To pass an exam, a student must achieve a minimum of 40% on both a project and a written paper. A student who meets this requirement will receive a Pass if the average mark is over 50, a Merit if it is 50 or more but less than 65, and a Distinction for 65 and above. All marks are whole numbers, and the average is rounded up.</p> <pre><code>using System;\n\nnamespace grades\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int PASS = 40;\n            const int MERIT = 50;\n            const int DISTINCTION = 65;\n\n            int project, exam, average;\n            Console.Clear();\n            // get marks \n            Console.Write(\"Enter project mark:   \");\n            project = Convert.ToInt32(Console.ReadLine());\n\n            Console.Write(\"Enter exam mark:    \");\n            exam = Convert.ToInt32(Console.ReadLine());\n\n            // calculate the rounded average \n            average = (project + exam + 1) / 2;\n            Console.WriteLine(\"Overall average is \" + average.ToString());\n\n            // determine grade \n            if ((project &lt; PASS) || (exam &lt; PASS))\n            {\n                Console.Write(\"Student has failed\");\n            }\n            else if (average &lt; MERIT)\n            {\n                Console.Write(\"Student has gained a pass\");\n            }\n            else if (average &lt; DISTINCTION)\n            {\n                Console.Write(\"Student has gained a merit\");\n            }\n            else\n            {\n                Console.Write(\"Student has gained a distinction\");\n            }\n            Console.Write(\"\\nPress any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>This example features a more complex boolean expression. Ensure you understand the logic and possible execution paths. It employs a series of <code>if ... else</code> statements, utilizing <code>else if</code> for subsequent conditions. When multiple paths of execution exist, this chaining of conditional statements becomes necessary, though it may complicate understanding. The next section discusses the <code>switch</code> statement, which is useful in such cases.</p> <p>Note that each individual expression, as well as the overall expression, must be enclosed in parentheses. Logical operators (e.g., <code>&amp;&amp;</code>, <code>||</code>) can also be used to connect expressions.</p>"},{"location":"chapters/05_decisions/01_making_a_choice/#nesting-if-statements","title":"Nesting if Statements","text":"<p>Lastly, we can nest <code>if</code> statements within one another, creating what is known as a nested if. While this can become complex quickly, it is advisable to limit the levels of nesting. Below is a simple example that finds the largest of three numbers:</p> <pre><code>using System;\n\nnamespace nestedIf\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int first = 5;\n            int second = -42;\n            int third = 64;\n\n            Console.Clear();\n            Console.WriteLine(\"Nested if\");\n\n            if (first &gt; second)\n            {\n                if (first &gt; third)\n                {\n                    Console.WriteLine($\"{first} is the largest number\");\n                }\n                else\n                {\n                    Console.WriteLine($\"{third} is the largest number\");\n                }\n            }\n            else\n            {\n                if (second &gt; third)\n                {\n                    Console.WriteLine($\"{second} is the largest number\");\n                }\n                else\n                {\n                    Console.WriteLine($\"{third} is the largest number\");\n                }\n            }\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/05_decisions/02_switch/","title":"Switch","text":"<p>The <code>switch</code> statement is a powerful control structure in C# that simplifies complex conditional logic, making code easier to read and maintain. We previously saw the <code>switch</code> statement in the cards program from an earlier chapter.</p>"},{"location":"chapters/05_decisions/02_switch/#advantages-of-using-switch","title":"Advantages of Using Switch","text":"<p>Nested <code>if</code> statements can become difficult to read and manage. The <code>switch</code> construct offers a cleaner and more straightforward alternative for making multi-way decisions.</p>"},{"location":"chapters/05_decisions/02_switch/#example-grades-program","title":"Example: Grades Program","text":"<p>Here\u2019s an example illustrating the use of the <code>switch</code> statement in a grading system. The value of the variable <code>grade</code> determines which message is displayed on the screen.</p> <pre><code>static void Main(string[] args) {\n    char grade = 'B';\n\n    switch (grade) {\n        case 'A':\n            Console.WriteLine(\"Excellent!\");\n            break;\n        case 'B':\n        case 'C':\n            Console.WriteLine(\"Well done!\");\n            break;\n        case 'D':\n            Console.WriteLine(\"You passed.\");\n            break;\n        case 'F':\n            Console.WriteLine(\"Better try again.\");\n            break;\n        default:\n            Console.WriteLine(\"Invalid grade.\");\n            break;\n    }\n\n    Console.WriteLine($\"Your grade is {grade}.\");\n}\n</code></pre>"},{"location":"chapters/05_decisions/02_switch/#key-features-of-switch","title":"Key Features of Switch","text":"<ul> <li>Conciseness: The <code>switch</code> statement is generally more concise than a series of <code>if-else</code> statements, enhancing code readability.</li> <li>Break Statement: The use of <code>break</code> after each <code>case</code> is crucial. It exits the switch block once the matched case executes, preventing the fall-through behavior where subsequent cases would execute unintentionally. This is illustrated with cases <code>B</code> and <code>C</code>, which share the same output.</li> <li>Default Case: If none of the specified cases match the <code>grade</code>, the <code>default</code> case executes, providing a fallback for invalid inputs.</li> </ul>"},{"location":"chapters/05_decisions/02_switch/#valid-selector-types","title":"Valid Selector Types","text":"<p>The <code>switch</code> construct can be utilized with a selector of type: - Integer - Character (<code>char</code>) - String - Enum (which will be introduced later)</p> <p>Using a <code>switch</code> statement effectively can streamline your decision-making processes in programming, making your code not only shorter but also clearer and easier to follow.</p>"},{"location":"chapters/05_decisions/03_programming_task/","title":"Programming Task - Rock, Paper, Scissors","text":"<p>Here is an incomplete version of the game: Rock, Paper, Scissors.  It needs to be completed using an algorithm to determine the winner of the game.</p> <pre><code>using System;\nnamespace RockPaperScissors\n{\n    class RockPaperScissors\n    {\n        static void Main(string[] args)\n        {\n            string computerObject = \"\";\n            int computerChoice = 0; ;\n            bool computerWins = false;\n\n            Random random = new Random();\n            Console.Clear();\n            Console.WriteLine(\"Enter your choice r(ock),p(aper),s(cissors): \");\n\n            string userObject = Console.ReadLine();\n            char userObjectFirst = userObject[0];           //what does this do?            \n            computerChoice = random.Next(3);                // what does this do?\n\n            //replace the following three if statements with a case statement\n            if (computerChoice == 0) \n            {\n                computerObject = \"rock\";\n            }\n            if (computerChoice == 1) \n            {\n                computerObject = \"paper\";\n            }\n            if (computerChoice == 2) \n            {\n                computerObject = \"scissors\";\n            }\n\n            Console.WriteLine(\"Computer choses \" + computerObject);\n\n            char computerObjectFirst = computerObject[0];               //what does this do?\n\n            if (String.Equals(computerObjectFirst, userObjectFirst))    // what does this do?\n            {\n                Console.WriteLine(\"It's a draw\");\n            }                  \n            else\n            {\n                //complete the missing logic to decide who has won\n                if (computerWins == true)\n                {\n                    Console.WriteLine(\"Computer wins!\");\n                }\n                else\n                {\n                    Console.WriteLine(\"You win!\");\n                }\n            }\n            Console.WriteLine(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n</code></pre>"},{"location":"chapters/05_decisions/04_questions/","title":"Questions","text":"<ol> <li> <p>Rewrite the following <code>if</code> statements into a single <code>if ... then ... else</code> statement:</p> <pre><code>if (age &lt; 18)\n    ageCategory = \"Junior\";\nif (age &gt;= 18)\n    ageCategory = \"Senior\";\n</code></pre> </li> <li> <p>What is the output from the following code?</p> <pre><code>int sum = 17;\nif (sum &lt; 20)\n    Console.Write(\"Under \");\nelse\n    Console.Write(\"Over \");\nConsole.WriteLine(\"the limit\");\n</code></pre> </li> <li> <p>Write an appropriate selection statement/construct to do the following:</p> <ul> <li>If an integer variable <code>currentNum</code> is odd, change its value so it is now \\(3\\) times the <code>currentNum</code> + \\(1\\), otherwise change its value so that it is now half the value of <code>currentNum</code> (rounded down when <code>currentNum</code> is odd)</li> <li>If an integer variable <code>n</code> has the value \\(1\\), read in <code>double</code> values for <code>X</code> and <code>Y</code>, calculate and print their sum</li> <li>Assign a value to a <code>double</code> variable <code>cost</code> depending on the integer variable <code>distance</code> as in the following table:</li> </ul> </li> </ol> Distance Cost 0 through 100 5.00 More than 100 but not more than 500 8.00 More than 500 but less then 1,000 10.00 1,000 or more 12.00"},{"location":"chapters/05_decisions/04_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write an if-statement that takes two integer variables and exchanges their values if the first one is greater than the second one.</li> <li>Write a program that asks for a digit (0-9), and depending on the input, shows the digit as a word (in English) using a switch statement.</li> <li>A year is a leap year if it is divisible by 4, unless it is a century year, in which case it is only a leap year if it is divisible by 400 (e.g. 2000 is a leap year, but 1900 was not).  Design and write a program to accept a year and output a message indicating if it is a leap year.</li> <li> <p>(something to stretch the Maths muscles ...) Write a program that gets the coefficients \\(a\\), \\(b\\) and \\(c\\) of a quadratic equation: \\(ax^{2} + bx + c\\), calculates and prints its real roots (if they exist).</p> <p>Tip</p> <p>A quadratic equation may have one or two real roots or no real roots at all. In order to calculate the real roots of a given quadratic equation, we first calculate the discriminant (\\(D\\)) by the formula: \\(D = b^{2} - 4ac\\). If the discriminant (\\(D\\)) is zero, then the quadratic equation has one double real root and it is calculated by the formula: \\(x_{1,2} = \\frac{-b}{2a}\\).  If the value of the discriminant is positive, then the equation has two distinct real roots, which are calculated by the formula: \\(x_{1,2} = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\\). If the discriminant is negative, the quadratic equation has no real roots). Quadratic equations may have 0, 1 or 2 real roots.  The <code>Math</code> namespace has a square root method: <code>Math.Sqrt()</code>.</p> </li> <li> <p>READ and DO the tutorial on iteration</p> </li> </ol>"},{"location":"chapters/05_decisions/05_boolean_logic/","title":"Extended Theory - Boolean Logic","text":"<p>Making decisions in programming hinges on evaluating conditional expressions, which result in a value of either <code>true</code> or <code>false</code>. In C#, <code>true</code> is represented as <code>1</code> and <code>false</code> as <code>0</code>. </p>"},{"location":"chapters/05_decisions/05_boolean_logic/#boolean-logic","title":"Boolean Logic","text":"<p>Conditional expressions serve as tests that produce these two outcomes. These expressions can be combined using Boolean operators based on Boolean logic, which is fundamental to computer operations. For our purposes, there are five main Boolean operations:</p> <ul> <li>AND</li> <li>OR</li> <li>NOT</li> <li>NAND</li> <li>NOR</li> </ul> <p>Each operator typically takes two inputs, which we will denote as <code>A</code> and <code>B</code>, producing a single output, <code>Q</code>. These operations are often described using a truth table, where <code>1</code> represents <code>true</code> and <code>0</code> represents <code>false</code>. </p>"},{"location":"chapters/05_decisions/05_boolean_logic/#and-operator","title":"AND Operator","text":"<p>The AND operator produces a true output, <code>Q</code>, only when both <code>A</code> and <code>B</code> are true. All conditions must be satisfied:</p> A B Q 0 0 0 0 1 0 1 0 0 1 1 1 <p>This can be visualized using a Venn diagram, demonstrating the intersection of conditions for three variables:</p> A AND B AND C are true <p>In C#, this can be implemented as:</p> <pre><code>if (A &amp;&amp; B &amp;&amp; C)\n{\n    // Execute this block if A, B, and C are all true\n}\n</code></pre>"},{"location":"chapters/05_decisions/05_boolean_logic/#or-operator","title":"OR Operator","text":"<p>The OR operator yields a true output, <code>Q</code>, when at least one of the inputs (<code>A</code> or <code>B</code>) is true:</p> A B Q 0 0 0 0 1 1 1 0 1 1 1 1 <p>The corresponding Venn diagram for three inputs would be:</p> A OR B OR C are true <p>In C#, this would look like:</p> <pre><code>if (A || B || C)\n{\n    // Execute this block if any of A, B, or C is true\n}\n</code></pre>"},{"location":"chapters/05_decisions/05_boolean_logic/#not-operator","title":"NOT Operator","text":"<p>The NOT operator differs from the others as it takes only one input and outputs the opposite (or complement):</p> A Q 0 1 1 0 NOT A <p>In C#, the NOT operator is represented by an exclamation mark (<code>!</code>) preceding the condition:</p> <pre><code>if (!(A &amp;&amp; B &amp;&amp; C))\n{\n    // Execute this block when the condition is false\n}\n</code></pre>"},{"location":"chapters/05_decisions/05_boolean_logic/#nand-and-nor-operators","title":"NAND and NOR Operators","text":"<p>The final two operators, NAND and NOR, are simply the negation of the AND and OR operations, respectively:</p> <ul> <li>NAND: NOT (A AND B)</li> <li>NOR: NOT (A OR B)</li> </ul>"},{"location":"chapters/05_decisions/05_boolean_logic/#compound-conditionals-and-de-morgans-laws","title":"Compound Conditionals and De Morgan's Laws","text":"<p>Working with compound conditional statements can lead to confusion. Consider these two statements:</p> <pre><code>// [1]\nif (a &gt;= 0 &amp;&amp; a &lt;= 10) { ... }\n// [2]\nif (a &gt;= 0 || a &lt;= 10) { ... }\n</code></pre> <ul> <li>The first statement will evaluate to <code>true</code> if <code>a</code> is in the range of 0 to 10.</li> <li>The second statement evaluates to <code>true</code> for every value of <code>a</code>, since one of the conditions (<code>a &gt;= 0</code>) is always satisfied for non-negative values.</li> </ul> <p>Looking back at Venn diagrams, the AND operator represents the intersection, while the OR operator represents the union of the sets.</p> <p>If we want to check whether a value is not in the range of 0 to 10, we might write:</p> <pre><code>// [3]\nif (!(a &gt;= 0 &amp;&amp; a &lt;= 10)) { ... }\n</code></pre> <p>However, simplifying this incorrectly to:</p> <pre><code>// [4]\nif (a &lt; 0 &amp;&amp; a &gt; 10) { ... }\n</code></pre> <p>will produce incorrect results. </p>"},{"location":"chapters/05_decisions/05_boolean_logic/#de-morgans-laws","title":"De Morgan's Laws","text":"<p>The laws governing simplification of Boolean expressions were established by the British mathematician Augustus De Morgan. These rules state:</p> <ul> <li>NOT(A AND B) = NOT A OR NOT B</li> <li>NOT(A OR B) = NOT A AND NOT B</li> </ul> <p>For our earlier statement [3], we can use De Morgan's laws to rewrite it as:</p> <pre><code>// [5]\nif (!(a &gt;= 0) || (!(a &lt;= 10))) { ... }\n</code></pre> <p>Recognizing that <code>!(a &gt;= 0)</code> translates to <code>a &lt; 0</code>, and <code>!(a &lt;= 10)</code> translates to <code>a &gt; 10</code>, we can simplify our expression to:</p> <pre><code>// [6]\nif (a &lt; 0 || a &gt; 10) { ... }\n</code></pre> <p>By removing the NOTs from the conditional, the code becomes clearer and easier to maintain. Applying simplification rules such as De Morgan's laws is a valuable skill in Boolean algebra.</p>"},{"location":"chapters/06_iteration/","title":"Iteration","text":"<p>From the syllabus</p> <p>AQA: Use, understand and know how the following statement types can be combined in programs; Use definite and indefinite iteration, including indefinite iteration with the condition(s) at the start or the end of the iterative structure. A theoretical understanding of condition(s) at either end of an iterative structure is required (3.1.1.2/4.1.1.2):}</p> <ul> <li>Often in an algorithm, a group of statements needs to be executed again and again until a certain condition is met, this is iteration.</li> </ul> <p>Programming often requires a series of statements to be repeated.  These statements may be repeated a fixed number of times or will execute until a particular condition is reached (or not execute at all if the condition fails).  These loop constructs are one of the most important constructs to master and a key feature of algorithm design.  </p> <p>Many program errors are caused by poorly constructed loops.  If the loop never ends we enter an infinite loop, thus the key feature to remember when designing a block of statements that repeat, or loop, is the exit strategy: when should the loop terminate?</p> <p>There are two types of loop:</p> <ul> <li>for loops: when the number of iterations (repetitions) is pre-determined, also known as counted loops, or count controlled loops</li> <li>while loops: when the number of repetitions is not predetermined, or conditional loops, or condition controlled loops</li> </ul> <p>For example, consider the following problem:</p> <p>Design an algorithm and write a program to find the average of a series of numbers.</p> <p>We'll illustrate solutions to this problem with each of the three different types of loop structure available in C# in the following sections.</p>"},{"location":"chapters/06_iteration/01_while_loop/","title":"While loop","text":"<p>The <code>while</code> loop is one of the simplest and most commonly used control structures in programming. Its syntax is as follows:</p> <pre><code>while (condition)\n{\n    // body of the loop\n}\n</code></pre>"},{"location":"chapters/06_iteration/01_while_loop/#understanding-the-while-loop","title":"Understanding the While Loop","text":"<p>In this context, the condition is any expression that evaluates to a Boolean result, meaning it can be either <code>true</code> or <code>false</code>. The loop will continue to execute as long as the condition remains <code>true</code>. Once the condition becomes <code>false</code>, the loop terminates. It's important to note that if the condition is initially <code>false</code>, the loop body will not execute at all. This characteristic distinguishes the <code>while</code> loop from the <code>do ... while</code> loop, which guarantees at least one execution of the loop body.</p>"},{"location":"chapters/06_iteration/01_while_loop/#example-calculating-the-average-of-a-series-of-numbers","title":"Example: Calculating the Average of a Series of Numbers","text":"<p>Let\u2019s look at a practical example where we use a <code>while</code> loop to calculate the average of a series of numbers. </p> <pre><code>// Design an algorithm and write a program to find the average of a series of numbers.\nusing System;\n\nnamespace AverageCalculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double average;\n            double sum = 0;\n            double value;\n            int count = 0;\n            bool finished = false;\n\n            while (!finished)\n            {\n                Console.Write(\"Enter number (0 to quit) &gt; \");\n                value = Convert.ToDouble(Console.ReadLine()); // Changed to Convert.ToDouble for more accurate inputs\n                if (value == 0)\n                {\n                    finished = true; // Ends the loop if the user enters 0\n                }\n                else\n                {\n                    count++; // Increment the count of valid entries\n                    sum += value; // Add the entered value to the sum\n                }\n            }\n\n            if (count &gt; 0) // Check to avoid division by zero\n            {\n                average = sum / count; // Calculate the average\n                Console.WriteLine($\"Average = {average}\");\n            }\n            else\n            {\n                Console.WriteLine(\"No numbers were entered to calculate an average.\");\n            }\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Code Explanation</p> <ul> <li>Lines 14, 16: The <code>finished</code> Boolean variable acts as the condition for the loop. The loop will continue to run as long as <code>finished</code> is not true.</li> <li>Line 22: When the user enters <code>0</code>, <code>finished</code> is set to true, terminating the loop. If the input is non-zero, the program increments the <code>count</code> and adds the input value to <code>sum</code>.</li> <li>Line 30: Once the loop ends, the average is calculated using <code>sum</code> divided by <code>count</code>. A check is included to ensure that at least one valid number was entered to avoid division by zero.</li> </ul> <p>Note</p> <p>If the condition is <code>false</code> when the loop is first encountered, the loop will not execute at all. This property makes the <code>while</code> loop a top-tested loop, as the condition is evaluated before each iteration.</p>"},{"location":"chapters/06_iteration/01_while_loop/#alternative-exit-conditions","title":"Alternative Exit Conditions","text":"<p>An alternative approach could involve asking the user for the total number of values to be averaged. In this case, the loop would need a counter variable to track how many numbers have been entered, allowing it to terminate gracefully once the specified number is reached.</p>"},{"location":"chapters/06_iteration/02_do_while_loop/","title":"Do.. While loop","text":"<p>The <code>do ... while</code> loop is similar to the <code>while</code> loop, but with a key difference: it guarantees that the loop body will execute at least once. Its syntax is as follows:</p> <pre><code>do\n{\n    // body of the loop\n} while (condition);\n</code></pre>"},{"location":"chapters/06_iteration/02_do_while_loop/#understanding-the-do-while-loop","title":"Understanding the Do While Loop","text":"<p>In a <code>do ... while</code> loop, the condition is evaluated after the loop body has executed. This means that even if the condition is initially <code>false</code>, the code inside the loop will run once before the condition is checked. This characteristic makes the <code>do ... while</code> loop a bottom-tested loop.</p>"},{"location":"chapters/06_iteration/02_do_while_loop/#example-calculating-the-average-of-a-series-of-numbers","title":"Example: Calculating the Average of a Series of Numbers","text":"<p>Let\u2019s rewrite the previous example of calculating the average using a <code>do ... while</code> loop:</p> <pre><code>// Design an algorithm and write a program to find the average of a series of numbers.\nusing System;\n\nnamespace AverageCalculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double average;\n            double sum = 0;\n            double value;\n            int count = 0;\n            bool finished = false;\n\n            do\n            {\n                Console.Write(\"Enter number (0 to quit) &gt; \");\n                value = Convert.ToDouble(Console.ReadLine()); // Changed to Convert.ToDouble for better precision\n                if (value == 0)\n                {\n                    finished = true; // Ends the loop if the user enters 0\n                }\n                else\n                {\n                    count++; // Increment the count of valid entries\n                    sum += value; // Add the entered value to the sum\n                }    \n            } while (!finished);\n\n            if (count &gt; 0) // Check to avoid division by zero\n            {\n                average = sum / count; // Calculate the average\n                Console.WriteLine($\"Average = {average}\");\n            }\n            else\n            {\n                Console.WriteLine(\"No numbers were entered to calculate an average.\");\n            }\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Code Explanation</p> <ul> <li>Loop Execution: The <code>do ... while</code> loop starts by executing the code block. The user is prompted to enter a number, which is read and converted to a double for more accurate input.</li> <li>Exit Condition: If the user enters <code>0</code>, the <code>finished</code> variable is set to true, which will terminate the loop on the next evaluation. If the input is not zero, the program increments the <code>count</code> and adds the input value to <code>sum</code>.</li> <li>Average Calculation: After exiting the loop, the program checks if <code>count</code> is greater than <code>0</code> to avoid division by zero. If valid numbers were entered, the average is calculated and displayed. If no numbers were entered, an appropriate message is shown.</li> </ul> <p>Warning</p> <p>Be sure to include a semicolon at the end of the <code>do ... while</code> loop. This is a common syntax requirement in C# and can lead to errors if omitted.</p>"},{"location":"chapters/06_iteration/03_for_loop/","title":"For Loop","text":"<p>The <code>for</code> loop is a versatile and commonly used loop construct in programming. It is often referred to as a counted loop because it is designed to repeat a block of code a fixed number of times. The syntax is slightly more complex than other loops, but it provides clear control over the loop's execution.</p>"},{"location":"chapters/06_iteration/03_for_loop/#syntax","title":"Syntax","text":"<pre><code>for (variable initialization; condition; steps)\n{\n    // body of the loop \n}\n</code></pre>"},{"location":"chapters/06_iteration/03_for_loop/#breakdown-of-the-syntax","title":"Breakdown of the Syntax","text":"<p>The <code>for</code> loop consists of three key parts, each separated by a semicolon:</p> <ol> <li>Variable Initialization: This is where you declare and initialize a variable that will control the loop's execution.</li> <li>Condition: A boolean expression that determines whether the loop continues to execute. It returns either <code>true</code> or <code>false</code>.</li> <li>Steps: This specifies how the control variable will be incremented or decremented after each iteration.</li> </ol>"},{"location":"chapters/06_iteration/03_for_loop/#example-of-a-simple-for-loop","title":"Example of a Simple For Loop","text":"<p>Consider the following example of a basic <code>for</code> loop:</p> <pre><code>for (int i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(\"Value of i: {0}\", i);\n}\n</code></pre> <p>In this loop:</p> <ul> <li>The variable <code>i</code> is initialized to <code>0</code>.</li> <li>The loop continues to execute as long as <code>i</code> is less than <code>10</code>.</li> <li>After each iteration, <code>i</code> is incremented by <code>1</code>.</li> </ul>"},{"location":"chapters/06_iteration/03_for_loop/#example-calculating-the-average-of-a-series-of-numbers","title":"Example: Calculating the Average of a Series of Numbers","text":"<p>Here\u2019s the average calculation example, rewritten using a <code>for</code> loop:</p> <pre><code>// Design an algorithm and write a program to find the average of a series of numbers.\nusing System;\n\nnamespace AverageCalculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double average;\n            double sum = 0;\n            double value;\n            int count;\n\n            Console.Write(\"Enter the number of values to average &gt; \");\n            count = Convert.ToInt32(Console.ReadLine());\n\n            for (int i = 0; i &lt; count; i++)\n            {\n                Console.Write(\"Enter number &gt; \");\n                value = Convert.ToDouble(Console.ReadLine()); // Changed to Convert.ToDouble for better precision\n                sum += value; // Add the entered value to the sum\n            }\n\n            if (count &gt; 0) // Check to avoid division by zero\n            {\n                average = sum / count; // Calculate the average\n                Console.WriteLine($\"Average = {average}\");\n            }\n            else\n            {\n                Console.WriteLine(\"No values entered to calculate an average.\");\n            }\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Code Explanation</p> <ul> <li>Control Variable: The loop uses the variable <code>i</code> as the control variable, which is standard convention in programming. It starts at <code>0</code> and increments until it reaches <code>count</code>.</li> <li>Body of the Loop: The code block within the curly braces is executed for each iteration, prompting the user for a number and adding it to the sum.</li> <li>Average Calculation: After the loop completes, the average is calculated and displayed, with a check to avoid division by zero if no valid numbers were entered.</li> </ul> <p>Additional Notes</p> <ul> <li>Multiple Conditions: You can include multiple variables in a <code>for</code> loop, though clarity is key. For example:    <pre><code>for (int i = 0, j = 7; i &lt; j; i++, j--)\n</code></pre></li> <li>Nesting For Loops: <code>for</code> loops can be nested, but limit the number of nesting levels for readability. When nesting, it\u2019s common to use additional variable names like <code>j</code>, <code>k</code>, etc.</li> </ul>"},{"location":"chapters/06_iteration/03_for_loop/#choosing-the-right-loop","title":"Choosing the Right Loop","text":"<p>While most problems requiring loops can be solved using either a <code>for</code> loop or a <code>while</code> loop, the <code>for</code> loop is often preferred for situations where the number of iterations is known. This can help reduce the chance of errors, such as those arising from mismanaging the exit conditions in a <code>while</code> loop.</p>"},{"location":"chapters/06_iteration/04_pseudocode/","title":"Pseudocode","text":"<p>As problems get more difficult or complex it is necessary to sketch out potential solutions.  There are various tools available for programmers to do this such as flowcharts, which we met in the previous chapter, or pseudocode.</p> <p>Pseudocode is simply a way of writing out an algorithm which is independent of any programming language.  It should be written in such a way that a non-programmer could read it and know what the steps are in the algorithm.  There is no standard, or correct way, of writing pseudocode.  It will look like code, without being code.  For example:</p> <pre><code>Set total to zero\nSet grade counter to one\nWhile grade counter is less than or equal to ten\n    Input next grade\n    Add grade to the total\nSet the class average to the total divided by ten\nPrint class average\n</code></pre>"},{"location":"chapters/06_iteration/05_loop_examples/","title":"Iteration Examples","text":"<p>Let\u2019s explore some examples that require the use of iteration, loops, in C#. Each example illustrates a different loop construct and its application.</p>"},{"location":"chapters/06_iteration/05_loop_examples/#example-1-prime-numbers","title":"Example 1: Prime Numbers","text":"<p>This program calculates whether a given number is prime. A prime number is a positive integer greater than 1 that has no positive divisors other than 1 and itself. We can check if a number, <code>num</code>, is prime by dividing it by all integers between 2 and the square root of <code>num</code>. Here\u2019s how the program works:</p> <pre><code>using System;\n\nnamespace PrimeChecker\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.Write(\"Enter a positive number: \");\n            int num = int.Parse(Console.ReadLine());\n            int divisor = 2;\n            int maxDivisor = (int)Math.Sqrt(num);\n            bool isPrime = true;\n\n            while (isPrime &amp;&amp; (divisor &lt;= maxDivisor))\n            {\n                if (num % divisor == 0)\n                {\n                    isPrime = false;\n                }\n                divisor++;\n            }\n            Console.WriteLine($\"Is {num} a prime number? {isPrime}\");\n        }\n    }\n}\n</code></pre> <p>Explanation</p> <ul> <li>Lines 10-14: Initialize variables and retrieve user input. We use the <code>sqrt</code> function from the <code>Math</code> library to determine the maximum divisor needed, which optimizes our checks.</li> <li>Line 16: The <code>while</code> loop checks two conditions: <code>isPrime</code> must remain <code>true</code>, and the current <code>divisor</code> should not exceed <code>maxDivisor</code>.</li> <li>Line 18: If the number is divisible by <code>divisor</code>, it is not prime, and <code>isPrime</code> is set to <code>false</code>.</li> </ul> <p>Note</p> <p>The <code>break</code> operator can be useful for exiting the loop prematurely if needed.</p>"},{"location":"chapters/06_iteration/05_loop_examples/#example-2-factorial-calculation","title":"Example 2: Factorial Calculation","text":"<p>The factorial of a number <code>n</code>, denoted as <code>n!</code>, is the product of all positive integers from 1 to <code>n</code>. We can use a loop to calculate this:</p> <pre><code>using System;\n\nnamespace FactorialCalculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.Write(\"Enter a value &gt; \");\n            ulong numIn = ulong.Parse(Console.ReadLine()); // Changed to ulong for larger input handling\n            ulong n = numIn;\n            ulong factorial = 1;\n\n            do\n            {\n                factorial *= n;\n                n--;\n            } while (n &gt; 0);\n\n            Console.WriteLine($\"{numIn}! = {factorial}\");\n        }\n    }\n}\n</code></pre> <p>Explanation</p> <ul> <li>The <code>do ... while</code> loop ensures that the calculation occurs at least once.</li> <li>We multiply <code>factorial</code> by the input value <code>n</code> and then decrement <code>n</code> until it reaches 0.</li> <li>The <code>ulong</code> type is used to accommodate larger numbers, but be aware that factorial values grow quickly and can lead to overflow. Consider using <code>BigInteger</code> from <code>System.Numerics</code> for very large values.</li> </ul>"},{"location":"chapters/06_iteration/05_loop_examples/#example-3-approximation-of-a-square-root","title":"Example 3: Approximation of a Square Root","text":"<p>In this example, we approximate the square root of a number using an iterative method. The loop uses <code>while(true)</code> to continuously refine the approximation until a specified accuracy is achieved:</p> <pre><code>using System;\n\nnamespace Approximation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.Write(\"Enter an integer value: \");\n            int n = Convert.ToInt32(Console.ReadLine());\n            double approximateValue = n / 2.0; // Use double for better precision\n            Console.WriteLine($\"Initial approximate value = {approximateValue}\");\n\n            while (true)\n            {\n                double betterValue = (approximateValue + n / approximateValue) / 2;\n                if (Math.Abs(approximateValue - betterValue) &lt; 0.001)\n                {\n                    Console.WriteLine($\"Better value = {betterValue}\");\n                    break; // Exit the loop when sufficiently accurate\n                }\n                approximateValue = betterValue;\n            }\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Explanation</p> <ul> <li>The <code>while(true)</code> loop continues indefinitely until the <code>break</code> condition is met.</li> <li>We use the formula <code>(approximateValue + n / approximateValue) / 2</code> to calculate a better approximation of the square root.</li> <li>The loop exits when the difference between the old and new approximations is less than <code>0.001</code>.</li> </ul>"},{"location":"chapters/06_iteration/05_loop_examples/#example-4-using-a-for-loop","title":"Example 4: Using a For Loop","text":"<p>Here\u2019s an example of using a <code>for</code> loop to print numbers from 1 to 10:</p> <pre><code>using System;\n\nnamespace ForLoopExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i &lt;= 10; i++)\n            {\n                Console.WriteLine(\"Number: {0}\", i);\n            }\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>for</code> loop initializes <code>i</code> to <code>1</code> and continues as long as <code>i</code> is less than or equal to <code>10</code>, incrementing <code>i</code> by <code>1</code> in each iteration.</li> <li>This concise structure is ideal for cases where the number of iterations is known.</li> </ul>"},{"location":"chapters/06_iteration/06_programming_task/","title":"Programming Task - Guessing Game","text":"<p>The problem: Write a program to get the computer to generate a random number between 1 and 100.  Set up a loop to keep inputting the guess.  If the guess is below the number then output \"too low\".  If the guess is above the number then output \"too high\".  Stop the program when the user guesses the number.</p> <p>To implement this program we need to generate a random number.  We've seen this before in the Card game program but here's a reminder:</p> <pre><code>Random rnd = new Random();\nint myRandomNumber = Rnd.Next(100)+1; \n</code></pre> <p>The first statement looks unusual but it creates a new <code>object</code> called <code>random</code>.  This object has a number of built in methods for dealing with random numbers.  One of which is the <code>Next()</code> method.  This will return a random number between \\(1\\) and \\(100\\) in this instance.</p> <p>Note</p> <p>AQA: Random number generation in a programming language (3.1.1.8/4.1.1.8):}</p> <ul> <li>Be familiar with, and be able to use, random number generation</li> </ul>"},{"location":"chapters/06_iteration/07_questions/","title":"Questions","text":"<p>You have been asked to write a program to check the validity of a password entered by a user into a computer system.  The user will only have \\(3\\) attempts before being locked out of the system.  The system will check the entered password against one stored.</p> <ol> <li>What would be an appropriate identifier and data type for the stored password?</li> <li>What would be an appropriate identifier and data type for the entered password?</li> <li>What would be an appropriate identifier and data type for the number of attempts?</li> <li>Describe using either a flowchart or pseudocode your algorithm for this problem</li> <li>Create a password program that asks the user for the password and checks it against one that you have made up. Inform the user if they have entered the correct password or not. \u200b</li> </ol>"},{"location":"chapters/06_iteration/07_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li> <p>Display the ASCII characters associated with integers from 32 to 126 inclusive.  Do not try to display those less than 32. (Why?)  IDeally, present as a table with their decimal and hexadecimal equivalents.  (Hint: You will need to look up how to convert a character into its ASCII code equivalent)</p> </li> <li> <p>Write a program to generate the \"Hailstone Sequence\", also known as the Collatz Conjecture.  This starts with any value, if the value is even divide by 2, if it is odd multiply by 3 and add 1.  The conjecture states, whatever the start value the sequence will always reach 1.</p> </li> <li> <p>Imagine you have a can of whipped cream. Every second the nozzle stays open, \\(2\\%\\) of the remaining cream squirts out. How long, to the nearest second, will it take to empty half the can?</p> </li> <li> <p>Write a loop that generates random numbers in the range \\(1\\) to \\(100\\) until ten numbers are generated in the range \\(1\\) to \\(10\\) and ten are in the range \\(91\\) to \\(100\\). How many numbers were generated in all?</p> </li> <li> <p>Write a program to play \"Fizz Buzz\". For each number, between \\(1\\) and \\(100\\), that is evenly divisible by 3, output the word \"Fizz\".  For each number that is evenly divisible by 5, output the word \"Buzz\".   For each number that is evenly divisible by both 3 AND 5, output the word \"FizzBuzz\".</p> </li> <li> <p>Write a program that prints a triangle of numbers from \\(1\\) to a given value \\(n\\) provided by the user.  Your output should look like:</p> <pre><code>1\n1 2\n1 2 3\n1 2 3 4\n1 2 3 4 5\n</code></pre> </li> <li> <p>Write a program that reads from the console number \\(N\\) and print the sum of the first \\(N\\) members of the Fibonacci sequence: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377\\)</p> </li> </ol>"},{"location":"chapters/06_iteration/08_parity_check_digits/","title":"Extended Theory - Parity Bits, Majority Voting, Check Digits","text":"<p>Data transmission is prone to errors, which can lead to incorrect or corrupted information being received. To ensure data integrity, several error detection and correction methods are employed. This document explores three such techniques: parity checking, majority voting, and check digits.</p>"},{"location":"chapters/06_iteration/08_parity_check_digits/#parity-checking","title":"Parity Checking","text":"<p>In parity checking, an additional bit, known as a parity bit, is added to a string of binary data. This ensures that the total number of <code>1</code> bits in the string is either an odd or even number, depending on the chosen parity:</p> <ul> <li>Even Parity: The total number of <code>1</code> bits is even.</li> <li>Odd Parity: The total number of <code>1</code> bits is odd.</li> </ul> <p>Parity checking can detect single-bit errors but cannot correct them.</p> Parity Bits <p>Let's use the <code>BitArray</code> class from the <code>System.Collections</code> namespace to demonstrate how to calculate the parity bit for an integer:</p> <pre><code>using System;\nusing System.Collections;\n\nnamespace parity\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\"Enter an integer (1..127) &gt; \");\n            int inputNumber = Convert.ToInt32(Console.ReadLine());            \n            BitArray bits = new BitArray(new int[] { inputNumber });  // Convert to an array of bits\n            int count = 0;\n\n            for (int i = 0; i &lt; bits.Length; i++)\n            {\n                if (bits[i])\n                    count++;  // Count the number of 1s\n            }\n\n            Console.WriteLine($\"{count} 1s in {inputNumber}\");\n\n            // Check if the count is odd or even using modulus operator\n            if (count % 2 == 1)\n            {\n                bits[7] = true;  // Set parity bit for even parity\n            }\n\n            // Convert back to integer\n            int[] resultArray = new int[1];\n            bits.CopyTo(resultArray, 0);\n            inputNumber = resultArray[0];\n\n            Console.WriteLine($\"With parity bit set: {inputNumber}\");\n        }\n    }\n}\n</code></pre> <p>The <code>BitArray</code> class represents the bits as <code>true</code> (1) or <code>false</code> (0). We count the number of <code>true</code> values to determine the parity. </p>"},{"location":"chapters/06_iteration/08_parity_check_digits/#majority-voting","title":"Majority Voting","text":"<p>Majority voting is another error detection method where each bit in the data is duplicated an odd number of times, such as three. This redundancy helps to correct certain errors. For example, the binary data <code>101</code> becomes <code>111 000 111</code>.</p> <p>If errors occur during transmission, the receiver takes the majority of each bit group to reconstruct the original data. Although not foolproof, this method can correct some errors without needing retransmission.</p> <p>Here\u2019s how to implement and test majority voting:</p> <pre><code>static void Main(string[] args)\n{\n    // Get the character to encode\n    Console.Write(\"Enter a character to encode: \");\n    char ch = Console.ReadLine()[0];\n    string binCode = DecimalToBinary(ch);\n    Console.WriteLine($\"Encoding {ch} is: {binCode}\");\n\n    // Get the number of repetitions for each bit\n    Console.Write(\"Enter number of repeats for each bit: \");\n    int repetitions = Convert.ToInt32(Console.ReadLine());\n    string newBinCode = \"\";\n\n    for (int i = 0; i &lt; binCode.Length; i++)\n    {\n        for (int j = 0; j &lt; repetitions; j++)\n        {\n            newBinCode += binCode[i];\n        }\n    }\n\n    Console.WriteLine($\"The transmitted code is: {newBinCode}\");\n\n    // Introduce errors as a percentage\n    Console.Write(\"Enter percentage of errors to introduce: \");\n    int errorPercent = Convert.ToInt32(Console.ReadLine());\n    string errorBinCode = \"\";\n    Random rnd = new Random();\n\n    for (int i = 0; i &lt; newBinCode.Length; i++)\n    {\n        if (rnd.Next(100) &lt; errorPercent)\n        {\n            errorBinCode += newBinCode[i] == '0' ? '1' : '0';\n        }\n        else\n        {\n            errorBinCode += newBinCode[i];\n        }\n    }\n\n    Console.WriteLine($\"Code with errors introduced: {errorBinCode}\");\n\n    // Check and correct the errors using majority voting\n    string repairedCode = \"\";\n    int n = 0;\n\n    while (n &lt; errorBinCode.Length)\n    {\n        int count = 0;\n        for (int i = 0; i &lt; repetitions; i++)\n        {\n            if (errorBinCode[n] == '1')\n                count++;\n            n++;\n        }\n\n        repairedCode += count &gt; repetitions / 2 ? '1' : '0';\n    }\n\n    Console.WriteLine($\"Repaired code is: {repairedCode} or {Convert.ToChar(BinaryToDecimal(repairedCode))}\");\n}\n</code></pre>"},{"location":"chapters/06_iteration/08_parity_check_digits/#check-digits","title":"Check Digits","text":"<p>A check digit is a digit added to the end of data to help verify its accuracy. It is commonly used with credit card numbers, bank account numbers, and ISBNs.</p> <p>For example, the ISBN-13 check digit is calculated as follows:</p> <ol> <li>Multiply each digit alternately by 1 and 3.</li> <li>Sum the products.</li> <li>Find the remainder when the sum is divided by 10.</li> <li>Subtract the remainder from 10 to get the check digit.</li> </ol> <pre><code>static void Main(string[] args)\n{\n    string isbn = \"9781861972712\";\n    int sum = 0;\n\n    for (int i = 0; i &lt; isbn.Length - 1; i++)\n    {\n        int n = isbn[i] - '0';\n        sum += (i % 2 == 0) ? n * 1 : n * 3;\n    }\n\n    int remainder = sum % 10;\n    int checkDigit = remainder == 0 ? 0 : 10 - remainder;\n    Console.WriteLine($\"Check\n\n digit = {checkDigit}\");\n}\n</code></pre> <p>This code uses a ternary operator for compactness, but the logic can be expanded as shown below:</p> <pre><code>if (remainder == 0)\n{\n    checkDigit = 0;\n}\nelse\n{\n    checkDigit = 10 - remainder;\n}\n</code></pre>"},{"location":"chapters/06_iteration/08_parity_check_digits/#summary","title":"Summary","text":"<p>These error detection methods provide various ways to verify data integrity during transmission. While each has its strengths and weaknesses, they are crucial tools in ensuring accurate data communication.</p>"},{"location":"chapters/07_arrays/","title":"Arrays","text":"<p>In this chapter:</p> <ul> <li>The characteristics of an array</li> <li>How to declare an array and initialise its values</li> <li>Use an index number of access each element of the array and either set or change its value</li> <li>Loop through each element of the array using either a <code>for</code> loop or a <code>foreach</code> loop</li> <li>Sort the elements of an array into ascending or descending order</li> <li>Describe the characteristics of a 2D array, declare and initialise the values</li> <li>Use the row index and column index to access an element in a 2D array</li> <li>Traverse a 2D array using nested for loops and the `GetLength()`` method</li> </ul> <p>So far we have worked with simple data types, such as integers, reals and characters. As programs become more complex, it becomes essential to store larger amounts of data and it is impractical to use simple types to do so. For example, you might need to store and process the marks for a class of \\(20\\) students over a series of \\(5\\) assignments. It is not practical to use \\(100\\) separate integer variables to do this. What would you call them? How would you carry out the same operation on each?  </p> <p>For such a situation we need to use an array.  An array is a collection of variables, known as elements, where each element is the same data type.  </p> Arrays <p>The elements are numbered, starting with \\(0\\), the number acts as an index to access each element.  The first element is known as the lower bound of the array, the last as the upper bound.  The lower bound will always by \\(0\\) in C#.  This is important to remember when iterating through an array, as the upper bound will always be one less than its length (the number of items in the array).  Once it has been initialised the number of elements in the array is fixed.</p> <p>An array can be multi-dimensional but most commonly one or two dimensions only, anything beyond this gets difficult to manage.</p> <p>In C# an array is an object, which means it needs to be declared using different syntax.</p> <p>From the syllabus</p> <p>AQA: Single- and multi-dimensional arrays (3.2.1.2/4.2.1.2): Use arrays (or equivalent) in the design of solutions to simple problems</p> <ul> <li>An array is a data structure that can store multiple values in a single variable.</li> </ul>"},{"location":"chapters/07_arrays/01_declaring_arrays/","title":"Declaring and Allocating Memory for Arrays","text":"<p>In C#, arrays have a fixed length that is set when they are declared and cannot be changed later. This means arrays in C# are static.</p>"},{"location":"chapters/07_arrays/01_declaring_arrays/#declaring-an-array","title":"Declaring an Array","text":"<p>To declare an array, use the following syntax:</p> <pre><code>int[] myArray;\n</code></pre> <ul> <li>The <code>int</code> keyword specifies the data type of the array elements.</li> <li>The square brackets <code>[]</code> indicate that <code>myArray</code> is an array of integers, not a single integer.</li> <li>This line only creates a reference to the array on the stack. The array itself has not been created yet, and the memory required to hold the data has not been allocated. Attempting to use <code>myArray</code> at this point would result in a <code>NullReferenceException</code> because no memory has been allocated for the array elements.</li> </ul> <p>Note</p> <p>A reference in this context is a variable that is pointing to an array object, that is an address for the start of the array object.</p>"},{"location":"chapters/07_arrays/01_declaring_arrays/#allocating-memory-for-an-array","title":"Allocating Memory for an Array","text":"<p>To allocate memory for the array, use the <code>new</code> keyword:</p> <pre><code>myArray = new int[6];\n</code></pre> <ul> <li>This statement creates six consecutive memory locations on the heap, each capable of holding an integer value.</li> <li>All elements are initialized with the default integer value of <code>0</code>.</li> </ul> <p>Note</p> <p>Any numeric data type will be initialised to \\(0\\); the <code>bool</code> data type defaults to <code>false</code>.</p> <p>Let\u2019s visualize what happens in memory:</p> <p> </p> Uninitialized Memory: `myArray` points to `null`. <p> </p> Initialized Memory: `myArray` now points to the start address of a block of memory containing six integers, all initialized to `0`."},{"location":"chapters/07_arrays/01_declaring_arrays/#initializing-an-array-with-values","title":"Initializing an Array with Values","text":"<p>You can also initialize the array with specific values when declaring it:</p> <pre><code>int[] myArray = { 23, 16, 9, 86, 54, 3 };\n</code></pre> <p>In this case: - The length of the array is inferred from the number of elements provided. - The array <code>myArray</code> is created with six elements, initialized to the values specified in the curly braces.</p> <p>Similarly, you can create and initialize an array of strings:</p> <pre><code>string[] primates = { \"Gorilla\", \"Ape\", \"Lemur\", \"Simian\" };\n</code></pre> <p>Note</p> <p>The curly braces <code>{}</code> are used to initialize the array with values directly.</p>"},{"location":"chapters/07_arrays/01_declaring_arrays/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ol> <li> <p>Accessing Elements Before Initialization:    Attempting to use an array before allocating memory with the <code>new</code> keyword will result in a <code>NullReferenceException</code>.</p> </li> <li> <p>Changing Array Length:    Once created, the length of an array cannot be changed. If you need a resizable collection, consider using a <code>List&lt;T&gt;</code> instead.</p> </li> </ol>"},{"location":"chapters/07_arrays/02_accessing_elements_arrays/","title":"Accessing Elements of the Array","text":"<p>In C#, you access elements of an array using the square bracket notation. Remember that array indexing is zero-based. This means that:</p> <ul> <li><code>myArray[0]</code> references the first element in the array.</li> <li><code>myArray[2]</code> references the third element in the array.</li> </ul> <p>You can both retrieve and set the value of an element using this notation:</p> <pre><code>myArray[2] = 9;          // Sets the third element to 9\nstring[] primates = { \"Gorilla\", \"Ape\", \"Lemur\", \"Simian\" };\nprimates[0] = \"Baboon\";  // Replaces \"Gorilla\" with \"Baboon\"\n</code></pre>"},{"location":"chapters/07_arrays/02_accessing_elements_arrays/#using-loops-to-access-array-elements","title":"Using Loops to Access Array Elements","text":"<p>Loops are ideal for accessing each element in turn. The following <code>for</code> loop prints each element of the array:</p> <pre><code>int[] myArray = { 23, 16, 9, 86, 54, 3 };\nfor (int i = 0; i &lt; myArray.Length; i++)\n{\n    Console.WriteLine(myArray[i]);  // Print each element\n}\n</code></pre> <ul> <li><code>myArray.Length</code> is a property that returns the number of elements in the array. Here, it would return <code>6</code>.</li> <li>The loop runs from <code>i = 0</code> to <code>i &lt; myArray.Length - 1</code>, ensuring we do not exceed the bounds of the array.</li> </ul>"},{"location":"chapters/07_arrays/02_accessing_elements_arrays/#array-bounds-and-exceptions","title":"Array Bounds and Exceptions","text":"<ul> <li>Lower Bound: The lowest index of an array is always <code>0</code>.</li> <li>Upper Bound: The highest index is always <code>myArray.Length - 1</code>.</li> <li>Out-of-Bounds Access: Trying to access an index outside this range (e.g., <code>myArray[6]</code> or <code>myArray[-1]</code>) will result in an <code>IndexOutOfRangeException</code>. This is an error indicating that you are trying to access a memory location not allocated to the array.</li> </ul> <p>Note</p> <p>You can use expressions within the square brackets, such as <code>myArray[i + 1]</code> or <code>myArray[12 / 4 - 1]</code>, as long as the result is a valid index.</p>"},{"location":"chapters/07_arrays/02_accessing_elements_arrays/#using-the-foreach-loop","title":"Using the <code>foreach</code> Loop","text":"<p>The <code>foreach</code> loop is a convenient way to iterate through all elements in an array:</p> <pre><code>int[] myArray = { 23, 16, 9, 86, 54, 3 };\nforeach (int element in myArray)\n{\n    Console.WriteLine(element);  // Print each element\n}\n</code></pre> <ul> <li>The <code>foreach</code> loop processes each element in the array, from the first to the last.</li> <li>The loop variable <code>element</code> is read-only within the loop and represents the current array element.</li> <li>This loop is ideal for read-only access but cannot be used to modify the array elements directly.</li> </ul>"},{"location":"chapters/07_arrays/02_accessing_elements_arrays/#additional-tips","title":"Additional Tips","text":"<ul> <li>Empty Arrays: An array can be declared with a size of zero, but accessing any element will throw an <code>IndexOutOfRangeException</code>.</li> <li>Null Arrays: If an array is not initialized, attempting to access it will result in a <code>NullReferenceException</code>. Always check if an array is initialized before use.</li> </ul>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/","title":"Sorting Elements in an Array","text":"<p>From the syllabus</p> <p>AQA: Bubble Sort (4.3.5.1): Understand and be able to trace (and analyze the time complexity) of the bubble sort algorithm. Time complexity is \\(O(n^{2})\\).</p> <p>Sorting is a fundamental procedure in computer science, and there are several algorithms available to organize data. One of the simplest, yet least efficient, is the bubble sort.</p> <p>The bubble sort algorithm works by repeatedly stepping through the array, comparing adjacent elements and swapping them if they are in the wrong order. Each pass through the array moves the largest unsorted element to its correct position, \"bubbling\" it up to the top. This process is repeated until no more swaps are needed.</p>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/#example-of-bubble-sort-in-action","title":"Example of Bubble Sort in Action","text":"<p>Consider the array <code>{ 23, 16, 9, 86, 54, 3 }</code>. After each pass of the bubble sort, the array will look like this:</p> <ol> <li><code>{ 16, 9, 23, 54, 3, 86 }</code>  // 86 has bubbled to the top</li> <li><code>{ 9, 16, 23, 3, 54, 86 }</code></li> <li><code>{ 9, 16, 3, 23, 54, 86 }</code></li> <li><code>{ 9, 3, 16, 23, 54, 86 }</code></li> <li><code>{ 3, 9, 16, 23, 54, 86 }</code>  // Array is now sorted</li> </ol>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/#bubble-sort-code-in-c","title":"Bubble Sort Code in C","text":"<pre><code>using System;\n\nnamespace BubbleSortExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] myArray = { 23, 16, 9, 86, 54, 3 };\n            int temp;\n\n            Console.Clear();\n            Console.WriteLine(\"Initial contents of the array:\");\n            foreach (int value in myArray)\n            {\n                Console.Write($\"{value} \");\n            }\n\n            // Bubble Sort Implementation\n            for (int i = 0; i &lt; myArray.Length - 1; i++)\n            {\n                for (int j = 0; j &lt; myArray.Length - 1 - i; j++)\n                {\n                    if (myArray[j] &gt; myArray[j + 1])\n                    {\n                        // Swap the elements\n                        temp = myArray[j];\n                        myArray[j] = myArray[j + 1];\n                        myArray[j + 1] = temp;\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nSorted array:\");\n            foreach (int value in myArray)\n            {\n                Console.Write($\"{value} \");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/#optimizing-the-algorithm","title":"Optimizing the Algorithm","text":"<p>The code above will sort the array, but it is not efficient. It continues making passes even if the array is already sorted. To fix this, we can add a <code>bool swapped</code> flag:</p> <pre><code>bool swapped;\nfor (int i = 0; i &lt; myArray.Length - 1; i++)\n{\n    swapped = false;\n    for (int j = 0; j &lt; myArray.Length - 1 - i; j++)\n    {\n        if (myArray[j] &gt; myArray[j + 1])\n        {\n            // Swap the elements\n            temp = myArray[j];\n            myArray[j] = myArray[j + 1];\n            myArray[j + 1] = temp;\n            swapped = true;\n        }\n    }\n    // If no two elements were swapped in the inner loop, break\n    if (!swapped) break;\n}\n</code></pre> <p>This version stops if no swaps are made during a pass, indicating the array is already sorted.</p>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/#understanding-the-trace-table","title":"Understanding the Trace Table","text":"<p>Use the following trace table to understand how elements are swapped:</p> <code>i</code> <code>j</code> <code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> 0 0 16 23 9 86 54 3 1 16 9 23 86 54 3 2 16 9 23 54 86 3 3 16 9 23 54 3 86 4 16 9 23 3 54 86 1 0 9 16 23 3 54 86 1 1 9 16 3 23 54 86 1 2 9 3 16 23 54 86 <p>Notice how each pass reduces the number of elements that need to be compared (<code>j &lt; myArray.Length - 1 - i</code>).</p>"},{"location":"chapters/07_arrays/03_sorting_elements_arrays/#built-in-methods-for-sorting","title":"Built-in Methods for Sorting","text":"<p>Although it's important to understand sorting algorithms and their efficiency, C# provides built-in methods for sorting arrays:</p> <ul> <li><code>Array.Sort(myArray);</code> sorts the array in ascending order.</li> <li><code>Array.Reverse(myArray);</code> reverses the order of elements.</li> </ul> <p>Using these methods is much more efficient than manually implementing a sorting algorithm in most practical scenarios.</p> <p>Understanding and implementing algorithms like bubble sort is crucial for grasping the fundamentals of algorithm development and analyzing time complexity, which are key skills in computer science.</p>"},{"location":"chapters/07_arrays/04_2d_arrays/","title":"Arrays with More Than One Dimension","text":"<p>A one-dimensional array, also known as a vector in mathematics, stores data in a linear sequence. However, when we need to represent more complex data structures like a chess board or a table with rows and columns, we use multi-dimensional arrays. A two-dimensional array is often called a matrix in mathematics.</p> <p>Arrays can also have more than two dimensions, but these can become complicated to manage and visualize. For now, we'll focus on one-dimensional and two-dimensional arrays.</p>"},{"location":"chapters/07_arrays/04_2d_arrays/#declaring-multi-dimensional-arrays","title":"Declaring Multi-Dimensional Arrays","text":"<p>Multi-dimensional arrays in C# are declared similarly to one-dimensional arrays, but with additional commas to represent each dimension:</p> <pre><code>int[,] matrix;   // Two-dimensional array (2D array)\nint[,,] cube;    // Three-dimensional array (3D array)\n</code></pre> <p>As with one-dimensional arrays, memory needs to be allocated using the <code>new</code> keyword:</p> <pre><code>int[,] matrix = new int[8,8];  // 8x8 chessboard\nint[,] myTable = new int[4,5]; // Table with 4 rows and 5 columns\n</code></pre> <p>In <code>myTable</code>, the first dimension represents the number of rows, and the second dimension represents the number of columns. This means <code>myTable</code> has 4 rows and 5 columns:</p> 0 1 2 3 4 0 3 7 4 2 1 1 7 2 8 9 8 2 5 5 2 0 5 3 3 9 5 2 6"},{"location":"chapters/07_arrays/04_2d_arrays/#initializing-a-2d-array","title":"Initializing a 2D Array","text":"<p>Just like one-dimensional arrays, a two-dimensional array can be initialized with values using curly braces:</p> <pre><code>int[,] matrix = \n{\n    { 1, 2, 3, 4 },\n    { 5, 6, 7, 8 }\n};\n</code></pre> <p>This array has 2 rows and 4 columns.</p>"},{"location":"chapters/07_arrays/04_2d_arrays/#accessing-elements-in-a-2d-array","title":"Accessing Elements in a 2D Array","text":"<p>To access an element in a two-dimensional array, you need to specify both indices: the row index and the column index.</p> <pre><code>int value = matrix[0, 2]; // Accesses the element in the first row, third column (value is 3)\nmatrix[row, col] = 10;    // Assigns the value 10 to the specified row and column\n</code></pre> <p>Each dimension of the array has its own length, which can be accessed using the <code>GetLength()</code> method:</p> <ul> <li><code>matrix.GetLength(0);</code> returns 2 (number of rows).</li> <li><code>matrix.GetLength(1);</code> returns 4 (number of columns).</li> </ul>"},{"location":"chapters/07_arrays/04_2d_arrays/#iterating-through-a-2d-array","title":"Iterating Through a 2D Array","text":"<p>To iterate through all elements in a two-dimensional array, we typically use two nested loops, one for each dimension:</p> <pre><code>for (int row = 0; row &lt; matrix.GetLength(0); row++)\n{\n    for (int col = 0; col &lt; matrix.GetLength(1); col++)\n    {\n        Console.WriteLine($\"Element at ({row},{col}) is {matrix[row, col]}\");\n    }\n}\n</code></pre> <p>This will print every element in the array, along with its position.</p>"},{"location":"chapters/07_arrays/04_2d_arrays/#practical-example-representing-a-chessboard","title":"Practical Example: Representing a Chessboard","text":"<p>A chessboard can be represented as an 8x8 two-dimensional array, where each element could store a piece's information or whether the square is empty:</p> <pre><code>char[,] chessboard = new char[8,8];\nchessboard[0,0] = 'R'; // Rook\nchessboard[0,1] = 'N'; // Knight\n// Initialize other pieces...\n</code></pre>"},{"location":"chapters/07_arrays/04_2d_arrays/#handling-more-dimensions","title":"Handling More Dimensions","text":"<p>For three-dimensional arrays, the concept extends with an additional index. For example, a <code>cube</code> with dimensions <code>[3, 3, 3]</code> could represent a 3x3x3 Rubik's Cube. Each element in the cube would then require three indices to be accessed.</p>"},{"location":"chapters/07_arrays/04_2d_arrays/#summary","title":"Summary","text":"<p>Multi-dimensional arrays extend the concept of simple arrays to allow for more complex data representations, such as tables, grids, and even 3D structures. Understanding how to use them is crucial for handling structured data efficiently in programming.</p>"},{"location":"chapters/07_arrays/05_jagged_arrays/","title":"Jagged Arrays","text":"<p>In addition to multi-dimensional arrays, C# also supports jagged arrays, which are essentially arrays of arrays. Unlike regular multi-dimensional arrays, jagged arrays allow each row to have a different length, providing flexibility for situations where data is not uniformly structured.</p>"},{"location":"chapters/07_arrays/05_jagged_arrays/#declaring-and-initializing-jagged-arrays","title":"Declaring and Initializing Jagged Arrays","text":"<p>The key difference when declaring jagged arrays is that each dimension is marked with separate square brackets:</p> <pre><code>int[][] myJaggedArray;\nmyJaggedArray = new int[2][];\nmyJaggedArray[0] = new int[7]; // First row has 7 elements\nmyJaggedArray[1] = new int[4]; // Second row has 4 elements\n</code></pre> <p>This can also be done at the point of declaration:</p> <pre><code>int[][] myJaggedArray = {\n    new int[] { 9, 3, 14 },       // First row has 3 elements\n    new int[] { 7, 2, 5, 1, 0, 2} // Second row has 6 elements\n};\n</code></pre> <p>Each \"row\" in the jagged array is an independent array, and the rows can vary in size, making this structure more flexible than a regular multi-dimensional array.</p>"},{"location":"chapters/07_arrays/05_jagged_arrays/#when-to-use-jagged-arrays","title":"When to Use Jagged Arrays?","text":"<p>Jagged arrays are particularly useful when dealing with scenarios where rows contain varying amounts of data. For example:</p> <ul> <li>Student Scores: Each student may have different numbers of test scores.</li> <li>Polygon Vertices: Different polygons may have varying numbers of vertices.</li> <li>Uneven Data Storage: When data does not fit neatly into a rectangular structure, such as survey results where respondents answered a different number of questions.</li> </ul>"},{"location":"chapters/07_arrays/05_jagged_arrays/#example-traversing-a-jagged-array","title":"Example: Traversing a Jagged Array","text":"<p>Here's a practical example to illustrate how to declare, initialize, and iterate over a jagged array:</p> <pre><code>using System;\n\nnamespace JaggedArrayExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Declare a jagged array with three rows\n            int[][] myJaggedArray = new int[3][];\n\n            // Initialize each row with different sizes\n            myJaggedArray[0] = new int[] { 1, 2, 3, 4 };\n            myJaggedArray[1] = new int[] { 11, 34, 67 };\n            myJaggedArray[2] = new int[] { 89, 23 };\n\n            // Traverse the jagged array and print its elements\n            for (int row = 0; row &lt; myJaggedArray.Length; row++) \n            {\n                Console.Write(\"Row({0}): \", row);\n\n                for (int col = 0; col &lt; myJaggedArray[row].Length; col++) \n                {\n                    Console.Write(\"{0} \", myJaggedArray[row][col]);\n                }\n                Console.WriteLine(); // New line for each row\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/07_arrays/05_jagged_arrays/#using-foreach-for-traversal","title":"Using <code>foreach</code> for Traversal","text":"<p>A <code>foreach</code> loop can make traversal simpler and more readable:</p> <pre><code>foreach (int[] row in myJaggedArray)\n{\n    foreach (int element in row)\n    {\n        Console.Write(element + \" \");\n    }\n    Console.WriteLine();\n}\n</code></pre>"},{"location":"chapters/07_arrays/05_jagged_arrays/#important-considerations","title":"Important Considerations","text":"<ul> <li>Initialization: Uninitialized rows in a jagged array will cause a <code>NullReferenceException</code> if accessed. Always ensure each row is initialized before use.</li> <li>Memory Efficiency: Jagged arrays can be more memory-efficient than multi-dimensional arrays if the row sizes vary significantly.</li> </ul>"},{"location":"chapters/07_arrays/05_jagged_arrays/#summary","title":"Summary","text":"<p>Jagged arrays provide a flexible way to handle collections of data with different lengths, making them a versatile choice for many programming scenarios. Understanding how to use and manipulate them is key to effectively managing non-uniform data structures in C#.</p>"},{"location":"chapters/07_arrays/06_lists/","title":"Lists","text":"<p>A limitation of arrays is that their size is fixed (static)\u2014once declared, the number of elements in an array cannot be changed at runtime. In contrast, a <code>List</code> is an ordered collection of elements that can grow or shrink as needed, making it dynamic.</p> <p>Like arrays, each element in a <code>List</code> must be of the same data type, and you can access elements by their index. However, the flexibility to adjust the number of elements makes <code>List</code> a more versatile option in many cases.</p>"},{"location":"chapters/07_arrays/06_lists/#declaring-a-list","title":"Declaring a List","text":"<p>To use a <code>List</code>, you need to include the <code>System.Collections.Generic</code> namespace. When declaring a <code>List</code>, you must specify the data type of its elements using angle brackets. Here\u2019s an example:</p> <pre><code>using System.Collections.Generic; // Remember to include this\n...\n...\nList&lt;int&gt; Marks = new List&lt;int&gt;();  // Initialize a list of integers\nMarks.Add(78);                      // Add elements using Add()\nMarks.Add(65);\nMarks.Add(82);\n\nforeach(int mark in Marks)           // Use foreach to iterate over the list\n{                                    // No changes to the list are allowed during foreach\n    Console.WriteLine(mark);         // Output each element\n}\n\n// or\n\nfor (int i = 0; i &lt; Marks.Count; i++)  // Use a for loop to access elements by index\n{\n    if (Marks[i] &gt; 75)\n    {\n        Console.WriteLine($\"{Marks[i]} = Distinction\");\n    }\n}\n</code></pre>"},{"location":"chapters/07_arrays/06_lists/#modifying-a-list","title":"Modifying a List","text":"<p>Unlike arrays, a <code>List</code> allows elements to be added and removed dynamically. You can remove elements either by value or by their index:</p> <pre><code>Marks.Remove(65);   // Removes the first occurrence of 65\nMarks.RemoveAt(0);  // Removes the element at index 0\n</code></pre>"},{"location":"chapters/07_arrays/06_lists/#checking-if-a-list-contains-an-element","title":"Checking if a List Contains an Element","text":"<p>You can check if a list contains a specific element using the <code>Contains()</code> method:</p> <pre><code>if (Marks.Contains(54))  // Checks if 54 is in the list\n{\n    // Do something\n}\n</code></pre> <p>To avoid duplicates, you can use this method before adding new elements:</p> <pre><code>if (!Marks.Contains(54))\n{\n    Marks.Add(54);\n}\n</code></pre>"},{"location":"chapters/07_arrays/06_lists/#other-useful-methods","title":"Other Useful Methods","text":"<p>Here are some other common methods for working with lists:</p> <ul> <li><code>Insert(index, value)</code> - Insert an element at a specific position.</li> <li><code>Clear()</code> - Remove all elements from the list.</li> <li><code>IndexOf(value)</code> - Find the index of the first occurrence of an element.</li> </ul> <pre><code>Marks.Insert(1, 90); // Inserts 90 at index 1\nint index = Marks.IndexOf(82); // Gets the index of 82\nMarks.Clear(); // Removes all elements from the list\n</code></pre>"},{"location":"chapters/07_arrays/06_lists/#differences-between-arrays-and-lists","title":"Differences Between Arrays and Lists","text":"<ul> <li>Static vs Dynamic: Arrays have a fixed size, while lists can grow or shrink.</li> <li>Length vs Count: Use <code>.Length</code> for arrays and <code>.Count</code> for lists to get the number of elements.</li> <li>Indexing: Both arrays and lists are zero-indexed, meaning the first element is at index 0.</li> </ul>"},{"location":"chapters/07_arrays/06_lists/#efficiency-consideration","title":"Efficiency Consideration","text":"<p>While lists are flexible, some operations (like removing elements from the middle) can be less efficient than arrays because elements need to be shifted to fill gaps.</p>"},{"location":"chapters/07_arrays/06_lists/#summary","title":"Summary","text":"<p><code>List</code> in C# offers a flexible, dynamic alternative to arrays, allowing you to modify the size of the collection at runtime. With methods like <code>Add()</code>, <code>Remove()</code>, and <code>Contains()</code>, lists are easy to work with and are suitable for situations where the number of elements is not known in advance or can change during program execution.</p>"},{"location":"chapters/07_arrays/07_programming_task/","title":"Programming Task - Improving the Bubble Sort","text":"<ol> <li>Make the improvements to the Bubble Sort routine as mentioned in the text previously</li> <li> <p>Create a top films program that stores your top 5 films in an array. Use this code to start: <code>string[] films = { \"ADD\", \"YOUR\", \"TOP\", \"5\", \"FILMS\" };</code> The program should:</p> <ul> <li>Create a string array with your top 5 films (use the template code above)</li> <li>Display each of the films using a foreach loop</li> <li>Sort the array into ascending order using Array.Sort() then display the elements</li> <li>Reverse the array into descending order using Array.Reverse() then display the elements</li> <li>Replace the last film from the reversed array with another film then display the elements</li> </ul> </li> <li> <p>Create a subject entry program that allows a user to input all the subjects they are studying and then displays the list of subjects back to them. The program should:</p> <ul> <li>Ask the user for the number of subjects they currently study</li> <li>Create an array with a length that matches the number of subjects</li> <li>Use a loop to store each subject as an element in the array</li> <li>Use another loop to output all the subjects entered</li> <li>Challenge: Allow the user to modify their subject choices.</li> </ul> </li> </ol>"},{"location":"chapters/07_arrays/07_programming_task/#extension-activity","title":"Extension Activity","text":"<p>You have been asked to create a cinema seating program for a local cinema. The cinema needs to keep track of which seats are filled and which are empty. The screens all have 10 rows of seats (A-J) and 18 seats per row. If a seat is booked, it should record whether it is an adult or child sat there.</p> <p>Your program should:</p> <ul> <li>Use a 2D array to represent the seating for a screen</li> <li>Display all of the seats to see which ones are booked or empty</li> <li>Allow the user to book a specific seat if the seat is empty</li> <li>Allow the user to book multiple seats next to each other in a row</li> <li>Output the total number of adult seats booked, child seats booked, and seats left</li> </ul>"},{"location":"chapters/07_arrays/08_questions/","title":"Questions","text":"<ol> <li> <p>An array has been created to store test marks:</p> <pre><code>| [0] | [1] | [2] | [3] | [4] | [5] | [6] |\n|-----|-----|------|----|-----|-----|-----|\n| 32  |  65 |  59  | 23 |  71 | 47  | 63  |\n</code></pre> <p>a. What is the value contained in index [3]?</p> <p>b. How many indices does the array have?</p> <p>c. What is the index for the value 65?</p> <p>d. The marks for [2] gets changed to 58 following a remark.  Write the C# statement to make this change.</p> </li> <li> <p>A 2D array, <code>marks</code>, stores the marks achieved by students in a recent exam:</p> [0] [1] [2] [3] [4] [5] [6] Programming Test 32 65 59 23 71 47 63 Theory Test 38 52 65 32 71 49 70 <p>a. What is the value contained in <code>marks[2,3]</code>?</p> <p>b. How many values can be stored in this array?</p> <p>c. What is the index reference for the value \\(49\\)?</p> <p>d. The mark in student [3] in their programming test has been entered incorrectly, write the C# statement to update this mark to \\(33\\)</p> </li> <li> <p>Study the following code<sup>1</sup>:</p> <pre><code>int n = 78;\nint r;\nConsole.Write(\"Enter an integer: \");\nn = Convert.ToInt32(Console.ReadLine());\nstring op = \"\";\nwhile (n &gt; 0)\n{\n    r = n % 2;\n    n = n / 2;\n    op = r + op;\n}\nConsole.WriteLine(op);\n</code></pre> <p>a. Complete a trace table for this code with the input value 47</p> <p>b. What does the code do?</p> </li> </ol>"},{"location":"chapters/07_arrays/08_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write a program, which creates an array of 20 integer elements.  Each element should be initialised with a value equal to the square of its index.  Print the elements to the screen.</li> <li>Write a program to read in the contents of a \\(10\\) element array, then prints them to the screen in reverse order of entry.</li> <li>Write a program that initialises an array of 20 elements with random integers (\\(0 &lt;= n &gt;= 100\\)).  Ask the user for an integer and search the array to discover if their number is in the array.</li> <li>Write a program to read 20 integers from the user and sort the even and odd numbers into two separate arrays and print the results to the screen</li> <li>Write a program to merge two arrays of the same size sorted in ascending order into a new array</li> <li>Write a program to print to the screen a multiplication table (1-12)</li> <li>Write a program to read elements of two matrices (2D arrays) and add elements of each matrix.  Print the result to the screen.</li> <li>There are lots of different sorting algorithms.  Research the selection sort, and the insertion sort.  Write programs to implement both of these sorting algorithms.</li> <li>Write a program that lists all prime numbers between 1 and a given value.  Use a List to store the results (as we don't know how many prime numbers there might be)</li> </ol> <ol> <li> <p>Adapted from A Level WikiBooks \u21a9</p> </li> </ol>"},{"location":"chapters/07_arrays/09_big_O_notation/","title":"Big O Notation","text":"<p>TODO</p>"},{"location":"chapters/08_strings_encryption/","title":"Strings, Encryption, and Testing","text":"<p>In this chapter</p> <ul> <li>Declaring, creating, and initializing a string data type.</li> <li>Implementing some of the common string handling methods used in C#.</li> <li>Introduction to regular expressions.</li> <li>Rudimentary encryption using the Caesar Cipher.</li> <li>How to dry-run a program using a trace table.</li> </ul> <p>A string in C# is a sequence of characters (<code>char</code>) stored in memory. While the <code>char</code> data type is used for a single character, we use the <code>string</code> data type for a sequence of characters. </p> <p>As discussed in Chapter 4 (\"Using the Console\"), each character in .NET is represented using a numeric value from the Unicode standard. Unicode succeeded ASCII as the default for character representation. ASCII uses a single byte to represent common English characters and symbols, but it is too limited for non-English alphabets and additional symbols. Unicode, in .NET, uses a 16-bit code, providing 65,535 different available characters.</p> <p>Although we could theoretically create an array of <code>char</code> with a specified length, it would be static and require manual processing for each character. While there are some situations where arrays of <code>char</code> are necessary, C# provides the <code>String</code> class, which is used more frequently due to its flexibility and ease of use.</p> <p>One important aspect of the <code>String</code> class is that it is immutable, meaning that its contents cannot be altered after it is created. Instead, if we try to change a string, a new string object is created in memory:</p> <pre><code>string name = \"Peter\";\nname[0] = 'S';          // This line will cause a compilation error\nname = \"Sally\";         // A new string \"Sally\" is created, and name now refers to it\nConsole.WriteLine(name); // Outputs: Sally\n</code></pre> <p>Internally, a string is represented as an array of characters, allowing individual access to its elements using indices:</p> <pre><code>string myString = \"Hello, World!\";\nConsole.WriteLine(myString.Length);     // Outputs: 13\nConsole.WriteLine(myString[0]);         // Outputs: 'H'\n</code></pre> <p>From the syllabus</p> <p>AQA: String-handling operations in a programming language (3.1.1.7/4.1.1.7)</p> <ul> <li>Be familiar with and be able to use: length, position, substring, concatenation, character to character code, character code to character, string conversion operations.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/","title":"Declaring, Creating, and Initializing a String in C","text":""},{"location":"chapters/08_strings_encryption/01_declaring_strings/#declaring-a-string-variable","title":"Declaring a String Variable","text":"<p>To declare a string variable in C#, use the following syntax:</p> <pre><code>string myString;\n</code></pre> <ul> <li>This tells the compiler that <code>myString</code> is a string variable.</li> <li>At this point, <code>myString</code> is uninitialized and has a default value of <code>null</code>.</li> </ul> <p>Note</p> <ul> <li>A variable with a <code>null</code> value means it is not pointing to any object in memory. Trying to use <code>myString</code> without assigning a value will result in a runtime error.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#understanding-reference-types","title":"Understanding Reference Types","text":"<p>Strings, like arrays, are reference types. This means:</p> <ul> <li>Stack vs. Heap Memory:<ul> <li>The variable <code>myString</code> on the stack holds a reference (memory address) to the actual string object stored on the heap.</li> <li>When you declare a string without assigning a value, the variable exists but does not reference any object in memory.</li> </ul> </li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#instantiating-and-initializing-a-string","title":"Instantiating and Initializing a String","text":"<p>Before using a string, you must initialize it by assigning a value:</p> <pre><code>myString = \"Hello, World!\";\nstring name = \"\";\n</code></pre> <ul> <li>The string literal <code>\"Hello, World!\"</code> is created in the heap, and <code>myString</code> holds a reference to this location.</li> <li><code>name</code> is initialized as an empty string (<code>\"\"</code>).</li> </ul> <p>Warning</p> <ul> <li>Declaring a string variable without assigning a value and then trying to use it will result in a <code>NullReferenceException</code>.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#copying-string-references","title":"Copying String References","text":"<p>If you assign one string variable to another, you're copying the reference, not the value:</p> <pre><code>string myNewString = myString;\n</code></pre> <ul> <li>This means <code>myNewString</code> now points to the same memory location as <code>myString</code>.</li> <li>Any changes to the string object will be reflected in both variables.</li> </ul> <p>Note</p> <ul> <li>Even though strings are reference types, they are immutable. This means you cannot change the value of an existing string object in memory. Any modification results in a new string object being created.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#string-initialization-in-one-step","title":"String Initialization in One Step","text":"<p>You can declare and initialize a string in a single step:</p> <pre><code>string greeting = \"Welcome to A Level Computer Science!\";\n</code></pre>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#reading-and-printing-strings","title":"Reading and Printing Strings","text":"<p>We have seen these methods quite a bit in previous sections, but copied here for completeness.</p>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#reading-from-the-console","title":"Reading from the Console","text":"<p>The <code>ReadLine()</code> method reads a line of text entered by the user and returns it as a string:</p> <pre><code>Console.Write(\"Enter your name: \");\nstring name = Console.ReadLine();\n</code></pre> <ul> <li>The <code>ReadLine()</code> method waits for the user to press Enter and assigns the input to the <code>name</code> variable.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#printing-to-the-console","title":"Printing to the Console","text":"<p>The <code>WriteLine()</code> method prints a string to the console:</p> <pre><code>Console.WriteLine(\"Hello, \" + name + \"!\");\n</code></pre> <ul> <li>This uses string concatenation to combine the greeting and the <code>name</code> variable.</li> </ul>"},{"location":"chapters/08_strings_encryption/01_declaring_strings/#string-interpolation","title":"String Interpolation","text":"<p>String interpolation provides a more readable way to include variables in strings:</p> <pre><code>Console.WriteLine($\"Hello, {name}!\");\n</code></pre> <ul> <li>The <code>$</code> symbol before the string allows you to embed variables directly within the curly braces <code>{}</code>.</li> </ul> <p>Advantages of String Interpolation: - More readable and easier to manage, especially with complex strings. - Avoids the need to use the <code>+</code> operator for concatenation.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/","title":"String Methods in C","text":"<p>The <code>string</code> class in C# provides a variety of methods and properties for handling and processing strings. Below are some commonly used methods along with examples and explanations.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#comparing-strings","title":"Comparing Strings","text":""},{"location":"chapters/08_strings_encryption/02_string_methods/#using-equals","title":"Using <code>Equals()</code>","text":"<p>The <code>Equals()</code> method checks if two strings are equal. It works similarly to the <code>==</code> operator but is generally preferred when dealing with objects.</p> <pre><code>string word1 = \"C#\";\nstring word2 = \"c#\";\n\nConsole.WriteLine(word1.Equals(\"C#\"));  // True\nConsole.WriteLine(word1.Equals(word2)); // False\nConsole.WriteLine(word1 == \"C#\");       // True\nConsole.WriteLine(word1 == word2);      // False\n</code></pre> <p>Note</p> <p>String comparison using <code>Equals()</code> is case-sensitive. To perform a case-insensitive comparison, use <code>Equals(word2, StringComparison.OrdinalIgnoreCase)</code>.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#using-compareto","title":"Using <code>CompareTo()</code>","text":"<p>The <code>CompareTo()</code> method compares two strings based on their lexicographical order (dictionary order).</p> <ul> <li>It returns <code>-1</code> if the first string is less than the second.</li> <li>It returns <code>0</code> if they are equal.</li> <li>It returns <code>1</code> if the first string is greater than the second.</li> </ul> <pre><code>string word1 = \"Aardvark\";\nstring word2 = \"Adam\";\n\nConsole.WriteLine(word1.CompareTo(word2)); // -1\n</code></pre> <p>Tip</p> <p>Remember that lowercase letters come after uppercase letters in ASCII order.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#concatenation","title":"Concatenation","text":"<p>Joining strings together can be done using the <code>+</code> operator or the <code>Concat()</code> method.</p> <pre><code>string hello = \"Hello\";\nstring world = \"World\";\n\nConsole.WriteLine(hello + \" \" + world);             // \"Hello World\"\nConsole.WriteLine(string.Concat(hello, \" \", world)); // \"Hello World\"\n</code></pre>"},{"location":"chapters/08_strings_encryption/02_string_methods/#concatenation-with-other-data-types","title":"Concatenation with Other Data Types","text":"<pre><code>string message = \"Your age is \";\nint age = 17;\n\nmessage += age;  // \"Your age is 17\"\nConsole.WriteLine(message);\n</code></pre> <p>Note</p> <p>Avoid excessive use of <code>+</code> for string concatenation in loops, as it can affect performance. Consider using <code>StringBuilder</code> for repeated modifications.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#changing-case","title":"Changing Case","text":"<p>The methods <code>ToUpper()</code> and <code>ToLower()</code> convert all characters in a string to their uppercase or lowercase equivalents.</p> <pre><code>string password = \"qwertyuiop\";\nConsole.WriteLine(password.ToUpper());  // \"QWERTYUIOP\"\n</code></pre> <p>Use these methods for case-insensitive string comparisons or standardizing input.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#searching-for-a-substring","title":"Searching for a Substring","text":""},{"location":"chapters/08_strings_encryption/02_string_methods/#using-indexof","title":"Using <code>IndexOf()</code>","text":"<p>The <code>IndexOf()</code> method searches for the first occurrence of a substring within a string and returns its index. It returns <code>-1</code> if the substring is not found.</p> <pre><code>string title = \"Introduction to Computer Science\";\nConsole.WriteLine(title.IndexOf(\"tro\"));  // 2\nConsole.WriteLine(title.IndexOf(\"COMPUTER\"));  // -1 (case-sensitive)\n</code></pre> <p>Tip</p> <p>Searches are case-sensitive. Convert both strings to the same case using <code>ToUpper()</code> or <code>ToLower()</code> for a case-insensitive search.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#using-lastindexof","title":"Using <code>LastIndexOf()</code>","text":"<p><code>LastIndexOf()</code> returns the index of the last occurrence of a substring within the string.</p> <pre><code>string text = \"This is a test. This is only a test.\";\nConsole.WriteLine(text.LastIndexOf(\"test\"));  // 27\n</code></pre>"},{"location":"chapters/08_strings_encryption/02_string_methods/#extracting-a-substring","title":"Extracting a Substring","text":"<p>The <code>Substring()</code> method extracts a portion of the string starting from a specified index. Optionally, you can specify the length of the substring.</p> <pre><code>string title = \"Introduction to Computer Science\";\nConsole.WriteLine(title.Substring(16, 8));  // \"Computer\"\n</code></pre>"},{"location":"chapters/08_strings_encryption/02_string_methods/#combining-indexof-with-substring","title":"Combining <code>IndexOf()</code> with <code>Substring()</code>","text":"<p>You can use <code>IndexOf()</code> to find the starting position of a substring and then use <code>Substring()</code> to extract it.</p> <pre><code>string name = \"Ms Robinson\";\nint charPos = name.IndexOf(\"R\"); // Finds the position of 'R'\nstring lastName = name.Substring(charPos);\nConsole.WriteLine(lastName);     // \"Robinson\"\n</code></pre>"},{"location":"chapters/08_strings_encryption/02_string_methods/#splitting-a-string","title":"Splitting a String","text":"<p>The <code>Split()</code> method breaks a string into an array of substrings based on a specified delimiter.</p> <pre><code>string teams = \"Arsenal,Chelsea,Everton,Liverpool\";\nstring[] teamsArray = teams.Split(',');\n\nforeach (string team in teamsArray)\n{\n    Console.WriteLine(team);\n}\n// OUTPUT:\n// Arsenal\n// Chelsea\n// Everton\n// Liverpool\n</code></pre> <p>Note</p> <p>If you need to split a string on multiple delimiters or with more complex logic, use <code>Regex.Split()</code>.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#replacing-a-substring","title":"Replacing a Substring","text":"<p>The <code>Replace()</code> method substitutes all occurrences of a specified substring with another substring.</p> <pre><code>string message = \"Hi John\";\nstring newMessage = message.Replace(\"John\", \"Imran\");\nConsole.WriteLine(newMessage);  // \"Hi Imran\"\n</code></pre> <p><code>Replace()</code> is case-sensitive. Use it carefully when replacing text in a case-insensitive context.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#escaping-characters-in-a-string","title":"Escaping Characters in a String","text":"<p>Strings must be enclosed in double quotes (<code>\"</code>). To include special characters, use escape sequences:</p> <pre><code>string message = \"Hello, my name is \\\"Khalid\\\" and I am from London\";\nConsole.WriteLine(message);  // Hello, my name is \"Khalid\" and I am from London\n</code></pre>"},{"location":"chapters/08_strings_encryption/02_string_methods/#common-escape-characters","title":"Common Escape Characters","text":"Escape Character Result Description <code>\\\\'</code> <code>'</code> Single quote <code>\\\\\"</code> <code>\"</code> Double quote <code>\\\\\\\\</code> <code>\\</code> Backslash <code>\\\\n</code> New Line Moves cursor to the beginning of the next line <code>\\\\t</code> Tab Inserts a tab space <code>\\\\b</code> Backspace Moves cursor back one space <p>Use escape sequences to handle characters like quotes and backslashes within your strings.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#empty-string","title":"Empty String","text":"<p>There are two equivalent ways to initialize an empty string in C#:</p> <pre><code>string myString1 = String.Empty; // More readable and common\nstring myString2 = \"\";           // Equivalent to String.Empty\n\nif (myString1 == String.Empty)\n{\n    Console.WriteLine(\"String is empty\");\n}\n</code></pre> <p>Note</p> <p><code>string</code> is an alias for <code>System.String</code>. They can be used interchangeably.</p>"},{"location":"chapters/08_strings_encryption/02_string_methods/#summary","title":"Summary","text":"<ul> <li>C# provides a rich set of string methods for common operations like comparison, concatenation, and modification.</li> <li>Be aware of case sensitivity when using methods like <code>Equals()</code>, <code>IndexOf()</code>, and <code>Replace()</code>.</li> <li>Use escape sequences to handle special characters within strings.</li> <li>For complex string manipulation, consider using classes like <code>StringBuilder</code> for better performance.</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/","title":"Regular Expressions in C#","text":"<p>From the syllabus</p> <p>AQA: Know that a regular expression is simply a way of describing a set and that regular expressions allow particular types of languages to be described in a convenient shorthand notation; Be able to form and use simple regular expressions for string manipulation and matching. (4.4.2.3)</p>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#introduction-to-regular-expressions","title":"Introduction to Regular Expressions","text":"<p>A regular expression (often abbreviated as regex or regexp) is a sequence of characters that defines a search pattern. They are incredibly useful for tasks such as:</p> <ul> <li>Validating input formats (e.g., email addresses, phone numbers).</li> <li>Extracting information from strings (e.g., dates, tags in HTML).</li> <li>Replacing or transforming substrings within a larger string.</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#basic-syntax","title":"Basic Syntax","text":"<p>The syntax of a regular expression may look confusing at first, but once you understand the basics, they become a powerful tool. Let's break down a simple example to illustrate.</p>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#example-matching-a-date-format","title":"Example: Matching a Date Format","text":"<p>Suppose you want to find dates in the format <code>\"May 12\"</code> or <code>\"February 14\"</code>. The corresponding regular expression pattern is:</p> <pre><code>string pattern = @\"([a-zA-Z]+) (\\d+)\";\n</code></pre> <p>This pattern consists of:</p> <ul> <li><code>@</code>: The <code>@</code> symbol denotes a verbatim string in C#. This means backslashes are treated as literal characters, which is convenient for writing regex patterns.</li> <li><code>([a-zA-Z]+)</code>: A group (<code>( )</code>) that matches one or more (<code>+</code>) uppercase or lowercase letters (<code>[a-zA-Z]</code>).</li> <li><code>(\\d+)</code>: A group that matches one or more digits (<code>\\d</code>).</li> </ul> <p>This pattern matches \"May 12\" or \"February 14\" but not \"12 May\" or \"14 February\".</p>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#common-regular-expression-patterns","title":"Common Regular Expression Patterns","text":"<p>Here are some common regex patterns and their meanings:</p> Pattern Meaning <code>abc...</code> Letters <code>123...</code> Digits <code>\\d</code> Any digit (equivalent to <code>[0-9]</code>) <code>\\D</code> Any non-digit character <code>.</code> Any character except newline <code>\\.</code> A literal full stop <code>[abc]</code> Any one of 'a', 'b', or 'c' <code>[^abc]</code> Not 'a', 'b', or 'c' <code>[a-z]</code> Any lowercase letter <code>[0-9]</code> Any digit <code>\\w</code> Any alphanumeric character (<code>[a-zA-Z0-9_]</code>) <code>\\W</code> Any non-alphanumeric character <code>{m}</code> Exactly m repetitions <code>{m,n}</code> Between m and n repetitions <code>*</code> Zero or more repetitions <code>+</code> One or more repetitions <code>?</code> Zero or one repetition <code>\\s</code> Any whitespace <code>\\S</code> Any non-whitespace character <code>^</code> Start of a string <code>$</code> End of a string <code>(abc\\|def)</code> Either 'abc' or 'def' <code>(...)</code> Grouping"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#practical-examples","title":"Practical Examples","text":""},{"location":"chapters/08_strings_encryption/03_regular_expressions/#validating-email-addresses","title":"Validating Email Addresses","text":"<p>A regular expression pattern to validate email addresses might look like this:</p> <pre><code>string emailPattern = @\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\";\n</code></pre> <p>Explanation:</p> <ul> <li><code>^[a-zA-Z0-9._%+-]+</code>: Start with one or more letters, digits, dots, underscores, percent signs, plus or minus signs.</li> <li><code>@[a-zA-Z0-9.-]+</code>: An <code>@</code> symbol followed by one or more letters, digits, dots, or hyphens.</li> <li><code>\\.[a-zA-Z]{2,}$</code>: A dot followed by 2 or more letters, representing the domain (e.g., .com, .org).</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#extracting-html-tags","title":"Extracting HTML Tags","text":"<p>Let's extract all the HTML tags from a snippet of text:</p> <pre><code>using System;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main()\n    {\n        string html = @\"&lt;p&gt;The date of the next show will be &lt;strong&gt;May 12&lt;/strong&gt;&lt;/p&gt;\";\n        string pattern = @\"&lt;/?[a-z]+&gt;\";\n\n        Regex rx = new Regex(pattern);\n        MatchCollection matches = rx.Matches(html);\n\n        foreach (Match match in matches)\n        {\n            Console.WriteLine(match.Value);\n        }\n    }\n}\n</code></pre> <p>This pattern <code>&lt;/?[a-z]+&gt;</code> matches:</p> <ul> <li><code>&lt;p&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;/strong&gt;</code>, <code>&lt;/p&gt;</code>.</li> </ul> <p>Explanation:</p> <ul> <li><code>&lt;/?</code>: Matches either <code>&lt;</code> or <code>&lt;/</code> (the <code>?</code> makes the preceding <code>/</code> optional).</li> <li><code>[a-z]+</code>: Matches one or more lowercase letters representing the tag name.</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#using-regular-expressions-in-c","title":"Using Regular Expressions in C","text":"<p>To use regular expressions in C#, import the <code>System.Text.RegularExpressions</code> namespace and use the <code>Regex</code> class.</p>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#basic-operations","title":"Basic Operations","text":"<ul> <li> <p>Creating a Regex object: <pre><code>Regex regex = new Regex(pattern);\n</code></pre></p> </li> <li> <p>Matching Patterns: <pre><code>Match match = regex.Match(inputString);\n</code></pre></p> </li> <li> <p>Finding Multiple Matches: <pre><code>MatchCollection matches = regex.Matches(inputString);\n</code></pre></p> </li> <li> <p>Replacing Text: <pre><code>string result = regex.Replace(inputString, replacementString);\n</code></pre></p> </li> <li> <p>Splitting Strings: <pre><code>string[] result = regex.Split(inputString);\n</code></pre></p> </li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#matching-and-extracting","title":"Matching and Extracting","text":"<p>Use the <code>Match</code> method to find the first match:</p> <pre><code>Match match = regex.Match(inputString);\nif (match.Success)\n{\n    Console.WriteLine($\"Found: {match.Value}\");\n}\n</code></pre>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#replacing-text","title":"Replacing Text","text":"<p>Replace all digits in a string with an asterisk (<code>*</code>):</p> <pre><code>string input = \"Phone: 123-456-7890\";\nstring pattern = @\"\\d\";\nstring result = Regex.Replace(input, pattern, \"*\");\nConsole.WriteLine(result);  // \"Phone: ***-***-****\"\n</code></pre>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#splitting-a-string","title":"Splitting a String","text":"<p>Split a string based on whitespace characters:</p> <pre><code>string input = \"Split this   sentence by   spaces.\";\nstring pattern = @\"\\s+\";\nstring[] words = Regex.Split(input, pattern);\n\nforeach (string word in words)\n{\n    Console.WriteLine(word);\n}\n</code></pre>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Be mindful of complex patterns that can degrade performance, especially in large texts or within loops.</li> <li>Use compiled regular expressions (<code>RegexOptions.Compiled</code>) for better performance in repeated use.</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#resources-for-further-learning","title":"Resources for Further Learning","text":"<p>Regular expressions can become quite complex. Explore the following resources for more in-depth learning:</p> <ul> <li>RegexOne Tutorial: Interactive tutorials for learning the basics.</li> <li>Comprehensive C# Reference on RegexOne: In-depth guide on using regex in C#.</li> </ul>"},{"location":"chapters/08_strings_encryption/03_regular_expressions/#summary","title":"Summary","text":"<ul> <li>Regular expressions are powerful tools for text processing, validation, and transformation.</li> <li>Use verbatim strings (<code>@</code>) in C# to simplify regex patterns.</li> <li>Understand the most common patterns and their use cases.</li> <li>Practice with tools like RegexOne to master the basics.</li> </ul> <p>Regular expressions can be challenging, but with practice, you'll be able to use them effectively in your C# programs.</p>"},{"location":"chapters/08_strings_encryption/04_programming_task/","title":"Programming Task - The Caesar Cipher","text":"<p>From the syllabus</p> <p>AQA: Understand what is meant by encryption and be able to define it. (3.5.6.8/4.5.6.10): Be familiar with Caesar cipher and be able to apply it to encrypt a plaintext message and decrypt a ciphertext. Be able to explain why it is easily cracked.</p> <ul> <li>Encryption is the method by which information is converted into secret code that hides the information's true meaning. In computing, unencrypted data is also known as plaintext, and encrypted data is called ciphertext. The formulas used to encode and decode messages are called encryption algorithms, or ciphers.</li> </ul> <p>Encryption is is the term used to converting information into an alternative, scrambled form so that only those who know how to unscramble the data can read the message.  The process takes the original message, the plaintext and applies an algorithm to each character in the text producing an alternative version of the message, the ciphertext.  </p> <p>Encryption has been used since earliest times and one of these early methods is the Caesar Cipher.  It is a type of substitution cipher where each letter of the plaintext is replaced by another letter some number of positions further on (or back) in the alphabet.  If the shift value was 3 the letter 'a' would be replaced by 'd'.  It's a rudimentary encryption method and very easy to decrypt (though in Caesar's day it might have been effective as most of his enemies could not read).</p> <p>The Problem Write a program to encrypt a string. A simple \"Caesar shift\": each character in the plaintext is replaced by the one shift places from it in the alphabet eg if shift=3 then 'a' is replaced by 'd', 'b' by 'e', ..., 'x' by 'a', 'y' by 'b', 'z' by 'c'.</p> <p>Here is an incomplete Caesar Shift program.</p> <pre><code>using System;\nusing System.Text;\n\nnamespace CaesarCipher\n{\n    class CaesarCipher\n    {\n        static void Main(string[] args)\n        {\n            int shift;\n            char letter;\n            string plaintext;\n            string ciphertext = \"\";\n\n            Console.Clear();\n            // get the message\n            Console.Write(\"Enter your message to be encrypted: \");\n            plaintext = Console.ReadLine();               \n\n            Console.Write(\"Enter the shift value (key): \");\n            shift = Convert.ToInt32(Console.ReadLine());\n\n            // encrypt it\n            // outer loop: step through the plaintext, one character at a time\n            for (int i = 0; i &lt; plaintext.Length; i++) \n            {\n                letter = plaintext[i];       \n                for (int n = 0; n &lt; shift; n++) // inner loop\n                {\n                    letter++;    // move the ith letter on to the next in the ASCII table, \n                }\n                ciphertext += letter;  //This appends the shifted letter to the ciphertext\n            }\n\n            // output the encrypted version\n            Console.WriteLine(\"The encrypted message is \" + ciphertext);\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>The program does not work correctly.  This raises the question of how we can test a program.</p> <p>There are many different ways of testing an algorithm or program. Here are two of them for you to try on the Caesar Shift program:</p>"},{"location":"chapters/08_strings_encryption/04_programming_task/#dry-run-testing-also-called-hand-tracing","title":"Dry-run testing (also called hand-tracing)","text":"<p>We met trace tables in the previous chapter.  Tracing an algorithm using this method can help reveal problems with algorithms as in this case with the Caesar Shift program:</p> <p>Start with a table, with a column for each variable in the program, like this:</p> i N plaintext <p>The order of columns should match the order in which the variables are changed in the for loops: this makes the table easier to complete and understand.</p> <p>To carry out a test, choose an initial value for the plaintext: say \"cat\" and a value for shift, say \\(3\\). Now work systematically through the code, recording the values of each variable as they change</p> i N plaintext cat 1 1 dat 1 2 eat 1 3 fat 2 1 fbt 2 2 fct 2 3 fdt 3 1 fdu 3 2 fdv 3 3 fdw <p>The function has passed this test, though that doesn't mean that it will work for all values of plaintext.</p> <ol> <li>Dry run the code, using a start value for the plaintext of \"axe\".  Follow the code literally, do not make any assumptions</li> <li>What change is required to correct the errors you found (NB.  You will find an error!)</li> <li>Implement the change to the code</li> </ol>"},{"location":"chapters/08_strings_encryption/04_programming_task/#functional-testing","title":"Functional Testing","text":"<p>In contrast to dry-run testing, functional testing does require a computer, but not access to the code, only the final executable and the specification of what the program is supposed to do. It is often called black-box testing because the tester sees the program as a black box and cannot see the internal workings.</p> <p>The aim of functional testing is to determine whether the program does what it's supposed to, for as wide a range of inputs as possible. Notice the last two words in the previous sentence. For most programs it is impossible to test that they work correctly for all possible inputs, because there is an infinite number of them. So, the tester has to design tests for all reasonably likely inputs: this includes those resulting from user error and ignorance!</p> <p>Some general principles can be applied when designing data for functional tests:</p> <ul> <li>All users make mistakes</li> <li>Programs are most likely to fail with extreme data</li> <li>Programmers most often make mistakes at data boundaries</li> </ul> <p>Applying these principles to the Caesar Shift program:</p> <ul> <li>User errors: non-numeric data for the shift value: eg \"5q\", non-integer data: eg 3.5</li> <li>Extreme data: 0 or very large numbers for the shift value, an empty or very long string for plaintext</li> <li>Boundary data: For the shift value: 0 (the minimum acceptable value), -1 (only just unacceptable)</li> </ul> <p>In order to choose test data correctly it is essential that the tester has a precise specification for the program. That is, what data should it accept and, how should it respond to invalid data, and what are the expected outputs for a range of valid data?</p> <p>Functional, black-box testing can be recorded using a table like this:</p> Test # Test Data Explanation Expected result Actual result Pass/Fail 1 3, \"cat\" Valid data outputs \"fdw\" \"fdw\" Pass 2 q, \"cat\" Invalid data Fatal error 3 3, \"xyz\" Boundary data Outputs \"abc\" 4 <ol> <li>Add additional, appropriate tests to the above table for the Caesar Cipher program.</li> <li>Implement those changes in your code</li> </ol>"},{"location":"chapters/08_strings_encryption/05_questions/","title":"Questions","text":"<ol> <li> <p>A function <code>sqrt(x)</code> returns the square root of a positive integer <code>x</code>.  The following table shows three values used to test the functionality of this function.  State in each case the  different type of test data being used in each case.</p> <code>x</code> Type of test data 49 -8 1 </li> <li> <p>Write a regular expression to match with a given credit card number which starts with either the digits \\(34\\) or \\(37\\) and is followed by 13 more digits</p> </li> <li> <p>A regular expression for a valid identifier in a programming language can be described as <code>[A-Za-z][A-Za-z0-9_]*</code>.  State whether the following identifiers would be valid in this language</p> <p>a. Form1</p> <p>b. outer_loop</p> <p>c. _unknown</p> <p>d. anon_</p> </li> <li> <p>Here is a regular expression: <code>^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$</code> For what input is this designed to test?</p> </li> </ol> <p>// MORE TO ADD</p>"},{"location":"chapters/08_strings_encryption/05_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write a program that reads a string, reverses it and prints it to the screen. For example: \"hello\" -&gt; \"olleh\".</li> <li>Create a string checking program that will:</li> <li>Store the string \"I am going to check every word of this sentence for the keywords\"</li> <li>Split the string into an array of the individual words making up the sentence</li> <li>Check the array of words for instances of these keywords: check, word, sentence</li> <li>Output the sentence with the keywords highlighted in a different console colour (Use e.g. <code>Console.ForegroundColor = ConsoleColor.Red</code>)</li> <li>Write a program that reads a string from the console and prints in alphabetical order all letters from the input string and how many times each one of them occurs in the string.</li> <li>Write a program that extracts all the text without any tags and attribute values from an HTML document. (Hint: Scan the text letter by letter, keep in a variable whether there is an opening tag which has not been closed.  If you have a letter add it to the result only when the closing tag has been encountered.)</li> <li>The rules for identifiers in a programming language can be defined as a regular expression patter: <code>\"[A-Za-z][A-Za-z0-9_]*\"</code>.  State whether the following are valid or invalid according to this pattern:<ul> <li>Form1</li> <li>outer_loop</li> <li>_myAge</li> <li>myAge_</li> </ul> </li> </ol>"},{"location":"chapters/08_strings_encryption/06_data_compression/","title":"Extended Theory - Data Compression","text":"<p>Data compression is the process of reducing the size of our data by minimizing the number of bits needed to represent the same information. Data compression is widely used across various file types, including images, sound, video, and text. It serves as an excellent example of enhancing our understanding of string handling with C#.</p>"},{"location":"chapters/08_strings_encryption/06_data_compression/#types-of-data-compression","title":"Types of Data Compression","text":"<p>There are two main types of data compression:</p> <ul> <li> <p>Lossy Compression: In this method, some data is irreversibly removed from the original file during compression. As a result, the original file cannot be restored precisely when decompressed. Lossy compression is typically used for multimedia files where some loss of quality is acceptable, such as:</p> <ul> <li>Images: JPEG</li> <li>Audio: MP3</li> <li>Video: MP4</li> </ul> </li> <li> <p>Lossless Compression: This method allows the original file to be restored exactly as it was before compression. Lossless compression is essential for text and program data where data integrity is crucial. Common formats include:</p> <ul> <li>File Archives: ZIP</li> <li>Images: PNG</li> <li>There are two types:</li> </ul> </li> </ul>"},{"location":"chapters/08_strings_encryption/06_data_compression/#run-length-encoding","title":"Run length encoding","text":"<p>Run Length Encoding is a form of lossless compression where runs of repeated data are replaced by a single data value and a count of repetitions. It works best with simple graphics, icons, and line drawings. </p> <p>For example, if we have a string of 20 characters: <code>ABBBBCCCCCCCAABDDDDA</code>, this could be encoded as <code>1A4B7C2A1B4D1A</code>, which uses only 14 bytes instead of 20.</p> <p>To decompress the data, we read the string and interpret the digits as counts for the number of characters that follow.</p> <p>In C# the algorithm for compressing data this way would be as below.  It uses, by way of example, the <code>StringBuilder</code> class to build a string, from the <code>System.Collections</code> namespace, takes the string to compress as a parameter returning the compressed string for further processing:</p> <pre><code>static string Compress(string str)\n{\n    StringBuilder sb = new StringBuilder();\n    int count = 1;\n    char current = str[0];\n    for (int i = 1; i &lt; str.Length; i++)\n    {\n        if (current == str[i])\n        {\n            count++;\n        }\n        else\n        {\n            sb.AppendFormat(\"{0}{1}\",count,current);\n            count = 1;\n            current = str[i];\n        }\n    }\n    sb.AppendFormat(\"{0}{1}\",count,current);\n    return sb.ToString();\n}\n</code></pre> <p>To decompress the string, we reverse the process:</p> <pre><code>static string Decompress(string str)\n{\n    string decodedStr = string.Empty;\n    StringBuilder sb = new StringBuilder();\n    foreach(char ch in str)\n    {\n        if(char.IsDigit(ch))\n        {\n            decodedStr = decodedStr + ch;\n        }\n        else\n        {\n            if(decodedStr == String.Empty)\n            {\n                sb.Append(ch);\n            }\n            else\n            {\n                int count = int.Parse(decodedStr);\n                decodedStr = String.Empty;\n                for(int j = 0; j &lt; count; j++)\n                {\n                    sb.Append(ch);\n                }\n            }\n        }\n    }\n    return sb.ToString();\n}\n</code></pre> <p>RLE is particularly effective when the data contains many repeated runs of text. However, it can be inefficient for non-repetitive data. An improvement can be made by introducing a flag to indicate a repeated run. For example, A4B7C2AB4DA could use the asterisk as a flag, adding an extra byte for each run but potentially reducing the overall file size.</p>"},{"location":"chapters/08_strings_encryption/06_data_compression/#image-compression-using-rle","title":"Image Compression using RLE","text":"<p>RLE can also be applied to image files. For monochrome bitmaps, one bit can represent black or white, a byte for the pixel value, and another for the run length. The most significant bit (MSB) indicates color: a 0 for white and a 1 for black.</p> <p>For example, the string 00000111111111111100000000000000000000 would be encoded as 00000101 10001101 00010100, representing runs of white and black pixels.</p> <pre><code>static void Main(string[] args)\n{\n    // load a \"binary image\"\n    string[] data = File.ReadAllLines(\"CSharpASCII.txt\"); \n    string[] compressedText = new string[data.Length];\n    // print to check\n    PrintImage(imageText,'*');\n    // print some info about the original file \n    FileInfo info = new FileInfo(\"CSharpASCII.txt\");\n    Console.WriteLine($\"({info.Length} bytes)\");\n\n    // compress each line of the file\n    for (int i =0; i &lt; data.Length; i++)\n    {\n        string s = Compress(data[i]);\n        compressedText[i] = s;\n    }\n\n    // save compressed string to a file\n    string compressedFileName = \"CSharpCompressed.txt\";\n    if (!File.Exists(compressedFileName))\n    {\n        File.WriteAllLines(compressedFileName,compressedText);\n    }\n\n    // Read the compressed file\n    string[] compressedData = File.ReadAllLines(\"CSharpCompressed.txt\");\n    foreach(string s in compressedData)\n    {\n        PrintImageLine(Decompress(s),'+');\n    }\n\n    // get size of compressed file\n    info = new FileInfo(\"CSharpCompressed.txt\");\n    Console.WriteLine($\"({info.Length} bytes)\");\n}\n\nstatic string Compress(string str)\n{\n    int count = 1;\n    string compressed = \"\";\n    for(int i = 1; i &lt; str.Length; i++)\n    {\n        if (str[i] != str[i-1])\n        {\n            if (str[i-1] == '1')\n            {\n                count = (count | 128);      // MSB &lt;- 1\n            }\n            compressed += count + \",\";\n            count = 1;           \n        }\n        else\n        {\n            count++;\n        }\n        if (i == str.Length - 1)\n        {\n            compressed += count;\n        }\n    }\n    return compressed;\n}\n\nstatic string Decode(string str)\n{\n    StringBuilder sb = new StringBuilder();\n    string[] parts = str.Split(',');\n    char ch;\n    for(int i = 0; i &lt; parts.Length; i++)\n    {\n        int run = Convert.ToInt32(parts[i]);\n        if (run &gt;= 128)\n        {\n            run -= 128;\n            ch = '1';\n        }\n        else\n        {\n            ch = '0';\n        }\n        for (int j = 0; j &lt; run; j++)\n        {\n            sb.Append(ch);\n        }\n    }\n    return sb.ToString();\n}\n\nstatic void PrintImageLine(string line, char ch)\n{\n    for(int i = 0; i &lt; line.Length; i++)\n    {\n        if(line[i] == '0')\n        {\n            Console.Write(' ');\n        }\n        else\n        {\n            Console.Write(ch);\n        }\n    }\n    Console.WriteLine();   \n}\nstatic void PrintImage(string[] lines, char ch)\n{\n    foreach(string s in lines)\n    {\n        PrintImageLine(s,ch);\n    }\n}\n</code></pre> <p>A run of this code yields:</p> <pre><code>     *************\n    **************    **     **\n    ****              **     **\n    ****         ********************\n    ****         ********************\n    ****              **     **\n    ****         ********************\n    ****         ********************\n    ****              **     **\n    **************    **     **\n     *************\n(438 bytes)\n     +++++++++++++\n    ++++++++++++++    ++     ++\n    ++++              ++     ++\n    ++++         ++++++++++++++++++++\n    ++++         ++++++++++++++++++++\n    ++++              ++     ++\n    ++++         ++++++++++++++++++++\n    ++++         ++++++++++++++++++++\n    ++++              ++     ++\n    ++++++++++++++    ++     ++\n     +++++++++++++\n(188 bytes)\n</code></pre> <p>An alternative, would be to make the first digit in the compressed version to represent white pixels.  If the string was <code>11111000000000000011111111111111111111</code> this would become <code>0,5,13,20</code>.</p> <p>A similar approach could be taken for images with blocks of colour.  Each colour being represented by a byte, providing \\(256\\) different colours (that could be stored in a lookup file, or embedded in the image file itself).  The data being represented as a series of two byte pairs, the first holding the frequency of repetition, the second the colour.  For example, the following slice from an image file:</p> <p></p> <p>Assuming the colour blue used a code of 16, yellow of 12 and green of 3 this data can be compressed as:</p> <p><code>00001000 00010000 00001000 00001100 00001100 00010000 00000100 00000011</code></p> <p>If we need more colour, add in additional bytes for the colour codes.  \\(24\\)-bit colour uses a combination of the colours red, green and blue so a compressed image file could use \\(4\\) bytes to represent the colour of each pixel.  As with the previous examples the amount of saving achieved through compression is dependent on the frequency of repeated data.</p>"},{"location":"chapters/08_strings_encryption/06_data_compression/#alternative-compression-techniques","title":"Alternative Compression Techniques","text":"<ul> <li> <p>Dictionary Compression: A more complex algorithm involves building a dictionary of patterns for compression. One of the most well-known examples is the LZW (Lempel-Ziv-Welch) algorithm. This algorithm is used in formats like GIF. For further exploration, consider reading about it on Wikipedia.</p> </li> <li> <p>Comparison with Other Techniques: It\u2019s useful to compare RLE with other compression techniques like Huffman coding, which can be more efficient for certain types of data. Each method has its strengths and weaknesses, depending on the data being compressed.</p> </li> </ul>"},{"location":"chapters/09_methods/","title":"Methods","text":"<p>In this chapter</p> <ul> <li>Describe the terms subroutine, method, procedure and function</li> <li>Define and call your own subroutines</li> <li>Use parameters and arguments to pass values to a subroutine</li> <li>Use return statements to return values back to the function call</li> <li>Know the difference between passing by value and passing by reference</li> <li>Know the difference between local and global variables</li> <li>Identify advantages of using subroutines\u200b</li> </ul> <p>As the problems we want to solve get larger, and presumably harder, it makes sense to split the algorithm into smaller sub-problems.  When taken separately these smaller sub-problems are easier to solve and if we solve all the sub-problems we'd have solved the larger one!  This is a process of breaking a larger problem into a set of smaller sub-problems is known as decomposition.</p> <p>Each sub-problem can have its own section in our code taking responsibility for handling just that part of the problem.  These sections are known as subroutines, or methods in C#.  You'll also encounter the terms procedure and function.  These terms do have a specific meaning as we'll see in this chapter as a method can be either a procedure or a function:</p> <ul> <li>function: functions return a value to where the function was called</li> <li>procedure: does not return a value</li> </ul> <p>There are very good reasons to use methods in our program code:</p> <ul> <li>The code will be structured better</li> <li>The code will be more readable</li> <li>Duplication will be kept to a minimum (Don't Repeat Yourself (DRY) is a good maxim to adopt)</li> <li>Code can be re-used</li> </ul> <p>Of course, we have already used a method, all the code examples we've looked at thus far had a <code>Main()</code> method.  This is the entry point to our programs, it is the main method in the Program class.</p> <p>From the syllabus</p> <p>AQA: Subroutines (procedures/functions) (3.1.1.10/4.1.1.10)}</p> <ul> <li>Be familiar with subroutines and their uses. Know that a subroutine is a named 'out of line' block of code that may be executed (called) by simply writing its name in a program statement. Be able to explain the advantages of using subroutines in programs</li> </ul>"},{"location":"chapters/09_methods/01_declaring_calling_methods/","title":"Declaring, Implementing, and Invoking a Method","text":"<p>There are three main stages involved in working with methods in C#:</p> <ol> <li>Declaration</li> <li>Implementation</li> <li>Invocation</li> </ol> <p>Let's go through each stage step-by-step, using examples to illustrate the concepts.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#declaration-of-a-method","title":"Declaration of a Method","text":"<p>When you declare a method, you define its name, return type, and any parameters it takes. Let\u2019s revisit the <code>Caesar Cipher</code> program, starting with the automatically generated code in Visual Studio when you created the project:</p> <pre><code>namespace CaesarCipher\n{\n    class CaesarCipher\n    {\n        static void Main(string[] args)\n        {\n            // code body\n        }\n    }\n}\n</code></pre> <p>In this code, Visual Studio generated a class named <code>CaesarCipher</code> with a method named <code>Main()</code>. Notice the curly braces <code>{ ... }</code> enclosing the body of both the class and the method.</p> <ul> <li>The <code>class</code> keyword declares the <code>CaesarCipher</code> class.</li> <li>The <code>Main()</code> method is the entry point of the program and is declared inside the <code>CaesarCipher</code> class.</li> </ul> <p>We can add more methods to this class. For example:</p> <pre><code>namespace CaesarCipher\n{\n    class CaesarCipher\n    {\n        static void Main(string[] args)\n        {\n            // Calling other methods from Main()\n            DisplayGreeting();\n            EncryptMessage();\n        }\n\n        static void DisplayGreeting()\n        {\n            Console.WriteLine(\"Welcome to the Caesar Cipher Program!\");\n        }\n\n        static void EncryptMessage()\n        {\n            // code to encrypt a message\n        }\n    }\n}\n</code></pre> <p>Here, two additional methods (<code>DisplayGreeting()</code> and <code>EncryptMessage()</code>) have been declared within the <code>CaesarCipher</code> class.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#components-of-a-method-declaration","title":"Components of a Method Declaration","text":"<p>Every method declaration includes the following elements, in this order:</p> <ol> <li>Return Type: Specifies what kind of data the method will return. If the method doesn't return any value, the return type is <code>void</code>.</li> <li>Method Name: A descriptive name that starts with an uppercase letter and follows PascalCase naming convention.</li> <li>Parameter List: A comma-separated list of parameters enclosed in parentheses. Parameters provide input values to the method and can be empty.</li> </ol> <p>Let\u2019s analyze the <code>Main()</code> method again:</p> <pre><code>static void Main(string[] args)\n{\n    // method body\n}\n</code></pre> <ul> <li>Return Type: <code>void</code> means this method doesn't return any value, making it a procedure. If it returned a value, we would use types like <code>int</code> or <code>string</code>, making it a function.</li> <li>Method Name: <code>Main</code> is the default entry point of a C# program, and it must be named exactly <code>Main</code>.</li> <li>Parameter List: <code>(string[] args)</code> is an array of strings named <code>args</code>. This allows the program to accept command-line arguments when it starts.</li> </ul>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#access-modifiers","title":"Access Modifiers","text":"<p>Methods can also have access modifiers that control their visibility:</p> <ul> <li><code>public</code>: The method can be accessed from outside the class.</li> <li><code>private</code>: The method can only be accessed from within the same class (default if no access modifier is specified).</li> <li><code>protected</code>: The method can only be accessed within its class and by derived classes.</li> </ul> <p>The <code>static</code> keyword means the method belongs to the class itself, not to an instance of the class. This concept is fundamental in object-oriented programming (OOP) and can be explored further as you progress.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#method-naming-conventions","title":"Method Naming Conventions","text":"<ul> <li>Start with an uppercase letter.</li> <li>Use PascalCase (e.g., <code>CalculateSum()</code>).</li> <li>Prefer descriptive names, ideally a verb or verb-noun combination (e.g., <code>PrintReport()</code>).</li> <li>Avoid abbreviations and keep the name meaningful.</li> </ul>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#implementation-of-a-method","title":"Implementation of a Method","text":"<p>Implementing a method means writing the code that performs the task described by the method name. The code is placed between the curly braces following the method declaration. For example:</p> <pre><code>static void ExitConsole()\n{\n    Console.WriteLine(\"Press any key to continue...\");\n    Console.ReadKey();\n}\n</code></pre> <p>This method displays a message and waits for the user to press a key before exiting.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#local-variables","title":"Local Variables","text":"<p>Variables declared inside a method are called local variables because their scope is limited to the method. Once the method finishes executing, these variables are no longer accessible.</p> <pre><code>static int GetInt()\n{\n    Console.Write(\"Enter an integer: \");\n    int number = Convert.ToInt32(Console.ReadLine());\n    return number;\n}\n</code></pre> <p>In this example, <code>number</code> is a local variable. It only exists within the <code>GetInt()</code> method and is not accessible outside.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#scope-of-local-variables","title":"Scope of Local Variables","text":"<p>Local variables are only in scope within the code block they are declared in. For example, variables declared in a <code>for</code> loop only exist while the loop is executing.</p> <pre><code>for (int i = 0; i &lt; 5; i++)\n{\n    int temp = i * 2;  // temp is only accessible inside the loop\n}\n</code></pre>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#invoking-or-calling-a-method","title":"Invoking or Calling a Method","text":"<p>Invoking or calling a method is done by writing its name followed by parentheses. If the method requires parameters, you provide them inside the parentheses.</p> <pre><code>int x = GetInt();  // GetInt() is called and its return value is stored in x\nExitConsole();     // ExitConsole() is called but does not return a value\n</code></pre> <ul> <li><code>GetInt()</code> returns an integer, so its return value is stored in the variable <code>x</code>.</li> <li><code>ExitConsole()</code> doesn\u2019t return a value, so it can be called on its own line.</li> </ul>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#passing-parameters-to-methods","title":"Passing Parameters to Methods","text":"<p>Methods can take parameters that are passed in when the method is called. For example:</p> <pre><code>static void PrintMessage(string message)\n{\n    Console.WriteLine(message);\n}\n\nPrintMessage(\"Hello, world!\");\n</code></pre> <p>The <code>PrintMessage()</code> method accepts a string parameter <code>message</code> and prints it to the console.</p>"},{"location":"chapters/09_methods/01_declaring_calling_methods/#summary","title":"Summary","text":"<p>Understanding the stages of method declaration, implementation, and invocation is crucial for structuring programs effectively in C#. Practice by creating different methods, experimenting with return types and parameters, and calling them from the <code>Main()</code> method.</p>"},{"location":"chapters/09_methods/02_parameters/","title":"Parameters","text":"<p>Often, methods need additional information to perform their tasks. This information is passed to methods through parameters.</p> <p>Let's start with a simple example. Suppose we need a method that returns the square of the number 5:</p> <pre><code>static int SquareOfFive()\n{\n    return 5 * 5;\n}\n</code></pre> <p>This method will always return 25, the square of 5. But what if we want a method that can return the square of any number, not just 5? For this, we need to pass a value to the method for it to work on.</p>"},{"location":"chapters/09_methods/02_parameters/#generalizing-with-parameters","title":"Generalizing with Parameters","text":"<p>Here's a generalized version of the method:</p> <pre><code>static int SquareNum(int number)\n{\n    return number * number;\n}\n</code></pre> <p>Now, our method can calculate the square of any integer we provide as a parameter:</p> <pre><code>int x = SquareNum(5);  // x will be 25\nint y = 53;\nint z = SquareNum(y);  // z will be 2809\n</code></pre> <p>In the example above, the <code>SquareNum</code> method takes an integer parameter <code>number</code>. When we call the method, we pass an argument (like <code>5</code> or <code>y</code>) that gets copied into the <code>number</code> parameter within the method. The method then performs its calculation using this value.</p>"},{"location":"chapters/09_methods/02_parameters/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Parameter: A variable used in a method definition that receives a value when the method is called.</li> <li>Argument: The actual value passed to the method when it is invoked. For example, in <code>SquareNum(5)</code>, the number <code>5</code> is the argument, and <code>number</code> is the parameter in the method definition <code>SquareNum(int number)</code>.</li> </ul>"},{"location":"chapters/09_methods/02_parameters/#best-practices-for-parameters","title":"Best Practices for Parameters","text":"<p>When designing methods, it's essential to look for opportunities to generalize the method. This means making the method flexible enough to handle a range of inputs, not just specific values. This can make your code more reusable and efficient.</p> <p>Example:</p> <pre><code>int num = 7;\nint numSquared = SquareNum(num); // numSquared will be 49\n</code></pre> <p>Here, we pass the variable <code>num</code> as an argument to the <code>SquareNum</code> method. The method then calculates the square of <code>num</code> and returns the result.</p>"},{"location":"chapters/09_methods/02_parameters/#multiple-parameters","title":"Multiple Parameters","text":"<p>A method can take multiple parameters, separated by commas. However, be cautious not to overload the method with too many parameters, as it can make the method difficult to use and understand. If a method has too many parameters, consider splitting it into smaller, more manageable methods.</p> <p>Example of multiple parameters:</p> <pre><code>static void PrintSumAndProduct(int a, int b)\n{\n    Console.WriteLine($\"Sum: {a + b}\");\n    Console.WriteLine($\"Product: {a * b}\");\n}\n\nPrintSumAndProduct(3, 4);  // Output: Sum: 7, Product: 12\n</code></pre>"},{"location":"chapters/09_methods/02_parameters/#important-rules-for-parameters","title":"Important Rules for Parameters","text":"<ol> <li>Each parameter must have a type declared: You cannot omit the data type, even if multiple parameters are of the same type.</li> </ol> <pre><code>// Incorrect\nstatic void MyMethod(int x, y, z) { }\n\n// Correct\nstatic void MyMethod(int x, int y, int z) { }\n</code></pre> <ol> <li>Order matters: When calling a method with multiple parameters, the order of arguments must match the order of parameters in the method definition.</li> </ol> <pre><code>static void PrintCoordinates(int x, int y)\n{\n    Console.WriteLine($\"X: {x}, Y: {y}\");\n}\n\nPrintCoordinates(10, 20);  // Correct\n// PrintCoordinates(20, 10);  // Incorrect, unless this is intended\n</code></pre> <ol> <li>No parameters: If a method does not take any parameters, the parentheses <code>()</code> cannot be omitted.</li> </ol> <pre><code>static void PrintHello()\n{\n    Console.WriteLine(\"Hello!\");\n}\n\nPrintHello();  // Correct\n</code></pre>"},{"location":"chapters/09_methods/02_parameters/#default-parameters","title":"Default Parameters","text":"<p>In C#, you can provide a default value for a parameter. This means that if the caller does not provide an argument for that parameter, the method will use the default value instead.</p> <p>Example:</p> <pre><code>static int SquareNum(int n = 5)\n{\n    return n * n;\n}\n\nint result1 = SquareNum();  // result1 will be 25, as the default value of n is used\nint result2 = SquareNum(3); // result2 will be 9, as 3 is passed as an argument\n</code></pre> <p>Here, the <code>SquareNum</code> method has a default parameter value of <code>5</code>. If we call <code>SquareNum()</code> without providing an argument, it uses the default value <code>5</code>. If we provide an argument, like <code>3</code>, it uses that value instead.</p>"},{"location":"chapters/09_methods/02_parameters/#summary","title":"Summary","text":"<p>Understanding how to work with parameters is crucial for writing flexible and reusable methods. Always strive to design methods that can handle a variety of inputs, and be mindful of the rules and best practices around parameters and arguments. By doing so, you'll be able to create more robust and maintainable code.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/","title":"Passing by Value, Passing by Reference","text":"<p>You've likely encountered the terms value and reference before. These terms are significant when discussing parameters in methods as well. Let's explore the differences with some examples.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#passing-by-value","title":"Passing by Value","text":"<p>Consider the following code and try to predict what will be displayed on the screen:</p> <pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n        int value = 3;\n        Console.WriteLine($\"In Main(), value is equal to {value}\");\n        AddFive(value);\n        Console.WriteLine($\"Back in Main(), value is equal to {value}\");\n    }\n\n    static void AddFive(int x)\n    {\n        x = x + 5;\n        Console.WriteLine($\"In AddFive(), value is now {x}\");\n    }\n}\n</code></pre> <p>Expected Output:</p> <pre><code>In Main(), value is equal to 3\nIn AddFive(), value is now 8\nBack in Main(), value is equal to 3\n</code></pre> <p>Did you predict correctly?</p> <p>When the variable <code>value</code> is passed to the method <code>AddFive()</code>, only the value of <code>value</code> is copied to the parameter <code>x</code>. This means a new memory location is created for <code>x</code>, and the value <code>3</code> is stored there. Changes to <code>x</code> inside the <code>AddFive()</code> method do not affect the original <code>value</code> variable in <code>Main()</code>. This is known as passing by value.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Passing by Value: A copy of the variable's value is passed to the method. Any changes made to the parameter inside the method do not affect the original variable.</li> <li>Memory Allocation: A new block of memory is allocated for the parameter when a method is called. When the method ends, this memory is released.</li> </ul>"},{"location":"chapters/09_methods/03_value_reference_parameters/#passing-by-reference","title":"Passing by Reference","text":"<p>Now, consider this code:</p> <pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n        int[] myArray = { 2, 3, 4 };\n        for (int i = 0; i &lt; myArray.Length; i++)\n        {\n            Console.Write($\"{myArray[i]} \");\n        }\n        Console.WriteLine();\n\n        AddTen(myArray);\n\n        for (int i = 0; i &lt; myArray.Length; i++)\n        {\n            Console.Write($\"{myArray[i]} \");\n        }\n    }\n\n    static void AddTen(int[] x)\n    {\n        for (int i = 0; i &lt; x.Length; i++)\n        {\n            x[i] += 10;\n        }\n    }\n}\n</code></pre> <p>Expected Output:</p> <pre><code>2 3 4 \n12 13 14 \n</code></pre> <p>An array is a reference type. When <code>myArray</code> is passed to the <code>AddTen()</code> method, it passes a reference (memory address) to the array, not a copy of its values. Therefore, changes made to <code>x</code> inside <code>AddTen()</code> affect the original array <code>myArray</code> in <code>Main()</code>. This is called passing by reference.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#key-concepts_1","title":"Key Concepts:","text":"<ul> <li>Passing by Reference: A reference (memory address) to the original variable is passed to the method. Changes made to the parameter inside the method affect the original variable.</li> <li>Reference Types: Arrays, objects, and other complex types in C# are reference types. When passed as arguments, the method can modify the original data.</li> </ul>"},{"location":"chapters/09_methods/03_value_reference_parameters/#passing-value-types-by-reference","title":"Passing Value Types by Reference","text":"<p>It is also possible to pass a value type (like <code>int</code>) by reference using the <code>ref</code> keyword. This allows the method to modify the original value.</p> <p>Example:</p> <pre><code>class Program\n{\n    static void Main(string[] args)\n    {\n        int value = 3;\n        Console.WriteLine($\"In Main(), value is initially {value}\");\n        AddFive(ref value);\n        Console.WriteLine($\"Back in Main(), value is now {value}\");\n    }\n\n    static void AddFive(ref int x)\n    {\n        x = x + 5;\n        Console.WriteLine($\"In AddFive(), value is now {x}\");\n    }\n}\n</code></pre> <p>Expected Output:</p> <pre><code>In Main(), value is initially 3\nIn AddFive(), value is now 8\nBack in Main(), value is now 8\n</code></pre> <p>Using <code>ref</code> allows the method to modify the original <code>value</code> variable. Both the method definition and the method call must include the <code>ref</code> keyword.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#summary","title":"Summary","text":"<ul> <li>Passing by Value: Copies the value to the method. Changes do not affect the original variable.</li> <li>Passing by Reference: Passes a reference to the method. Changes affect the original variable.</li> <li><code>ref</code> Keyword: Allows value types to be passed by reference, enabling the method to modify the original variable.</li> </ul>"},{"location":"chapters/09_methods/03_value_reference_parameters/#local-and-global-variables","title":"Local and Global Variables","text":"<p>You may remember from earlier chapters the difference between local and global variables. These terms describe the scope of a variable.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#local-variables","title":"Local Variables","text":"<p>A local variable is declared and used within a specific block of code, such as a method, loop, or conditional statement. It is only accessible within that block.</p> <p>Example:</p> <pre><code>static void Main(string[] args)\n{\n    int total;\n    IncreaseTotal();\n    Console.WriteLine(total);  // This will cause a compilation error\n}\n\nstatic void IncreaseTotal()\n{\n    int total = 10;\n}\n</code></pre> <p>In this example, the <code>total</code> variable in <code>Main()</code> and the <code>total</code> variable in <code>IncreaseTotal()</code> are different variables, each with its own memory. Modifying one does not affect the other.</p> <p>Common Mistake:</p> <pre><code>static void MyMethod()\n{\n    for (int i = 0; i &lt; 10; i++)\n    {\n        Console.WriteLine(i);\n    }\n    Console.WriteLine(i);  // Error: 'i' does not exist outside the loop\n}\n</code></pre> <p>Here, the variable <code>i</code> is local to the <code>for</code> loop and cannot be accessed outside of it. This will result in a compilation error.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#global-variables","title":"Global Variables","text":"<p>A global variable is accessible from anywhere in the program. In C#, global variables are typically declared as <code>static</code> fields of a class. They are rarely used due to potential issues such as unintended side effects and difficulty in debugging.</p> <p>Example:</p> <pre><code>class Program\n{\n    static int total = 0;\n\n    static void Main(string[] args)\n    {\n        IncreaseTotal();\n        Console.WriteLine(total);  // This will print 10\n    }\n\n    static void IncreaseTotal()\n    {\n        total += 10;\n    }\n}\n</code></pre> <p>In this example, the variable <code>total</code> is accessible from both <code>Main()</code> and <code>IncreaseTotal()</code> because it is a static field of the <code>Program</code> class.</p>"},{"location":"chapters/09_methods/03_value_reference_parameters/#advantages-of-local-variables","title":"Advantages of Local Variables","text":"<ul> <li>Isolation: Local variables are confined to their scope, preventing unexpected changes from other parts of the program.</li> <li>Memory Management: Local variables are destroyed once the block of code they belong to is finished, freeing up memory.</li> <li>Reusability: Functions and methods using local variables are easier to test and reuse in different contexts without side effects.</li> </ul>"},{"location":"chapters/09_methods/03_value_reference_parameters/#best-practices","title":"Best Practices","text":"<ul> <li>Use local variables whenever possible to limit the scope of data and reduce the risk of accidental changes.</li> <li>Avoid using global variables unless absolutely necessary, and prefer passing data explicitly through method parameters.</li> </ul>"},{"location":"chapters/09_methods/04_overloading_methods/","title":"Overloading Methods","text":"<p>In C#, it is possible to have multiple methods with the same name in the same class, as long as they differ in their parameters. This concept is known as method overloading.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#what-is-method-overloading","title":"What is Method Overloading?","text":"<p>Method overloading allows you to define multiple methods with the same name but different parameter lists. The methods must be distinguishable by: - The number of parameters, or - The data types of the parameters.</p> <p>This enables the use of a single method name for similar actions, improving readability and reducing the need for overly descriptive method names.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#example-overloading-by-data-type","title":"Example: Overloading by Data Type","text":"<pre><code>static int AddThree(int a, int b, int c)\n{\n    return a + b + c;\n}\n\nstatic double AddThree(double a, double b, double c)\n{\n    return a + b + c;\n}\n</code></pre> <p>Here, two <code>AddThree()</code> methods are defined: - The first takes three <code>int</code> parameters. - The second takes three <code>double</code> parameters.</p> <p>When you call <code>AddThree()</code> with three integers, the first method is executed. When you call it with three doubles, the second method is executed.</p> <p>Advantages: - Simplifies method names: Instead of <code>AddThreeIntegers()</code> and <code>AddThreeDoubles()</code>, you use just <code>AddThree()</code>. - Enhances code clarity by grouping similar operations under a single method name.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#example-overloading-by-number-of-parameters","title":"Example: Overloading by Number of Parameters","text":"<pre><code>static int Add(int a, int b)\n{\n    return a + b;\n}\n\nstatic int Add(int a, int b, int c)\n{\n    return a + b + c;\n}\n</code></pre> <p>In this example, both methods are named <code>Add()</code>, but the first one takes two parameters, while the second takes three. The correct method is chosen based on the number of arguments passed.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#important-note","title":"Important Note","text":"<p>It is not permissible to overload methods by changing only the return type. For example:</p> <pre><code>// This is NOT allowed\nstatic int Add(int a, int b) { return a + b; }\nstatic double Add(int a, int b) { return a + b; }\n</code></pre> <p>The above code will result in a compilation error because the methods have the same name, parameters, and the compiler cannot distinguish between them based on the return type alone.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#example-bubble-sort-revisited","title":"Example: Bubble Sort Revisited","text":"<p>Let's revisit the bubble sort algorithm we discussed earlier. Here is the original code:</p> <pre><code>using System;\n\nnamespace BubbleSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] myArray = { 23, 16, 9, 86, 54, 3 };\n            int temp;\n\n            Console.Clear();\n            Console.WriteLine(\"Initial contents of the array:\");\n            foreach (int i in myArray)\n            {\n                Console.Write($\"{i} \");\n            }\n\n            int current = myArray.Length - 1;\n\n            for (int i = 0; i &lt; myArray.Length - 1; i++)\n            {\n                for (int j = 0; j &lt; myArray.Length - 1; j++)\n                {\n                    if (myArray[j] &gt; myArray[j + 1])\n                    {\n                        temp = myArray[j];\n                        myArray[j] = myArray[j + 1];\n                        myArray[j + 1] = temp;\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nSorted array:\");\n            foreach (int i in myArray)\n            {\n                Console.Write($\"{i} \");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/09_methods/04_overloading_methods/#identifying-repeated-code","title":"Identifying Repeated Code","text":"<ol> <li>Printing the Array: The array is printed twice, once before and once after sorting. This is a good candidate for a separate method.</li> <li>Swapping Elements: The swap operation is performed within the sorting loop. Extracting this into a separate method makes the sorting logic clearer.</li> </ol>"},{"location":"chapters/09_methods/04_overloading_methods/#refactoring-using-methods","title":"Refactoring Using Methods","text":""},{"location":"chapters/09_methods/04_overloading_methods/#step-1-create-a-method-for-printing-the-array","title":"Step 1: Create a Method for Printing the Array","text":"<pre><code>static void PrintArray(int[] array)\n{\n    foreach (int i in array)\n    {\n        Console.Write($\"{i} \");\n    }\n    Console.WriteLine();\n}\n</code></pre> <p>Call this method instead of repeating the print logic:</p> <pre><code>Console.WriteLine(\"Initial contents of the array:\");\nPrintArray(myArray);\n\n// ... sorting logic ...\n\nConsole.WriteLine(\"Sorted array:\");\nPrintArray(myArray);\n</code></pre>"},{"location":"chapters/09_methods/04_overloading_methods/#step-2-create-a-method-for-swapping-elements","title":"Step 2: Create a Method for Swapping Elements","text":"<pre><code>static void Swap(ref int a, ref int b)\n{\n    int temp = a;\n    a = b;\n    b = temp;\n}\n</code></pre> <p>Use this method in the sorting logic:</p> <pre><code>for (int i = 0; i &lt; myArray.Length - 1; i++)\n{\n    for (int j = 0; j &lt; myArray.Length - 1; j++)\n    {\n        if (myArray[j] &gt; myArray[j + 1])\n        {\n            Swap(ref myArray[j], ref myArray[j + 1]);\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/09_methods/04_overloading_methods/#step-3-decompose-into-more-methods","title":"Step 3: Decompose into More Methods","text":"<p>You can further decompose the code into separate methods like <code>InitializeArray()</code> and <code>SortArray()</code> for better organization.</p>"},{"location":"chapters/09_methods/04_overloading_methods/#final-version","title":"Final Version","text":"<pre><code>using System;\n\nnamespace BubbleSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] myArray = InitializeArray();\n            Console.WriteLine(\"Initial contents of the array:\");\n            PrintArray(myArray);\n\n            SortArray(myArray);\n\n            Console.WriteLine(\"Sorted array:\");\n            PrintArray(myArray);\n        }\n\n        static int[] InitializeArray()\n        {\n            return new int[] { 23, 16, 9, 86, 54, 3 };\n        }\n\n        static void PrintArray(int[] array)\n        {\n            foreach (int i in array)\n            {\n                Console.Write($\"{i} \");\n            }\n            Console.WriteLine();\n        }\n\n        static void Swap(ref int a, ref int b)\n        {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        static void SortArray(int[] array)\n        {\n            for (int i = 0; i &lt; array.Length - 1; i++)\n            {\n                for (int j = 0; j &lt; array.Length - 1; j++)\n                {\n                    if (array[j] &gt; array[j + 1])\n                    {\n                        Swap(ref array[j], ref array[j + 1]);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/09_methods/04_overloading_methods/#advantages-of-decomposition","title":"Advantages of Decomposition","text":"<ul> <li>Code Reusability: Methods like <code>PrintArray()</code> and <code>Swap()</code> can be reused in other sorting algorithms.</li> <li>Simpler Maintenance: If a bug is found in the swap logic, it can be fixed in one place.</li> <li>Improved Readability: Breaking down the code into smaller methods makes it easier to understand.</li> </ul>"},{"location":"chapters/09_methods/04_overloading_methods/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Method overloading enhances readability and reduces the need for verbose method names.</li> <li>Decomposing complex problems into smaller methods improves code structure and maintainability.</li> <li>Avoid code duplication by creating reusable methods for repeated tasks.</li> </ul>"},{"location":"chapters/09_methods/05_hierarchy_charts/","title":"Hierarchy Charts (structure diagrams)","text":"<p>From the syllabus</p> <p>AQA: Procedural-oriented programming (3.1.1.10/4.1.2.2) - Be able to construct and use hierarchy charts when designing programs.     - Hierarchy charts are created by the programmer to help document a program. They convey the big picture of the modules (or functions) used in a program.</p> <p>It's often helpful to visualise the structure of a program.  One of the tools we can use is the Hierarchy chart (sometimes called structure diagram).  The diagram shows the relationship between the methods, ignoring any of the logic within those methods, but does show where methods are dependent on other methods.  Hierarchy charts are an important tool in documenting a solution.</p> <p>For example, the bubble sort program above can be visualised in the following hierarchy chart:</p> <p></p>"},{"location":"chapters/09_methods/06_advantages/","title":"Advantages of Using Methods","text":"<p>Using methods (also known as subroutines, procedures, or functions) in programming has several advantages. These advantages contribute to better code organization, maintainability, and reusability. Let\u2019s explore these benefits in more detail:</p> <p>1. Improved Code Readability and Structure</p> <ul> <li>Methods help break down complex programs into smaller, more manageable sections. This makes the code easier to read, understand, and maintain.</li> <li>Instead of having a long sequence of code, you can divide the program into logical units, each with a clear purpose.</li> </ul> <p>2. Code Reusability</p> <ul> <li>Methods can be called multiple times within a program, avoiding the need to duplicate the same code. This not only saves time but also reduces the risk of errors.</li> <li>If the same set of instructions is required in different parts of the program, you can use a method instead of rewriting the code.</li> </ul> <p>3. Easier Testing and Debugging</p> <ul> <li>Each method can be tested independently to ensure it works correctly, simplifying the debugging process.</li> <li>Testing individual methods helps identify bugs more easily, rather than sifting through a large block of code to find an error.</li> </ul> <p>4. Simplified Maintenance and Updates</p> <ul> <li>If a change is needed, you only have to modify the code inside the method, not in every place the logic is used. This reduces the chances of introducing new bugs.</li> <li>For example, if a method that calculates a discount rate needs to be updated, you only need to change the method\u2019s code, and the changes will apply wherever the method is called.</li> </ul> <p>5. Encapsulation and Abstraction</p> <ul> <li>Methods allow you to encapsulate functionality, hiding the implementation details from the rest of the program. This abstraction makes it easier to work with complex systems.</li> <li>By using methods, you can focus on the what (the method's purpose) without worrying about the how (the internal workings).</li> </ul> <p>6. Parameterization and Flexibility</p> <ul> <li>Methods can accept parameters, allowing you to pass in different data each time the method is called. This makes your code more flexible and reusable.</li> <li>For example, a method to calculate the area of a rectangle can accept <code>length</code> and <code>width</code> as parameters, so it can be used to calculate the area of any rectangle.</li> </ul> <p>7. Collaboration and Modular Development</p> <ul> <li>Large programs can be divided into separate methods or modules, which can be developed by different team members independently.</li> <li>Each programmer can work on different methods, and these can be integrated later, facilitating collaboration in software development projects.</li> </ul> <p>8. Use in Libraries</p> <ul> <li>Methods can be stored in libraries and reused across multiple programs. This means you can build a collection of useful methods and functions that you can draw on whenever needed.</li> </ul>"},{"location":"chapters/09_methods/06_advantages/#best-practices-when-using-methods","title":"Best Practices When Using Methods","text":"<p>To make the most out of methods, follow these best practices:</p> <p>1. Solve One Distinct Task</p> <ul> <li>Each method should perform one specific, well-defined task. Avoid combining multiple functionalities into a single method. For example, a method called <code>CalculateSquareRoot()</code> should only compute the square root and not handle user input or display results.</li> </ul> <p>2. Use Descriptive Names</p> <ul> <li>Method names should clearly describe what the method does. This makes your code self-documenting. For instance, use <code>CalculateAverage()</code> instead of vague names like <code>DoTask()</code>.</li> </ul> <p>3. Start Method Names with a Capital Letter</p> <ul> <li>In C#, it is standard practice to start method names with a capital letter (PascalCase). For example, <code>ComputeTotal()</code> is preferred over <code>computeTotal()</code>.</li> </ul> <p>4. Action-Oriented Names</p> <ul> <li>Method names should typically represent actions, such as <code>PrintReport()</code>, <code>GetUserData()</code>, or <code>UpdateRecord()</code>. This makes it clear what the method does just by reading its name.</li> </ul> <p>5. Minimize Dependencies</p> <ul> <li>A method should be as independent as possible from other methods or classes. It should not rely on the internal state of other parts of the program unless necessary. This makes methods easier to test and reuse.</li> </ul> <p>6. Avoid Side Effects</p> <ul> <li>A method should not change the state of the program unexpectedly. For example, a method that calculates a value should not also print it to the screen or modify a global variable.</li> </ul> <p>7. Keep Methods Short</p> <ul> <li>A method should ideally fit within a \"screenful\" of code. If it becomes too long, consider breaking it into smaller methods. This improves readability and maintainability.</li> </ul> <p>8. Use Parameters and Return Values Appropriately</p> <ul> <li>Use parameters to pass data into the method and return values to get data out of it. Avoid using global variables inside methods, as this can lead to unintended side effects.</li> </ul>"},{"location":"chapters/09_methods/06_advantages/#example-refactoring-a-program-with-methods","title":"Example: Refactoring a Program with Methods","text":"<p>Here\u2019s an example of a simple program that benefits from using methods:</p> <p>Original Program Without Methods:</p> <pre><code>static void Main(string[] args)\n{\n    int[] numbers = { 1, 2, 3, 4, 5 };\n    int sum = 0;\n    for (int i = 0; i &lt; numbers.Length; i++)\n    {\n        sum += numbers[i];\n    }\n    double average = sum / numbers.Length;\n    Console.WriteLine($\"The sum is {sum} and the average is {average}\");\n}\n</code></pre> <p>Refactored Program with Methods:</p> <pre><code>static void Main(string[] args)\n{\n    int[] numbers = { 1, 2, 3, 4, 5 };\n    int sum = CalculateSum(numbers);\n    double average = CalculateAverage(sum, numbers.Length);\n    DisplayResults(sum, average);\n}\n\nstatic int CalculateSum(int[] numbers)\n{\n    int sum = 0;\n    foreach (int number in numbers)\n    {\n        sum += number;\n    }\n    return sum;\n}\n\nstatic double CalculateAverage(int sum, int count)\n{\n    return (double)sum / count;\n}\n\nstatic void DisplayResults(int sum, double average)\n{\n    Console.WriteLine($\"The sum is {sum} and the average is {average}\");\n}\n</code></pre> <p>Benefits of Using Methods:</p> <ul> <li>Each method (<code>CalculateSum()</code>, <code>CalculateAverage()</code>, and <code>DisplayResults()</code>) handles a specific task, making the code more modular.</li> <li>The <code>Main()</code> method becomes simpler and focuses on orchestrating the method calls rather than handling all logic directly.</li> <li>The methods can now be reused and tested independently.</li> </ul> <p>By adhering to these best practices and leveraging the advantages of methods, you can write more efficient, maintainable, and understandable code in your A Level Computer Science projects.</p>"},{"location":"chapters/09_methods/07_programming_task/","title":"Programming Task - Calculator","text":"<p>Write a calculator program that inputs two numbers, asks the user what calculation they want to perform and then outputs the result.  Each calculation should be performed and output from inside it's own procedure.  The code below should help you get started.</p> <ul> <li>Modify the program so it can also perform subtraction, multiplication, and division, use either procedures or functions for each method</li> <li>Add a loop so that the menu repeats until the user wants to quit</li> <li>Challenge 1: Include procedures for floor (i.e. integer) division and modulus</li> <li>Challenge 2: Use exception handling with all of the user inputs (or write methods to <code>GetInt()</code> and <code>GetFloat()</code> with validation)</li> <li>Modify the methods, converting them from procedures into functions</li> </ul> <pre><code>using System;\n\nnamespace Calculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Welcome to the calculator program\\n\");\n\n            // Ask the user for two number and store them as floats\n            Console.Write(\"Enter the first number: \");\n            float number1 = float.Parse(Console.ReadLine());\n\n            Console.Write(\"Enter the second number: \");\n            float number2 = float.Parse(Console.ReadLine());\n\n            // Output the menu options\n            Console.WriteLine(\"\\nEnter the menu number of the calculation to perform: \");\n            Console.WriteLine(\"1 - Addition\");\n            Console.WriteLine(\"2 - Subtraction\");\n            Console.WriteLine(\"3 - Multiplication\");\n            Console.WriteLine(\"4 - Division\\n\");\n\n            // Ask for the menu option\n            string menuOption = Console.ReadLine();\n\n            // Perform a subroutine based on the menu option\n            if (menuOption == \"1\")\n            {\n                Addition(number1, number2);\n            }\n            else\n            {\n                Console.WriteLine(\"Please choose a valid option\");\n            }\n        }\n\n        // The addition procedure has two floats as parameters, adds them together and outputs the result\n        static void Addition(float num1, float num2)\n        {\n            Console.WriteLine(\"\\nThe result is: \" + (num1 + num2));\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/09_methods/07_programming_task/#secret-word","title":"Secret Word","text":"<p>[From ZigZag Education C# Console Programming]</p> <p>Create a new project called SecretWord and copy the code from below into your project. Adapt the program so that there are separate procedures and functions for:</p> <ul> <li>Outputting the menu (a procedure)</li> <li>Guessing the secret word (a procedure with a parameter)</li> <li>Changing the secret word (a function)</li> <li>Quitting the program (a procedure)</li> </ul> <pre><code>using System;\n\nnamespace SecretWord\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Initialise the variables and secret word\n            string menuOption;\n            string guess;\n            string secretWord = \"Computer\";\n\n            do\n            {\n                // Output the menu\n                Console.WriteLine(\"\\nWelcome to the guessing program menu - choose your option:\");\n                Console.WriteLine(\"1 - Change the secret word\");\n                Console.WriteLine(\"2 - Make a guess\");\n                Console.WriteLine(\"3 - Quit\");\n\n                // Ask the user for the menu number\n                menuOption = Console.ReadLine();\n\n                // Choose a task depending on the menu option \n                switch (menuOption)\n                {\n                    case \"1\":\n                        // Change the secret word\n                        Console.WriteLine(\"What is the new secret word?\");\n                        secretWord = Console.ReadLine();\n                        break;\n                    case \"2\":\n                        // Guess the secret word\n                        Console.WriteLine(\"Guess the secret word:\");\n                        guess = Console.ReadLine();\n\n                        // Check whether the word entered was the secret word\n                        if (guess == secretWord)\n                        {\n                            Console.WriteLine(\"Well done - you have guessed the secret word!\");\n                        }\n                        else\n                        {\n                            Console.WriteLine(\"Sorry, that is not the secret word\");\n                        }\n                        break;\n                    case \"3\":\n                        // Quit the program\n                        Console.WriteLine(\"Thank you for playing secret word\");\n                        Environment.Exit(0);\n                        break;\n                    default:\n                        Console.WriteLine(\"Invalid menu choice\");\n                        break;\n                }\n            }\n            while (menuOption == \"1\" || menuOption == \"2\");\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/09_methods/08_questions/","title":"Questions","text":"<ol> <li> <p>Write method signatures for:</p> <ul> <li>a method that takes one integer parameter</li> <li>a method that returns a Boolean value</li> <li>a method that takes one double and one string parameter and returns an integer value</li> <li>a method that takes one integer reference parameter and returns a boolean value</li> <li>Draw a hierarchy chart for the completed calculator program</li> <li>What is meant by the term structured programming?</li> <li>Explain how the two methods below can each use a variable named <code>x</code>.</li> </ul> <pre><code>public void FirstMethod(int number)\n{\n    int x = number;\n}\npublic void SecondMethod()\n{\n    int x = 0;\n}\n</code></pre> </li> <li> <p>What might be considered wrong with the following method?</p> <pre><code>public void calcEverything(ref int a, ref int b, ref int c)\n{\n    int total, avg;\n    total = a + b + c;\n    Console.WriteLine(\"the total of inputs = \" + total);\n    avg = total / 3;\n    Console.WriteLine(\"the average of inputs = \" + avg);\n}\n</code></pre> </li> </ol>"},{"location":"chapters/09_methods/08_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Create a method GetMax() with two integer (int) parameters, that returns the larger of the two numbers. Write a program that reads three numbers from the console and prints the biggest of them. Use the GetMax() method you just created.</li> <li>Write a method that finds how many times a certain number can be found in a given array. Write a program to test that the method works correctly.</li> <li>Write a program that calculates and prints the n! for any n in the range \\(1\\) .. \\(100\\).</li> <li> <p>Write a program to convert a \\(8\\)-bit binary number into its denary equivalent.  Decompose the program into several methods e.g. InputBinaryValue(), ConvertBit(), OutputResult().  Use the following pseudocode:</p> <pre><code>Result = 0\nColumnValue = 128\nPRINT \"Enter a binary number to convert: \"\nBinaryString &lt;- INPUT\nFOR i = 0 TO (Length of BinaryString - 1)\n    BitValue = 0\n    IF (BinaryString[i] is a \"1\") THEN\n        bitValue = bitValue + ColumnValue\n    ELSE\n        BitValue = bitValue\n    END IF\n    ColumnValue = ColumnValue /2\n    Result = Result + bitValue\nEND FOR\nPRINT Result\n</code></pre> <ul> <li>Test your program with the following values:  (a) 10000000; (b) 11111111; (c) 10010011</li> <li>Adapt the program so it can work with any length of binary number</li> <li> <p>Write a program that solves the following tasks:</p> </li> <li> <p>Put the digits from an integer number into a reversed order.</p> </li> <li>Calculate the average of given sequence of numbers.</li> <li>Solve the linear equation a * x + b = 0.</li> </ul> <p>Create appropriate methods for each of the above tasks. Make the program show a text menu to the user. By choosing an option of that menu, the user will be able to choose which task to be invoked</p> </li> </ol>"},{"location":"chapters/09_methods/09_call_stack/","title":"Extended Theory - The Call Stack","text":"<p>The concept of the stored program, introduced by John von Neumann in the 1940s, proposed that program instructions and data be stored together in a memory device. This idea revolutionized computing, enabling machines to switch between multiple programs stored in memory, rather than being limited to executing a single program at a time.</p> <p>A von Neumann machine consists of three key components:</p> <ul> <li>Central Processing Unit (CPU): The brain of the computer, responsible for executing instructions.</li> <li>Memory: Stores both data and instructions.</li> <li>Input/Output Devices (I/O): Facilitate interaction between the computer and the outside world.</li> </ul>"},{"location":"chapters/09_methods/09_call_stack/#cpu-and-its-components","title":"CPU and Its Components","text":"<p>The CPU, at the heart of a computer, contains three main components:</p> <ul> <li>Arithmetic Logic Unit (ALU): Performs mathematical and logical operations on data.</li> <li>Control Unit (CU): Manages the execution of instructions, coordinating the CPU's operations.</li> <li>Registers: Small, fast storage locations within the CPU used to hold temporary data and instructions.</li> </ul>"},{"location":"chapters/09_methods/09_call_stack/#memory-hierarchy","title":"Memory Hierarchy","text":"<p>Memory in a computer is organized hierarchically to optimize performance:</p> <ol> <li>Secondary Storage: Includes hard drives and SSDs, used for long-term data storage.</li> <li>Primary Memory (RAM): Used to store data and instructions that the CPU needs while executing programs.</li> <li>Cache Memory: A small, fast type of memory located close to the CPU, used to store frequently accessed data.</li> <li>Registers: The fastest type of memory, used for immediate data storage and manipulation.</li> </ol> <p>The higher up the hierarchy, the faster the memory access times for the CPU.</p>"},{"location":"chapters/09_methods/09_call_stack/#memory-addressing","title":"Memory Addressing","text":"<p>All computer memory is divided into locations, each identified by a unique number called an address. The basic storage unit is a byte (\\(1\\) byte = \\(8\\) bits), but modern CPUs often read and write data in word-sized chunks, typically \\(32\\)-bit (\\(4\\) bytes) or \\(64\\)-bit (\\(8\\) bytes). Even though data may be read or written in word-sized chunks, the addresses are still byte-referenced.</p> <p>For example, an <code>int</code> data type in C# is \\(4\\) bytes, meaning the value stored will occupy \\(4\\) consecutive memory locations.</p>"},{"location":"chapters/09_methods/09_call_stack/#logical-vs-physical-memory","title":"Logical vs Physical Memory","text":"<p>When a program runs, it is allocated memory, now referred to as a process. To the program, memory appears as a contiguous block of addresses, known as logical memory. However, the actual physical locations in RAM may be scattered. The operating system handles the mapping between logical and physical addresses, a process known as memory management.</p>"},{"location":"chapters/09_methods/09_call_stack/#memory-layout-of-an-executing-program","title":"Memory Layout of an Executing Program","text":"<p>The memory allocated to a running program typically looks like this:</p> Allocation of memory to a program <ol> <li>Code Segment: Contains the compiled machine code instructions of the program.</li> <li>Data Segment: Stores global and static variables.</li> <li>Heap: Allocates memory for dynamic data structures such as objects or arrays created with the <code>new</code> keyword. The heap grows upwards in memory.</li> <li>Stack: Manages function calls and local variables. It grows downwards in memory.</li> </ol> <p>If the heap and stack collide (e.g., due to excessive dynamic memory allocation or deep recursion), a stack overflow or out-of-memory error can occur.</p>"},{"location":"chapters/09_methods/09_call_stack/#understanding-the-stack","title":"Understanding the Stack","text":"<p>The stack is a crucial part of memory management for function calls. It operates on a last-in, first-out (LIFO) principle, much like a stack of books. The stack is used to:</p> <ul> <li>Store function call information such as parameters, return addresses, and local variables.</li> <li>Manage the sequence of function calls and returns.</li> </ul> <p>In programming terms:</p> <ul> <li>Push: Add an item to the top of the stack.</li> <li>Pop: Remove an item from the top of the stack.</li> </ul>"},{"location":"chapters/09_methods/09_call_stack/#calling-a-method","title":"Calling a Method","text":"<p>Consider the following C# example where the <code>Add()</code> method is called from the <code>main()</code> program:</p> <pre><code>static void Main(string[] args)\n{\n    int x = 3;\n    int y = 4;\n    Console.WriteLine(\"Simple adding method\");\n    int sum = Add(x, y);\n    Console.WriteLine($\"The sum is {sum}\");\n}\n\nstatic int Add(int a, int b)\n{\n    int sum = a + b;\n    return sum;\n}\n</code></pre> <p>Here, <code>Main()</code> is the caller, and <code>Add()</code> is the callee. For this call to execute correctly, several things must happen:</p> <ol> <li>Passing Parameters (<code>x</code> and <code>y</code>): </li> <li> <p>The values of <code>x</code> and <code>y</code> are pushed onto the stack before the method call. Parameters are typically pushed in reverse order (last parameter first).</p> </li> <li> <p>Saving the Return Address: </p> </li> <li> <p>The address of the next instruction to be executed after the <code>Add()</code> method (the instruction <code>Console.WriteLine($\"The sum is {sum}\");</code>) is pushed onto the stack.</p> </li> <li> <p>Creating a Stack Frame:</p> </li> <li> <p>A new stack frame is created for the <code>Add()</code> method, containing space for its parameters, local variables, and the return address.</p> </li> <li> <p>Returning from the Method:</p> </li> <li>When <code>Add()</code> finishes executing, it pops the return address from the stack and places the return value in a predefined location (typically a register). Control then returns to the instruction following the method call.</li> </ol>"},{"location":"chapters/09_methods/09_call_stack/#the-stack-in-detail","title":"The Stack in Detail","text":"Stack operations <ol> <li>Push Return Address: The address to which control should return after the method completes is pushed onto the stack.</li> <li>Push Parameters: Parameters for the method are pushed onto the stack.</li> <li>Execute Method: The method uses the stack to access its parameters and allocate local variables.</li> <li>Pop Items: After the method completes, the parameters and return address are popped off the stack, restoring the stack to its previous state.</li> </ol> <p>If a method calls another method (or itself in a recursive call), a new stack frame is created, and the process repeats. Each method call is thus isolated in its own stack frame.</p>"},{"location":"chapters/09_methods/09_call_stack/#practical-implications","title":"Practical Implications","text":"<p>In high-level languages like C#, the details of stack management are handled by the runtime environment. This abstraction allows developers to focus on writing code without worrying about the underlying mechanics. However, in low-level languages like assembly, programmers must manage the stack explicitly, making it crucial to understand these concepts.</p> <p>In summary, the call stack is a vital part of program execution, ensuring that function calls and returns occur in the correct order and that data is passed between methods effectively. Understanding how the stack works will deepen your understanding of how programs execute at a low level, even if you usually work with high-level languages.</p> <p>By keeping these concepts in mind, you'll gain a better grasp of how the CPU and memory work together to execute complex programs.</p>"},{"location":"chapters/10_recursion/","title":"Recursion","text":"<p>In this chapter</p> <ul> <li>Understand the principle of recursion.</li> <li>Compare recursion to iteration.</li> <li>Review the role played by the stack in recursive solutions.</li> <li>Recognize potential recursive solutions to problems.</li> <li>Understand the need for a base case to exit from a recursive method.</li> </ul>"},{"location":"chapters/10_recursion/#introduction","title":"Introduction","text":"<p>Recursion can be a challenging topic for many students, and it is often introduced later in programming or computer science courses. Although defining and explaining recursion is straightforward, identifying when and how to use it effectively can be more complex. In this section, we will explore the basics of recursion and how it compares to iteration, laying the groundwork for deeper discussions later on.</p>"},{"location":"chapters/10_recursion/#iteration-vs-recursion","title":"Iteration vs. Recursion","text":"<p>When we encounter a problem that requires repeating a set of instructions, we typically use loops to iterate over those instructions. This is known as iteration. For instance, if we want to print the integers between two given values, <code>a</code> and <code>b</code>, we can use a <code>for</code> loop:</p> <pre><code>static void PrintValues(int a, int b)\n{\n    for (int i = a; i &lt; b; i++)\n    {\n        Console.Write($\"{i}, \");\n    }\n    Console.WriteLine(b);\n}\n</code></pre> <p>This code iterates from <code>a</code> to <code>b</code>, printing each value. However, we can also solve this problem using recursion.</p>"},{"location":"chapters/10_recursion/#what-is-recursion","title":"What is Recursion?","text":"<p>Recursion occurs when a function calls itself to solve a smaller instance of the same problem. A recursive function typically consists of two parts:</p> <ol> <li>Base Case: The condition that stops the recursion, preventing an infinite loop.</li> <li>Recursive Case: The part of the function where the function calls itself with modified arguments, moving the problem closer to the base case.</li> </ol> <p>Let's rewrite the above example using recursion:</p> <pre><code>static void PrintValues(int a, int b)\n{\n    if (a == b)\n    {\n        Console.Write(b);\n    }\n    else\n    {\n        Console.Write($\"{a}, \");\n        PrintValues(a + 1, b);\n    }\n}\n</code></pre> <p>In this recursive version:</p> <ul> <li>Base Case: When <code>a</code> is equal to <code>b</code>, the function simply prints <code>b</code> and stops. This ensures that the function does not call itself indefinitely.</li> <li>Recursive Case: The function prints the current value of <code>a</code> and then calls itself with <code>a + 1</code> as the new argument. This moves the problem closer to the base case.</li> </ul>"},{"location":"chapters/10_recursion/#comparing-recursion-and-iteration","title":"Comparing Recursion and Iteration","text":""},{"location":"chapters/10_recursion/#similarities","title":"Similarities:","text":"<ul> <li>Both recursion and iteration are used to repeat a set of instructions.</li> <li>Any problem that can be solved with iteration can also be solved with recursion and vice versa.</li> </ul>"},{"location":"chapters/10_recursion/#differences","title":"Differences:","text":"<ul> <li>Iteration uses loop constructs (<code>for</code>, <code>while</code>, etc.) and relies on a counter or condition to stop.</li> <li>Recursion uses function calls and depends on a base case to terminate.</li> </ul>"},{"location":"chapters/10_recursion/#when-to-use-recursion","title":"When to Use Recursion:","text":"<p>Recursion is often more intuitive for problems that have a natural \"self-similar\" structure, such as:</p> <ul> <li>Factorial Calculation: <code>n! = n * (n - 1)!</code></li> <li>Fibonacci Sequence: <code>F(n) = F(n - 1) + F(n - 2)</code></li> <li>Tree Traversal: Exploring nodes in a tree-like structure.</li> </ul> <p>However, recursion can be less efficient in terms of memory and execution time because each recursive call adds a new entry to the call stack.</p>"},{"location":"chapters/10_recursion/#the-role-of-the-stack-in-recursion","title":"The Role of the Stack in Recursion","text":"<p>When a recursive function calls itself, the state of the current function (variables, return address, etc.) is pushed onto the call stack. Each recursive call creates a new stack frame, which holds the function's parameters and local variables.</p> <p>If the base case is not reached, the stack will keep growing, leading to a stack overflow. This occurs when the call stack exceeds its limit, usually due to deep or infinite recursion.</p>"},{"location":"chapters/10_recursion/#summary","title":"Summary","text":"<p>Recursion is a powerful tool in programming that allows for elegant and concise solutions to certain types of problems. Understanding its relationship with the call stack and the importance of a base case is crucial. As we continue to explore recursion in more depth, we will look at more complex examples and best practices for using recursion effectively.</p>"},{"location":"chapters/10_recursion/01_recursion_explained/","title":"Recursion Explained","text":"<p>From the syllabus</p> <p>AQA: Recursive Techniques (3.1.1.10/4.1.1.16):  - Be familiar with the use of recursive techniques in programming languages (general and base cases and the mechanism for implementation). - Be able to solve simple problems using recursion.</p> <p>Recursion is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem. Most programming languages support recursion by allowing a function to call itself from within its own code.</p> <p>Here's a tongue-in-cheek dictionary definition of recursion:</p> <ul> <li>Recursion: see Recursion</li> </ul>"},{"location":"chapters/10_recursion/01_recursion_explained/#what-is-recursion","title":"What is Recursion?","text":"<p>Recursion is a technique where a method calls itself with a smaller or simpler version of the original problem. This can be a powerful way to solve problems that have a repetitive or nested structure.</p> <p>To understand how this works, let\u2019s revisit the example from the previous section with <code>a = 1</code> and <code>b = 5</code>. </p> <pre><code>static void PrintValues(int a, int b)\n{\n    if (a == b)\n    {\n        Console.Write(b);\n    }\n    else\n    {\n        Console.Write($\"{a}, \");\n        PrintValues(a + 1, b);\n    }\n}\n</code></pre> <p>When <code>PrintValues(1, 5)</code> is called, the first statement in the <code>else</code> clause will print <code>1</code> to the screen. The method then calls itself with the updated values <code>a = 2</code> and <code>b = 5</code>. </p> <p>It's crucial to note that the first method call has not yet finished its execution when it calls itself again. We will explore this in more detail later. After several more recursive calls, the values will eventually be <code>a = 5</code> and <code>b = 5</code>. This is the terminating condition or base case. At this point, the <code>if</code> clause will be executed, and the method will stop calling itself. This termination prevents infinite recursion.</p> <p>Once the base case is reached, the method will start to unwind. This means that each previous call will complete in reverse order, one by one, until the initial call finishes and control is returned to the calling program.</p>"},{"location":"chapters/10_recursion/01_recursion_explained/#the-importance-of-a-base-case","title":"The Importance of a Base Case","text":"<p>The base case is essential for recursion to work correctly. Without a base case, the function will continue to call itself indefinitely, leading to an infinite recursion. This will eventually cause a stack overflow, crashing the program because the call stack\u2014the memory area where function calls are stored\u2014will run out of space.</p>"},{"location":"chapters/10_recursion/01_recursion_explained/#why-use-recursion","title":"Why Use Recursion?","text":"<p>This example may seem straightforward, but the real challenge is recognizing when, where, and how to use recursion effectively. When used correctly, recursion can provide elegant solutions to complex problems. It can simplify your code and reduce the complexity of your logic.</p> <p>The trick is to:</p> <ol> <li>Identify a simpler version of the problem that you can solve more easily.</li> <li>Express the original problem in terms of this simpler case.</li> <li>Apply recursion until the problem reduces to its simplest form (the base case), and then all the other steps will automatically resolve themselves.</li> </ol> <p>This may seem magical, but it\u2019s a logical consequence of breaking down a problem into smaller and smaller pieces until it becomes trivial to solve.</p>"},{"location":"chapters/10_recursion/01_recursion_explained/#a-visual-analogy","title":"A Visual Analogy","text":"<p>To visualize recursion, think of a set of nested Russian dolls. Each smaller doll fits inside a larger one, just like how each recursive call fits inside the previous one. The process continues until we reach the smallest doll, representing the base case. Afterward, the dolls are closed back in reverse order, similar to how recursive calls return and complete.</p> Recursion - with Russian Dolls"},{"location":"chapters/10_recursion/01_recursion_explained/#why-is-recursion-important","title":"Why is Recursion Important?","text":"<p>Recursion is one of the most fundamental ideas in computer science. Although it can be challenging to grasp at first, mastering recursion opens up new ways of thinking about problem-solving. It is particularly useful for problems that involve:</p> <ul> <li>Tree structures (e.g., parsing expressions, navigating file systems).</li> <li>Divide-and-conquer algorithms (e.g., quicksort, mergesort).</li> <li>Mathematical problems (e.g., calculating factorials, generating Fibonacci sequences).</li> </ul> <p>Finding recursive solutions requires a combination of logical thinking, practice, and sometimes even intuition. But with experience, it becomes an invaluable tool for solving complex problems.</p>"},{"location":"chapters/10_recursion/01_recursion_explained/#key-points-to-remember","title":"Key Points to Remember","text":"<ul> <li>Each call to a recursive function should bring the problem closer to the base case.</li> <li>Ensure that your recursive function has a clearly defined base case to prevent infinite recursion.</li> <li>Recursion is not always the best solution; consider whether an iterative approach might be simpler or more efficient.</li> </ul>"},{"location":"chapters/10_recursion/02_recursion_implemented/","title":"Implementing Recursion","text":"<p>Let's continue analyzing our <code>PrintValues()</code> example:</p> <pre><code>static void PrintValues(int a, int b)\n{\n    if (a == b)\n    {\n        Console.Write(b);\n    }\n    else\n    {\n        Console.Write($\"{a}, \");\n        PrintValues(a + 1, b);\n    }\n}\n</code></pre> <p>To understand how this function works, it's helpful to trace the flow of execution step-by-step. Using the values <code>a = 4</code> and <code>b = 6</code>, the series of calls to the <code>PrintValues()</code> method would look like this:</p> <pre><code>PrintValues(4, 6):\n    Console.Write(4);\n    PrintValues(5, 6):\n        Console.Write(5);\n        PrintValues(6, 6):\n            Console.Write(6);\n            return;\n        return;\n    return;\n</code></pre>"},{"location":"chapters/10_recursion/02_recursion_implemented/#understanding-recursive-algorithms","title":"Understanding Recursive Algorithms","text":"<p>Recursive algorithms generally have the following components:</p> <ul> <li> <p>Base Case: This is the simplest version of the problem, where the solution can be directly obtained without further recursion. The base case is crucial because it provides a stopping condition to prevent infinite recursion. In our example, the base case is:</p> <p><pre><code>if (a == b) { ... }\n</code></pre> Here, the function stops calling itself when <code>a</code> is equal to <code>b</code>.</p> </li> <li> <p>Recursive Call: This is where the function calls itself with a modified version of the original problem, bringing it closer to the base case. It is essential to ensure that each recursive call makes progress towards the base case. In our example:</p> <p><pre><code>PrintValues(a + 1, b)\n</code></pre> Each call increments <code>a</code>, moving closer to the base case.</p> </li> <li> <p>Processing (Work): This is the part of the function that performs any required computation before or after the recursive call. In our example:     <pre><code>Console.Write($\"{a}, \");\n</code></pre></p> </li> </ul>"},{"location":"chapters/10_recursion/02_recursion_implemented/#the-role-of-the-stack","title":"The Role of the Stack","text":"<p>The stack, as discussed in the previous chapter, plays a crucial role in the execution of recursive methods. Each time the method is called, its current state\u2014return address, parameters, and local variables\u2014is pushed onto the stack<sup>1</sup>. This ensures that when the function returns, it can continue where it left off.</p> <p>For instance, when <code>PrintValues(5, 6)</code> is called, it is pushed onto the stack, followed by <code>PrintValues(6, 6)</code>. Once the base case is reached, these calls are popped off the stack in reverse order, completing one after the other. This is known as the unwinding of the recursive calls. The stack operates as a Last In, First Out (LIFO) structure.</p>"},{"location":"chapters/10_recursion/02_recursion_implemented/#another-example-the-enigma-method","title":"Another Example: The <code>Enigma</code> Method","text":"<p>Consider the following method, which also demonstrates the components of a recursive function:</p> <pre><code>static void Enigma(int n)\n{\n    if (n &lt; 0)\n    {\n        Enigma(-n);\n    }\n    else if (n &lt; 10)\n    {\n        Console.Write(n);               \n    }\n    else\n    {\n        Enigma(n / 10);                 \n        int x = n % 10;                 \n        Console.Write(\", {0}\", x &amp; 1);\n    }\n}\n</code></pre>"},{"location":"chapters/10_recursion/02_recursion_implemented/#exercise-tracing-the-enigma-method","title":"Exercise: Tracing the <code>Enigma</code> Method","text":"<p>Work through the following calls to the <code>Enigma()</code> method and predict what will be displayed on the screen:</p> <ul> <li><code>Enigma(4)</code></li> <li><code>Enigma(99)</code></li> <li><code>Enigma(123)</code></li> <li><code>Enigma(-3456)</code></li> <li><code>Enigma(1234567)</code></li> </ul> <p>Let's trace <code>Enigma(99)</code> step-by-step:</p> <ol> <li><code>99</code> is neither negative nor less than <code>10</code>, so the final <code>else</code> block is executed.</li> <li>The method calls itself with <code>Enigma(99 / 10)</code>, which is <code>Enigma(9)</code>. This call is pushed onto the stack, and the first call remains unfinished.</li> <li><code>9</code> is less than <code>10</code>, so <code>9</code> is printed to the screen, and the method returns.</li> <li>Control returns to the previous call where <code>n = 99</code>. Now, <code>x</code> is set to <code>99 % 10</code>, which is <code>9</code>, and <code>9 &amp; 1</code> evaluates to <code>1</code>. This <code>1</code> is printed to the screen.</li> </ol> <p>Try repeating this process with the other test calls listed above. Check that you understand why the output for these calls is:</p> <ul> <li><code>Enigma(4)</code> prints <code>4</code></li> <li><code>Enigma(99)</code> prints <code>9, 1</code></li> <li><code>Enigma(123)</code> prints <code>1, 0, 1</code></li> <li><code>Enigma(-3456)</code> prints <code>3, 0, 1, 0</code></li> <li><code>Enigma(1234567)</code> prints <code>1, 0, 1, 0, 1, 0, 1</code></li> </ul>"},{"location":"chapters/10_recursion/02_recursion_implemented/#when-to-use-recursion","title":"When to Use Recursion","text":"<p>This brings us to the question: Which implementation is better? Is recursion always the best solution compared to an iterative one?</p> <p>Recursion can simplify code and make certain problems easier to solve, especially those involving complex data structures like trees. However, it also uses more memory due to the overhead of multiple function calls and can lead to stack overflow if not carefully managed.</p> <p>It's not the best solution for all problems, but for some cases (as we will see later in the chapter), recursion is precisely the right tool to use.</p> <ol> <li> <p>The stack is an area of memory that stores local variables and function calls. It follows a Last In, First Out (LIFO) order, meaning the last method pushed onto the stack is the first one to be popped off.\u00a0\u21a9</p> </li> </ol>"},{"location":"chapters/10_recursion/03_examples/","title":"Examples of Using Recursion","text":"<p>In the following sections, we'll explore several \"classic\" algorithms to gain more experience in viewing problems through the lens of recursion.</p>"},{"location":"chapters/10_recursion/03_examples/#summing-a-list-of-integers","title":"Summing a List of Integers","text":"<p>This is a simple problem, similar to the previous examples, but here the method returns a value, making it a function.</p>"},{"location":"chapters/10_recursion/03_examples/#iterative-solution","title":"Iterative Solution","text":"<p>Let's start with an iterative approach:</p> <pre><code>static void Main(string args[])\n{\n    int sum = GetSum(4);\n    Console.WriteLine(sum);\n}\n\nstatic int GetSum(int n)\n{\n    int total = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        total += i;\n    }\n    return total;\n}\n</code></pre> <p>We expect the result <code>6</code> to be printed to the screen, not <code>10</code> as initially stated. The sum of the numbers from 0 to 3 is <code>0 + 1 + 2 + 3 = 6</code>.</p> <p>To sum a given set of numbers <code>{1, 2, 3, 4}</code>, we could represent it as <code>4 + 3 + 2 + 1</code>. This helps us frame a recursive solution to the same problem:</p>"},{"location":"chapters/10_recursion/03_examples/#recursive-solution","title":"Recursive Solution","text":"<pre><code>static int GetSum(int n)\n{\n    if (n &lt;= 0)\n    {\n        return 0;\n    }\n    int sum = n + GetSum(n - 1);\n    return sum;\n}\n</code></pre> <p>In this recursive solution, we add the current number <code>n</code> to the sum of all numbers less than <code>n</code>. The recursive function is called repeatedly, decreasing <code>n</code> by 1 each time, until it reaches the base case (<code>n &lt;= 0</code>), where it returns <code>0</code>.</p>"},{"location":"chapters/10_recursion/03_examples/#understanding-the-call-stack","title":"Understanding the Call Stack","text":"<p>The key to understanding recursion lies in how the call stack works. Let's trace the execution for <code>n = 3</code>:</p> <ol> <li><code>GetSum(3)</code> is called.</li> <li><code>3 + GetSum(2)</code> is evaluated.</li> <li><code>2 + GetSum(1)</code> is evaluated.</li> <li><code>1 + GetSum(0)</code> is evaluated.</li> <li><code>GetSum(0)</code> returns <code>0</code>, triggering the unwinding of the recursive calls.</li> </ol> <p>The accumulated result is <code>3 + 2 + 1 + 0 = 6</code>. </p>"},{"location":"chapters/10_recursion/03_examples/#visualizing-the-stack","title":"Visualizing the Stack","text":"<p>It's beneficial to visualize how the stack \"winds\" and \"unwinds\" as recursive calls are made and returned. The figures below illustrate this concept:</p> Winding up the methods Unwinding the methods"},{"location":"chapters/10_recursion/03_examples/#avoiding-infinite-recursion","title":"Avoiding Infinite Recursion","text":"<p>Be careful! Recursion without a proper base case leads to infinite recursion, which results in a stack overflow. This happens when the system runs out of memory to allocate to the stack, causing the program to crash.</p>"},{"location":"chapters/10_recursion/03_examples/#converting-an-integer-to-a-string-in-any-base","title":"Converting an Integer to a String (in Any Base)","text":"<p>Let's build a recursive solution to convert an integer into a string representation in any base, such as decimal (base 10) or binary (base 2).</p> <p>We start with a simple case: converting the integer <code>245</code> into the string <code>\"245\"</code> or the binary string <code>\"1110101\"</code>. We will use a lookup string <code>convToString = \"0123456789ABCDEF\"</code>. For example, <code>convToString[5]</code> returns <code>\"5\"</code>. The task is to decompose the number <code>245</code> into its individual digits (<code>2</code>, <code>4</code>, and <code>5</code>), and use these as indices to the lookup string.</p>"},{"location":"chapters/10_recursion/03_examples/#steps-in-the-conversion","title":"Steps in the Conversion","text":"<ol> <li>Reduce the Number: Break the number into its individual digits.</li> <li>Convert to String: Use the lookup string to convert each digit.</li> <li>Concatenate Strings: Combine the digit strings in the correct order.</li> </ol> <p>The base case occurs when the number is less than the base itself. For example, dividing <code>245</code> by <code>10</code> yields <code>24</code> with a remainder of <code>5</code>. The remainder <code>5</code> is converted first, then we move to <code>24</code>, and so on, until a single digit remains.</p> <p>Here's the recursive function:</p> <pre><code>static string DecToAnyBase(int n, int b)\n{\n    string ch = \"0123456789ABCDEF\";\n    if (n &lt; b)\n        return ch[n].ToString();\n    else\n        return DecToAnyBase(n / b, b) + ch[n % b].ToString(); \n} \n</code></pre>"},{"location":"chapters/10_recursion/03_examples/#factorial","title":"Factorial","text":"<p>The factorial function (<code>n!</code>) is a classic example of recursion. It's not because recursion is the best way to compute factorials, but because it's easy to understand the concept using this problem.</p> <p>Recall that the factorial of a number <code>n</code> is the product of all integers from <code>1</code> to <code>n</code>. By definition, <code>0! = 1</code>.</p> <p>Here's how some factorials are calculated:</p> <pre><code>0! = 1\n1! = 1 * 1\n2! = 2 * 1\n3! = 3 * 2 * 1\n4! = 4 * 3 * 2 * 1\n5! = 5 * 4 * 3 * 2 * 1\n6! = 6 * 5 * 4 * 3 * 2 * 1\n</code></pre> <p>Alternatively, factorials can be defined recursively as:</p> <pre><code>0! = 1\nn! = n * (n - 1)!\n</code></pre> <p>Let's implement this using a recursive function:</p> <pre><code>static int Factorial(int n)\n{\n    if (n == 0)\n        return 1;            // base case\n    else\n        return n * Factorial(n - 1);  // recursive call\n}\n</code></pre> <p>This function can be called as follows:</p> <pre><code>Console.WriteLine(Factorial(5));  // Output: 120\n</code></pre> <p>Notice how the mathematical definition of factorial closely matches the recursive implementation.</p>"},{"location":"chapters/10_recursion/03_examples/#summary","title":"Summary","text":"<ol> <li>Trace Execution: Always trace the execution of recursive functions to understand their behavior.</li> <li>Base Case: Ensure every recursive function has a proper base case to avoid infinite recursion.</li> <li>Efficiency: Recursion can be elegant, but it's not always the most efficient solution compared to iterative methods.</li> </ol>"},{"location":"chapters/10_recursion/04_thinking_recursively/","title":"Thinking Recursively","text":"<p>When first encountered recursion can appear difficult, our tendency is usually when meeting a problem requiring a loop is to jump to one of the standard iteration constructs, either <code>for</code> or <code>while</code>.  The following steps should help to rewire our minds to think recursively.</p> <p>Taking a simple problem such as summing the digits in a value e.g. \\(245\\) sums as \\(11\\), \\(9764523\\) sums as \\(36\\).</p>"},{"location":"chapters/10_recursion/04_thinking_recursively/#step-1-create-the-iterative-solution","title":"Step 1: Create the iterative solution","text":"<p>As a first stab, we might convert the given integer into a string and then iterate over each of the characters in the string, converting them to the value equivalent (from the underlying ASCII code) and add each to a sum variable:</p> <pre><code>Console.Write(\"Enter an integer: \");\nnumStr = Console.ReadLine();\nint sum = 0;\nfor(int i = 0; i &lt; numStr.Length; i++)\n{\n    sum += numStr[i]-48;\n}\nConsole.WriteLine(sum);\n</code></pre>"},{"location":"chapters/10_recursion/04_thinking_recursively/#step-2-write-it-as-a-function","title":"Step 2: Write it as a function","text":"<p>Next, how might this code be turned into a function with parameters?  We need is to extract everything after the string conversion and pass the string as a parameter and returning the sum integer:</p> <pre><code>// from Main()\nConsole.Write(\"Enter an integer: \");\nnumStr = Console.ReadLine();\nConsole.WriteLine(GetSumOfDigits(numStr));\n//\n\nstatic int GetSumOfDigits(string numStr)\n{\n    int sum = 0;\n    for(int i = 0; i &lt; numStr.Length; i++)\n    {\n        sum += numStr[i]-48;\n    }\n    return sum;\n}\n</code></pre>"},{"location":"chapters/10_recursion/04_thinking_recursively/#step-3-what-is-the-minimal-problem-instance","title":"Step 3:  What is the minimal problem instance?","text":"<p>That is, what is the simplest case for this problem?  It'll be when we only have one digit in our number.  If our number is \\(5\\) then the <code>sum</code> will be \\(5\\).</p>"},{"location":"chapters/10_recursion/04_thinking_recursively/#step-4-amend-the-function-for-this-case","title":"Step 4:  Amend the function for this case","text":"<p>Our function will loop even when <code>num</code> is \\(5\\).  This needs to be amended to cope with this instance, ensuring that when the input length is \\(1\\) just return that number:</p> <pre><code>static int GetSumOfDigits(string numStr)\n{\n    int sum = 0;\n    if (numStr.Length == 1)\n    {\n        return numStr[0] - 48;                  // we need the value, not the ASCII code\n    }\n    else\n    {\n        for(int i = 0; i &lt; numStr.Length; i++)\n        {\n            sum += numStr[i]-48;\n        }\n    }\n    return sum;\n}\n</code></pre>"},{"location":"chapters/10_recursion/04_thinking_recursively/#step-5-apply-recursion-to-the-function","title":"Step 5: Apply recursion to the function","text":"<p>We already have the base case for recursion, when the digit is a single digit.  We now need to see that to sum \"245\" is the same as <code>2 + GetSumOfDigits(\"45\");</code> and the sum of \"45\" is the same as <code>4 + GetSumOfDigits(\"5\");</code> and we know <code>GetSumOfDigits(\"5\");</code> is \\(5\\).  So, we need to pass back into our function the rest of the string that has not yet been handled knowing it will terminate when there is a single digit to process.</p> <p>There is a \"gotcha\" here that needs more unpacking, how to pass back a shorter string to our function?  In C# a string, under the hood, is an zero-based index array of characters and has a method returning the length of the string.  Thus, \"5\" will have a length of \\(1\\) and to access the value we'd use <code>numStr[numStr.Length - 1];</code>.  This is fiddly, it's simpler to pass in to our function an additional parameter, the length of the string:  <code>GetSumOfDigits(string num, int length);</code>.  </p> <p>Now, in our recursive call we can write:</p> <pre><code>sum += (numStr[length-1] + GetSumOfDigits(numStr, length-1)) - 48;\n</code></pre> <p>Which describes the solution as it was explained above.</p> <p>Thus, our full recursive function:</p> <pre><code>static int GetSumOfDigits(string numStr, int length)\n{\n    int sum = 0;\n    if (length == 1)\n    {\n        return numStr[length-1]-48;\n    }\n    else\n    {\n        sum += (numStr[length-1] + GetSumOfDigits(numStr, length-1)) - 48;\n    }\n    return sum;\n}\n</code></pre> <p>This could be tidied up by making our base case end when the <code>length == 0</code> and then <code>return 0</code>.</p> <p>You might like to take the same steps to create a recursive function that calculates the power of a number entered at the keyboard.</p>"},{"location":"chapters/10_recursion/05_programming_task/","title":"Programming Task - Solving Sudoku","text":"<p>Consider this section as ADVANCED but introduces an application where a recursive solution is the best way to go.  The concepts here of searching through a problem space is usually considered in later texts on programming when advanced data structures such as trees and graphs are covered.</p> <p>With more than a passing nod to the Latin Square of Euler (1707-1783) the Sudoku puzzle has grown in popularity, most daily papers will publish a Sudoku challenge alongside a daily crossword and books of the puzzle can be bought in local bookshops.  The principle is simple: given a \\(9\\) x \\(9\\) grid that contains some scattered numbers and blanks, complete the puzzle in such a way that each row, column and \\(3\\) by \\(3\\) region contains each of the digits \\(1\\) to \\(9\\).  </p> <p>There is a problem set on Project Euler that provides a number of sample sudoku problems to solve.  The problem set there is to sum the first three digits in the first row of each the given problems.  We'll not get there but will use the example puzzles in our solution.</p> <p>To think how we might solve such a problem consider this sample:</p> Empty Sudoku puzzle <p>If you've never tried to complete a Sudoku with pen and paper, look at the \\(3\\) x \\(3\\) region in the top left hand corner.  The three empty squares must each contain one of either \\({[1, 4, 9]}\\), but how can you work out which goes where?</p> <p>We could adopt a brute force approach:</p> <ul> <li>Select an empty square</li> <li>Pick a number between \\(1\\) and \\(9\\)</li> <li>If this number is not repeated in either target row, column or region then write in that number, else pick an alternative number</li> <li>If none of our numbers meet the conditions in the previous step, a mistake has been made so backtrack to the previous position</li> <li>Repeat until the puzzle has been solved.</li> </ul> <p>NB.  We use the term region to denote the \\(3\\) by \\(3\\) sub-grid.</p> <p>If you think that's a lengthy, time-consuming process you'd be right and it would be daft to take this approach manually.  However, we have a computer well capable of handling millions of instructions per second so we can implement this tactic and get a result relatively quickly.</p> <p>It's worth pausing briefly to consider how we might improve on our brute-force algorithm.  One of the first steps taken by a manual Sudoku solver is to list the candidate numbers for each cell:</p> Sudoku solving <p>This approach will reduce the run-time of our algorithm considerably, instead of picking a random number between \\(1\\) and \\(9\\) we select one of the candidates from the list of possible values.  We are optimising our potential solution space through a process known as minimisation.  Once we've placed a number in a cell, e.g. \\(4\\) in the above grid this is no longer a candidate in its respective row, column or region and the candidates need to updated e.g. middle row, far right.  This is called constraint propagation but, of course, occurs across the whole of the Sudoku grid.</p> <p>In our sample region we'd then be left knowing that \\(1\\) and a \\(9\\) will be in these empty squares but we do not know which just yet.  A manual solver would then look to see if there is another cell with just these candidates in a respective row, column or region thus being able to eliminate these values as candidates from the other cells in that row, column or region.</p> <p>In this case, we're left with a singleton, \\(4\\), in one of the squares so this can be filled in, removing \\(4\\) from the candidates in the far right column.  We can go no further using such a process for this region.</p> <p>A further optimisation we might apply is to start in the region with the least number of unassigned cells.  It stands to reason that the top left region has less to do in searching for possible solutions than the region to its right.</p> <p>We could continue in this way to mimic the manual solver's process but it would take a lot of code and is not required as we can use the computer to search for the correct solution.  The solution we'll consider does involve some minimisation as we'll only be selecting those values not currently assigned in the target row, column or region.</p> <p>If interested in the manual approach this page provides a good summary</p>"},{"location":"chapters/10_recursion/05_programming_task/#backtracking","title":"Backtracking","text":"<p>Backtracking is one of those situations where a recursion is better than trying an iterative solution.</p> <p>The principle is to work through all possible configurations for a particular search space, if we arrive at a dead end (i.e. no solution possible) we backtrack to the most recent successful solution and try again.  You can think of working your way out of a maze, if you move up and then find a wall you return to the previous place and try moving to the right and so on.</p> <p>Backtracking can be used to solve a Sudoku puzzle.  When given a partially completed grid we find the first square that is empty.  We can only use the numbers from \\(1\\) through to \\(9\\) so we start by checking if \\(1\\) would be valid i.e. there are no others \\(1\\)s in that row, column or region, if there are move on to \\(2\\) and so on.</p> <p>Then move to the next empty square following the same process.  If you reach a point where none of our nine values are valid, we need to back track by unmaking our last decision and trying again.</p> <p>Checking for the presence of a value in a row, column or region can be implemented as:</p> <pre><code>static bool IsValid(int[,] grid, int row, int col, int num)\n{\n    return !UsedInRow(grid,row,num) &amp;&amp;\n            !UsedInColumn(grid,col,num) &amp;&amp;\n            !UsedInRegion(grid,row-row%3,col-col%3,num);\n}\n</code></pre> <p>The <code>grid</code> being represented as a 2D array of integers.</p> <p>Our helper methods here are:</p> <pre><code>static bool UsedInRow(int[,] grid, int row, int num)\n{\n    for(int col = 0; col &lt; 9; col++)\n    {\n        if(grid[row,col] == num) return true;\n    }\n    return false;\n}\n\nstatic bool UsedInColumn(int[,] grid, int col, int num)\n{\n    for(int row = 0; row &lt; 9; row++)\n    {\n        if(grid[row,col] == num) return true;\n    }\n    return false;\n}\n\nstatic bool UsedInRegion(int[,] grid, int startRow, int startCol, int num)\n{\n    for(int row = 0; row &lt; 3; row++)\n    {\n        for(int col = 0; col &lt; 3; col++)\n        {\n            if(grid[row+startRow,col+startCol] == num)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> <p>There should be no surprises here, we iterate through each of the values in either the row, column or region and return <code>false</code> if not found, <code>true</code> otherwise.</p> <p>The backtracking happens in the <code>Solve()</code> method:</p> <pre><code>static bool solve(int[,] cells)  \n{  \n    for (int i = 0; i &lt; cells.GetLength(0); i++)        // loop through each row ...\n    {  \n        for (int j = 0; j &lt; cells.GetLength(1); j++)    // ... and column\n        {  \n            if (cells[i, j] == UNASSIGNED)              // we have an empty cell\n            {  \n                for (int num = 1; num &lt;= 9; num++)      // try each number from 1 to 9\n                {  \n                    if(IsValid(cells,i,j,num))          // it looks OK ...\n                    {  \n                        cells[i, j] = num;              // assign that value to the empty cell\n\n                        if (solve(cells))               // recurse through the other cells\n                        {\n                            return true;                // the puzzle has been solved\n                        }\n                        else  \n                            cells[i, j] = UNASSIGNED;   // problem: it didn't work so make the cell empty\n                    }                                   // triggering the backtracking\n                }  \n                return false;  \n            }  \n        }  \n    }\n    return true;  \n}\n</code></pre> <p>Using the code above, create a Sudoku solver.  Initially, hardcode the grid:</p> <pre><code>int[,] grid = new int[9,9]\n    {\n        { 3, 0, 6, 5, 0, 8, 4, 0, 0 },\n        { 5, 2, 0, 0, 0, 0, 0, 0, 0 },\n        { 0, 8, 7, 0, 0, 0, 0, 3, 1 },\n        { 0, 0, 3, 0, 1, 0, 0, 8, 0 },\n        { 9, 0, 0, 8, 6, 3, 0, 0, 5 },\n        { 0, 5, 0, 0, 9, 0, 6, 0, 0 },\n        { 1, 3, 0, 0, 0, 0, 2, 5, 0 },\n        { 0, 0, 0, 0, 0, 0, 0, 7, 4 },\n        { 0, 0, 5, 2, 0, 6, 3, 0, 0 }\n    };\n</code></pre> <p>Then call your method to <code>Solve()</code>.  You'll need to write your own method to print the grid to the screen.</p> <p>As an extension, take a look at the problem set on the Project Euler page.  This provides a text file of fifty Sudoku problems.  You'll need to read ahead to see how to load these from a file into an array of grids.</p>"},{"location":"chapters/10_recursion/06_questions/","title":"Questions","text":""},{"location":"chapters/10_recursion/06_questions/#sum-numbers-in-an-array-trace-table","title":"Sum numbers in an array - trace table","text":"<p>Complete the trace table for the following program. How many times is the recursive routine called? What is output?</p> <pre><code>int marks[] = { 3, 6, 2, 8 };\nint sum = GetSumRecursively(marks, marks.length);\nConsole.WriteLine(COnvert.ToInt32(sum));\n\nstatic int GetSumRecursively(int[] numbers, int length)\n{\n    if (length == 0)\n        return 0;\n    else\n    {\n        return GetSumRecursively(numbers, length-1) + numbers[length-1];\n    }\n}\n</code></pre> Numbers length numbers[0] output {3,6,2,8} 4 3 + addNums({6,2,8}) {6,2,8} 8"},{"location":"chapters/10_recursion/06_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write a recursive function to return the length of a string</li> <li>Write a function that takes a string as a parameter and returns a new string that is the reverse of the old string. (Hint: use <code>substring</code> method on the string to pass a smaller form of the string.)</li> <li>Write a program to calculate the power of any number using recursion e.g. <code>MyPow(x, n)</code> that returns \\(x^n\\).</li> <li>Write a recursive function that returns true if an input string is a palindrome e.g. \"rotor\" is a palindrome, it can be read forwards and backwards.  (Hint:  the start and end letters must be the same, the second and penultimate letters must be the same, and a single character is a palindrome).</li> <li>Write a program that solves the Towers of Hanoi problem (see https://www.educative.io/edpresso/what-is-the-tower-of-hanoi-problem)</li> </ol>"},{"location":"chapters/10_recursion/07_computational_thinking/","title":"Extended Theory - Computational Thinking","text":"<p>At its heart computer science is about problem-solving, particularly solving problems using a computer and for programming actually writing the code that enables the problem to be solved.  It's a two-step process:</p> <ul> <li>Think about the steps needed to solve the problem, the algorithm, and then</li> <li>Write program statements to implement those steps, the code</li> </ul> <p>To do this effectively we need, in some part, to think like a computer.  Of course, a computer cannot think (!) but it means we need to understand the processes and approaches taken by the computer in order to write our algorithm appropriately, or computational thinking.  It's a term coined by Jeannette Wing:</p> <p>Computational thinking is the thought processes involved in formulating problems and their solutions so ... [they] ... can be represented in a form that can be carried out by an information processing agent.  (Wing, 2010)</p> <p>There are several processes involved here:</p> <ul> <li>logical reasoning: to predict, analyse and explain</li> <li>algorithms: the steps required to solve the problem</li> <li>decomposition: breaking the problem down into smaller problems</li> <li>abstraction: manage the complexity of the problem</li> <li>generalisation: being able to spot patterns and similarities for re-use</li> <li>evaluation: making judgements on the outcome</li> </ul> <p>Much of the text thus far has been using the first two of these to construct algorithmic solutions to smaller problems using C#.  Chapter 9 introduced the third, decomposition and we'll explore more of what that means as well as abstraction and generalisation here.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#decomposition","title":"Decomposition","text":"<p>Decomposition is not unique to programming or computer science, we do this every day in the real world.   Delivering a course such as this on programming in C# involves breaking the language down into smaller chunks, working on those before advancing to the next.  The computer you use will be built from many different components, each manufactured separately before being combined into a computer hardware system.  Cooking a meal involves decomposition of selecting the menu, purchasing the ingredients, preparing and cooking those ingredients, perhaps combining the results from previous preparations and so on.  Each of these tasks could be passed to another person to complete, perhaps independently of any other tasks.</p> <p>In the previous chapter we started to pass responsibility for completing parts of our program to smaller sections of code.  It makes the process of managing a larger problem much easier and in the \"real world\" we could work as a team with different teams taking responsibility for coding these sub-problems before they get combined into the larger problem.  These smaller problems, of course, may not be quite so small and will required further breaking down into a series of sub-sub-problems and so on.</p> <p>It's important, as you plan your solutions to look for those opportunities to break the problem down.  Once you have the sub-problems solved you can combine them to produce the solution to the larger problem i.e. composition.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#abstraction","title":"Abstraction","text":"<p>The concept of abstraction lies at the heart of computational thinking allowing us to manage complexity - focusing on what is important and ignoring unnecessary detail thus making the problem easier to think about.  We've seen this at work already e.g. we use binary numbers (\\(0\\)s and \\(1\\)s) to represent physical voltages in a computer, the detail of how the semiconductors etc are handling these voltages is abstracted away to a \\(0\\) or a \\(1\\), it's hiding the underlying reality.  The underground map of London is another example of abstraction as it shows the various underground trains lines in London and the relative position of the stations on those lines.  It does not show the distance between the stations, nor how far underground each station is.  It's a representational abstraction of the reality.</p> <p>When designing a system for the computer we need to consider what details are required, and what details can be ignored.  In a system keeping track of students in a school or college there are details we need such as their first name, last name, postcode etc but details such as, say, their show size or favourite music style are irrelevant.  We may think differently if we were designing a system for an on-line shoe retailer or a streaming music service.  We need the right amount of detail to solve the given problem in hand - no more.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#abstraction-by-generalisation","title":"Abstraction by generalisation","text":"<p>A generalisation is a form of abstraction, this involves a grouping of characteristics common to a particular type.  Thinking again of a system to handle data in a school system we're going to need data about pupils and staff (including teaching and non-teaching staff).  In this context the pupils and staff members are all people sharing common characteristics such as name, address, date of birth etc..  We can generalise these shared details into a new data type:  Person.  A \"Person\" is a more generalised type, a \"Student\" or \"StaffMember\" is a special kind of Person in this context.  One could further categorise \"teaching staff\" and \"non-teaching staff\" and make these specialised kinds of \"StaffMember\".</p> <p>Problems themselves can also be categorised e.g. decision problems, search problems, counting problems, optimisation problems and tractable or intractable problems.  Each type of problem will exhibit shared characteristics and apply similar principles in developing their solution or even sharing code between them.  It's an important skill to be able to abstract away some of the details of a particular problem until we can arrive at a generalisation.  We can refer to this technique as problem abstraction.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#information-hiding","title":"Information hiding","text":"<p>This refers to keeping implementation details hidden from a user.  For example, in card playing program we'd expect a method to <code>Shuffle()</code> the cards.  There are different ways of implementing the algorithm to produce a randomised sequence of cards ready for use in a card game.  We might have a method signature for this such as <code>public DeckOfCards Shuffle(DeckOfCards deck)</code>.  As developers all we need to know is the existence of this <code>Shuffle()</code> method and know that we need pass in a deck of cards to the method and expect to receive back the shuffled deck of cards.  The author of this method can make changes to the shuffling algorithm used at a later stage but our program can call the method ignorant of the implementation details, as long as the interface, that is the method signature, to that method remains the same.</p> <p>We call this method signature an interface, it's an abstraction of the complexity that lies behind that interface.  We're familiar with the term is e.g. user interface, an essential feature of an operating system that itself provides many examples of abstraction.  Think of the menus, icons etc, the folders and files made visible through the interface hiding the complexity of how those directories and files are physically stored.</p> <p>We can also describe this hiding of implementation details as functional abstraction, the method is a black box.  Pass data in and data will be returned and we do not care how that returned data has been computed.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#procedural-abstraction","title":"Procedural abstraction","text":"<p>Procedural abstraction represents a method.  The goal is to make the procedure as generalised as possible so it can be used for different problems.  We can think of this in two ways.  Take the example of calculating the area of a rectangle with sides of 4cm and 3cm, which we could call this method <code>CalculateAreaOfSquare();</code>:</p> <pre><code>public void CalculateAreaOfSquare()\n{\n    int area;\n    int side1 = 4;\n    int side2 = 3;\n    area = side1 * side2;\n    ConsoleWriteLine(area);\n}\n</code></pre> <p>It should be clear that this is not an ideal way to proceed!  It would be much more useful to be able to calculate the area of a rectangle of any size by passing in the sides as parameters:</p> <pre><code>public void CalculateAreaOfSquare(int side1, int side2)\n{\n    int area;\n    area = side1 * side2;\n    Console.WriteLine(area);\n}\n</code></pre> <p>There's still an issue that this method will only handle rectangles with whole number sides.  Not an enormous problem as we could require the sides are converted into millimetres before calling the function.  However, there is a further issue that is problematic, but may not be immediately obvious.</p> <p>The method calculates the area of a square.  That is all it should do is do the calculations and return that value, but we're also displaying the result to the screen.  These should be regarded as two separate methods, <code>CalculateArea()</code> and <code>PrintArea()</code>.  The displaying to the screen statement in the original method is known as a side-effect, these should be avoided when writing methods.  Once we've removed the side-effect the method can be used in a console application, a web application, an application using a graphical user interface and so on.  This is known as separation of concerns, the method should be responsible for one thing either calculating the area or printing the output but not both.</p> <p>The change needed is to make this method return the value of the <code>area</code> to the calling program:</p> <pre><code>public int CalculateAreaOfSquare(int side1, int side2)\n{\n    return side1 * side2;\n}\n</code></pre> <p>Procedural abstraction involves making the procedure as generalised as possible.</p>"},{"location":"chapters/10_recursion/07_computational_thinking/#data-abstraction","title":"Data abstraction","text":"<p>Thinking back to the <code>Shuffle()</code> example.  This needed a <code>DeckOfCards</code> to be passed in and a deck of cards returned.  That data type could be defined as a <code>struct</code> or an an <code>object</code>.  Internally, this deck of cards will be made up of \\(52\\) playing cards, another user-defined data type, <code>card</code>, that could be a <code>struct</code> or an <code>object</code> with variables for its rank and suit, but how will this deck of cards be organised?  It could be an array, a list, a stack, a queue or other structure we can use to organise data.</p> <p>When we call the <code>Shuffle()</code> method we pass the Deck data type.  It's hidden from us, as we call the method, how the Deck has been implemented.  Is it an <code>array</code> of cards?  Perhaps it's a <code>list</code>?  Either the array or the list could be organised as a <code>stack</code>, or a <code>queue</code>.  The point is the details of how the data is being organised has been hidden.</p> <p>Further, how that data structure itself has been implemented is also hidden.  If it's a <code>stack</code> of cards we'd expect to find methods to manipulate the stack, such as <code>Push()</code> to add an item to the top of the stack, and <code>Pop()</code> to remove the item at the top of the stack.  Again, how these methods have been implemented are not revealed unless we inspect the code at the lowest level.</p>"},{"location":"chapters/11_text_files/","title":"Text Files","text":"<p>In this chapter</p> <ul> <li>Explain the need for persistent data</li> <li>Read and write data to a text file using the File class</li> <li>Define the full file path of a text file that is to be used</li> <li>Use the StreamWriter class to write one or more lines to a text file</li> <li>Use the StreamReader class to read a text file line by line</li> <li>Recognise that a struct is the implementation of a record in C#</li> <li>Know how to use a struct as a lightweight class</li> <li>Structure text file using CSV</li> </ul> <p>While a program is running all data is stored in Random Access Memory (RAM), when the program ends (or the computer shuts down), all data in RAM will be lost.  To make our data persist it needs to be saved to an external storage device, or network cloud, as a file.</p> <p>There are two categories of classes in C# for dealing with Input/Output (I/O). There are classes that deal with (1) information about the file system itself e.g. copying  or moving files and/or directories, and (2) reading and writing data from different sources.  The different approaches to handling I/O can seem intimidating at first, particularly with the second category as the data can come from a variety of devices (e.g. peripherals, files, network connections).  We've already been interacting with peripheral devices, reading data from the keyboard (<code>Console.ReadLine()</code>) and writing data to the screen (<code>Console.WriteLine</code>).  In this chapter we'll expand into reading data from files, and writing data to files.</p> <p>Before getting into the actual reading and writing of data there are some utility classes that deal with file-handling and directories.</p> <p>From the syllabus</p> <p>AQA: Fields, records and files (3.2.1.3/4.1.1.16): Be able to read/write from/to a text file.}</p> <ul> <li>A text file is a computer file that only contains text and has no special formatting such as bold text, italic text, images, etc..  A text file stores all of its data as characters represented by their Unicode code.  Text files are read sequentially, from the beginning to the end.</li> </ul>"},{"location":"chapters/11_text_files/#directories-files-and-paths","title":"Directories, Files and Paths","text":"<ul> <li>Directory: methods for working with folders</li> <li>File: a class we can use for files</li> <li>Path: the route to the folder where a file is stored</li> </ul> <p>Let's see, first, how these interact by checking to see if a file called <code>settings.json</code> exists in a user's home directory.  Here's the code:</p> <pre><code>using System;\nusing System.IO;\n\nnamespace directories\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string path = \"\";\n\n            // check for SAH directory in personal user account directory\n            try\n            {\n                // on a Windows system: C:\\Users\\&lt;my username&gt;\\AppData\\Roaming\n                path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \"SAH\");\n                if (!Directory.Exists(path))\n                {\n                    Directory.CreateDirectory(path);\n                    Console.WriteLine($\"Directory created: {path}\");\n                }\n                else\n                {\n                    Console.WriteLine($\"Directory exists: {path}\");\n                }\n            }\n            catch\n            {\n                Console.WriteLine($\"Unable to create directory: {path}.  please check permissions\");\n            }\n\n            if (File.Exists(Path.Combine(path, \"settings.json\")))\n            {\n                try\n                {\n                    // load the file here\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Unable to load the settings file: {ex.Message}\");\n                }\n            }\n            else\n            {\n                try\n                {\n                    // create the file here\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Unable to create the settings file: {ex.Message}\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>There's a lot of code here but most is taken up with exception handling.  Handling exceptions when dealing with files and directories is a must so we can deal with I/O errors correctly.</p> <p>Firstly, we set the path:</p> <pre><code>path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \"SAH\");\n</code></pre> <p>Using the <code>Combine</code> method of the <code>Path</code> class we concatenate the name of our directory, \"SAH\", with the ApplicationData (<code>%APPDATA%</code>) directory on our Windows box.  In this case it is is set to <code>C:\\Users\\&lt;my username&gt;\\AppData\\Roaming</code>.  If we have the correct permissions, or know the file should default to a particular location, we could have hard-coded the path e.g. <code>D:\\\\MyUSBDrive\\\\MyProjects</code>.  NB. the double backslash is required, it's an escape sequence.  If our program is saving data to a location on the user's file system we need to have permission to write to that directory.  Alternatively, we could ask the user for the location.</p> <p>We then use the <code>Directory</code> class to check if this directory exists, if it does not exist it gets created with the <code>CreateDirectory</code> method.</p> <p>It's a similar procedure to check if the file, <code>settings.json</code>, exists.  If it does we can load the settings into our application (code not shown), or create the file (code not shown).</p> <p>Warning</p> <p>Before being able to save data to an external storage device the user will need the necessary permissions and access rights.   Both Windows and Linux permit saving data to a user's personal directories.  If you release applications \"into the wild\" make sure you know where data can be stored.  It is probably safest to ask the user to select the directory.</p> <p>The <code>File</code> class can be used for simple and quick file access.  To write (or read) from a file, the file has to be opened, and then closed when finished with.  Here's a very simple example:</p> <pre><code>TextWriter myFile = File.CreateText(\"test.txt\");\nmyFile.WriteLine(\"Hello, World!\");\nmyFile.Close();\n</code></pre> <p>This looks very similar to writing text to the <code>Console</code>, replacing the Console class with the identifier for our file.  If the file does not exist it will be created and when we've finished with it the file is closed and made available for other programs to use.</p> <p>This next example using the <code>ReadAllText()</code> method to the contents of a file into a string variable:</p> <pre><code>static void Main(string[] args)\n{\n    if(File.Exists(\"test.txt\"))\n    {\n        string content = File.ReadAllText(\"test.txt\");\n        Console.WriteLine(\"Current content of file:\");\n        Console.WriteLine(content);\n    }\n    Console.WriteLine(\"Please enter new content for the file:\");\n    string newContent = Console.ReadLine();\n    File.WriteAllText(\"test.txt\", newContent);\n}\n</code></pre> <p>This program assumes the path is the current working directory (though not recommended) and if the text file exists reads its contents to a string and displays the contents.  Our program then asks the user for more content which is saved to the file (actually overwriting any existing content).</p> <p>There is an equivalent method <code>ReadAllLines()</code> which can read each line into an array of strings for further processing.</p> <p>Other methods provided by the <code>File</code> class include:</p> <ul> <li><code>ReadAllText()</code>: the opposite to <code>WriteAllText()</code></li> <li><code>Create()</code>: Creates a file, returning a <code>FileStream</code></li> <li><code>Delete()</code>: Deletes a file</li> <li><code>Open()</code>: Opens a file for access with specified `FileMode`` i.e. read, write or append</li> <li><code>Close()</code>: Closes a file.  If a file has been opened, it must always be closed.</li> <li><code>Exists()</code>: Determines whether the file exists, returns a Boolean</li> <li><code>Copy()</code>:  Copies an existing file to a new file specified in the second parameter</li> <li><code>Move()</code>: Moves a file to a new location, or file</li> </ul>"},{"location":"chapters/11_text_files/01_streams/","title":"Streams","text":"<p>It's important to understand the concept of a stream when learning how I/O works in .NET as working with files is realised, more commonly, with streams.  It's fair to say that nowadays all I/O is handled by streams.  To use these streams, and other file-handling operations, we need to add the I/O namespace to our application:</p> <pre><code>using System.IO;\n</code></pre> <p>The principal of a stream is of a pipe connected at either end down which data flows between the application and the data source.  The data source could be a hard drive or a server on the Internet, it could be streaming data to a printer, or reading data from a sound card, or scanning documents from a scanner.  That is, ANY external device can receive or send data via the stream and the stream classes provided by .NET ensure a smooth flow of data for reading and writing between devices.  </p> <p>Thus, the stream represents any data source as an object capable of receiving, or sending, data.  The stream hides the details of what is happening inside the actual I/O device, best considered as an abstraction of a data communication channel.</p> <p>From the computer's perspective a stream is an ordered sequence of sequential bytes. There are different streams for working with text files, binary files or communications across a network.  This chapter deals exclusively with FileStream.</p> <p>Text files use the <code>StreamReader</code> and <code>StreamWriter</code> classes; binary files with <code>BinaryReader</code> and <code>BinaryWriter</code>.  Binary files are dealt with in the next chapter.</p> <p>A stream must be opened before it can be used, and must be closed when finished.</p> <p>It's worth pointing out that I/O in C# comes with a number of options and it can be overwhelming at first working out which option is the right one to use.  The I/O itself is not that tricky, but finding your way through the maze of possibilities can be.</p>"},{"location":"chapters/11_text_files/01_streams/#stream-operations","title":"Stream operations","text":"<p>With all I/O streams we can:</p> <ul> <li>create/open the stream, i.e. connect to a data source.  Here we also set the mode of access, i.e. reading, writing or both</li> <li>reading from the stream</li> <li>writing to the stream</li> <li>searching: or going to a particular position in the stream from a starting point (not supported by network streams)</li> <li>closing the stream, this should be done as soon as we've finished working with the stream to release resources</li> </ul> <p>Once we've opened the stream and connected to the source of data we can basically forget about the data source and let the stream manage the connection for us but we do need to manipulate the data being read or being written.</p>"},{"location":"chapters/11_text_files/01_streams/#text-streams","title":"Text Streams","text":"<p>A text file is the simplest type of file and the most versatile.  As the name suggests, the text file contains raw text characters with no special formatting applied.  Note while a word processor document file (e.g. .doc) might seem to contain text they also contain formatting information in binary.  All text files will be natively readable by humans if we view its contents in memory and can be displayed without error by simple text editor software such as Notepad for Windows.</p> <p>To read and write text from files in C# there are two main classes:</p> <ul> <li>TextWriter: including <code>Write()</code>, <code>WriteLine()</code></li> <li>TextReader: including <code>ReadLine()</code>, <code>ReadToEnd()</code></li> </ul> <p>Inheriting from these classes are:</p> <ul> <li><code>StreamReader</code>, and</li> <li><code>StreamWriter</code>.  </li> </ul> <p>It is these classes we will use for handling operations with text files.</p>"},{"location":"chapters/11_text_files/02_writing_to_a_file/","title":"Writing to a text file","text":"<p>Consider the following example:</p> <pre><code>using System;\nusing System.IO;\n\nnamespace textfiles\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Reading/Writing with text files\");\n\n            using(StreamWriter sw = new StreamWriter(@\"text.txt\")) \n            {\n                sw.WriteLine(\"The first line\");\n                sw.WriteLine(\"The second line\");\n                sw.WriteLine(\"The third line\");\n                sw.Flush();\n            }\n        }\n    }\n}\n</code></pre> <p>The program needs access to the <code>IO</code> classes so the line <code>using System.IO;</code> must be included.  Our main block of code uses a <code>using</code> block, this ensures the stream is closed when it has been finished with.  The alternative to the <code>using</code> block is to explicitly call <code>sw.Close()</code>.  It's easy to forget this so the <code>using</code> block is preferable.  A stream is an expensive resource and there should be no more than one stream open on the same file at one time so get into the habit of making sure the stream is closed before trying to open it again.</p> <p>The <code>StreamWriter</code> takes the name of the file as a parameter.  It is assumed here the file will be created in the current directory.  Writing to the file is done using the <code>WriteLine()</code> method in just the same way as we've used it for writing to the console.  </p> <p>The final statement calls <code>Flush()</code>.  The operating system puts data to be written in a buffer, the contents of the buffer may not be written out to the stream immediately (that's the point of holding it in a buffer first!). If the program crashes before the buffer has been written we'll not know how far it got and our data will be in an inconsistent state.  This method forces the buffer to be emptied before the stream is closed.  It can be omitted in this short example but often safer to include it.</p> <p>Run this file in a new project.  There will be a newly created file, <code>text.txt</code>, in your project directory.  Change some of the lines being written and run it again.  What do you see in the new file?  The previous contents have been overwritten.  Adding another parameter to the StreamWriter class can put it into append mode:</p> <pre><code>    StreamWriter sw = new StreamWriter(@\"text.txt\", true);\n</code></pre> <p>Make the change, run the program and look at the contents of <code>text.txt</code>:</p> <pre><code>The first line\nThe second line\nThe third line\nThe first line\nThe second line\nThe third line\n</code></pre>"},{"location":"chapters/11_text_files/03_reading_from_a_file/","title":"Reading from a text file","text":"<p>This is no more complicated than writing to the file but now using the <code>StreamReader</code> class.  We read in each line in turn, for which we have to use a loop, and ensure we do not read beyond the end of the file.  </p> <p>Add the following code to your source code after the writing section, compile and run:</p> <pre><code>using(StreamReader sr = new StreamReader(@\"text.txt\"))\n{\n    string strIn = sr.ReadLine();\n    while (strIn != null)\n    {\n        Console.WriteLine(strIn);\n        strIn = sr.ReadLine();\n    }\n}\n</code></pre> <p>We first set the name of the file to read in a <code>using</code> block and read the first line from the stream into a string.  Then loop until we get to the end of the file (<code>strIn != null</code> just means the line we've read has some content, it has not been set to <code>null</code>).  The body of the loop prints the line to the console and then reads the next line.</p> <p>The opening lines can be combined:</p> <pre><code>    while ((strIn = sr.ReadLine()) != null)\n    {\n        //\n    }\n</code></pre> <p>Alternatively, we can use the <code>Peek()</code> method to check for the end of file.  This method returns an integer value of the first character in the line to be read.  A return value of \\(-1\\) indicates the end of the file has been reached:</p> <pre><code>    while(reader.Peek() != -1)\n    {\n        //\n    }\n</code></pre> <p>As we've just opened a file created in the program it's safe to assume it exists but it is advisable to wrap any writing or reading with files in a <code>try ... catch</code> block as we saw earlier.  A number of different exceptions could be thrown:</p> <ul> <li><code>FileNotFoundException</code></li> <li><code>DirectoryNotFoundException</code></li> <li><code>IOException</code></li> </ul> <p>The following example illustrates the steps required.  It adds a lot of code but better than having your program crash:</p> <pre><code>string filename = \"text.txt\";\ntry\n{\n    StreamReader sr = new StreamReader(filename);\n    Console.WriteLine($\"File: {filename} has been opened\");\n    string strIn = sr.ReadLine();\n    using(sr)\n    {\n        while (strIn != null)\n        {\n        Console.WriteLine(strIn);\n        strIn = sr.ReadLine();\n        }    \n    }\n}\ncatch (FileNotFoundException)\n{\n    Console.WriteLine($\"Cannot find file {filename}\");\n}\ncatch (DirectoryNotFoundException)\n{\n    Console.WriteLine($\"Cannot find directory\");\n}\ncatch (IOException)\n{\n    Console.WriteLine(\"IO Exception has occurred\");\n}\n</code></pre> <p>Change the reading section of your project file and change the name of the file to be read to something you know does not exist and run.  It should handle the exception gracefully.</p>"},{"location":"chapters/11_text_files/04_csv_files/","title":"CSV files","text":"<p>A Comma Separated Values file (.CSV) is a text file used for storing data where each item of data, as the name implies, is separated by a comma.  Thus, there is an implicit structure to each line of data where each comma separated item is a field.  It's a handy and quick way of storing structured text data such as contacts, to do lists and the like.</p> <p>We can read the .CSV file in just the same way as above but now each line needs to be split, on the comma separator, into its various fields.</p> <p>Assuming we already have a .CSV file for a simple to do list:</p> <pre><code>13/04/2021,Apply for job,In progress\n13/04/2021,Clean out hamster cage,Not Started\n14/04/2021,Take car in for service,Not started\n15/04/2021,Buy birthday card for brother,Not started\n</code></pre> <p>We need a simple program to add new items to the list and to write our list to the screen:  </p> <pre><code>using System;\nusing System.IO;\n\nnamespace csvfiles\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DateTime taskDueDate;\n            string task;\n            string status;\n\n            Console.Clear();\n            Console.WriteLine(\"TODO Manager\");\n\n            Console.WriteLine(\"Enter the task: \");\n            Console.Write(\"Due Date: &gt; \");\n            taskDueDate = Convert.ToDateTime(Console.ReadLine());\n            Console.Write(\"Description: &gt; \");\n            task = (Console.ReadLine());\n            Console.Write(\"Status: &gt; \");\n            status = Console.ReadLine();\n\n            string filename = \"todo.txt\";\n            StreamWriter sw = new StreamWriter(filename, true);\n            using(sw)\n            {\n                sw.WriteLine($\"{taskDueDate.ToShortDateString()},{task},{status}\");\n                sw.Flush();\n            }\n        }\n    }\n}\n</code></pre> <p>Having declared variables to hold the data, we get input from the user and write the fields to the file as a whole line, using string interpolation, separated by commas.</p> <p>Note</p> <p>The <code>DateTime</code> field is converted so just the date is stored and not the time as well.</p> <p>The data for our simple TODO application has a clearly defined structure but currently just held in separate variables.  This will become tricky to handle if we have a lot of these data items that we wish to process.  To help with this we can use a struct.</p>"},{"location":"chapters/11_text_files/04_csv_files/#reading-from-a-csv-file","title":"Reading from a .CSV file","text":"<p>Assuming we're now holding our data in a <code>struct</code>, to demonstrate we'll read the file, line by line, splitting each line into its constituent members using the <code>Split()</code> method and print to the console.</p> <pre><code>StreamReader sr = new StreamReader(filename);\nTodo taskItem;\nstring line; \nusing(sr)\n{\n    line = sr.ReadLine();\n    while(line != null)\n    {\n        string[] items = line.Split(',');\n        taskItem.taskDueDate = Convert.ToDateTime(items[0]);\n        taskItem.task = items[1];\n        taskItem.status = items[2];\n        Console.WriteLine(taskItem.ToString());\n        line = sr.ReadLine();\n    }\n}\n</code></pre> <p>We've changed the <code>ToCSV()</code> method in the <code>struct</code> overriding the inbuilt <code>ToString()</code> method (that all objects in C# have).  It returns a string representation of our data structure.  Add this to the <code>struct</code> definition, compile and run:</p> <pre><code>public override string ToString()\n{\n    return $\"{taskDueDate.ToShortDateString()} : {task} ({status})\";\n}\n</code></pre>"},{"location":"chapters/11_text_files/05_struct/","title":"Struct","text":"<p>The <code>struct</code> is a value date type used to represent a data structure where each field can be of a different type, unlike <code>array</code> where each element is the same data type.  It is simply a collection of variables that can be treated as a single data item with multiple fields/members.  The <code>struct</code> is called a <code>record</code> in other languages.</p> <p>The <code>struct</code> is a lightweight alternative to a <code>class</code>, it has a lot in common with a class without the ability to inherit from other structs (though interfaces are supported).  Also, it is stored on the stack rather than the heap, thus it is a value type not a reference type.  They are perfect for simple data structures such as the examples we'll be using here.  Microsoft uses structs a great deal instead of classes, getting familiar with using <code>structs</code> serves as a good introduction to classes.  </p> <p>For our TODO application a <code>struct</code>would look like:</p> <pre><code>struct Todo\n{\n    public DateTime taskDueDate;\n    public string task;\n    public string inProgress; \n}\n</code></pre> <p>The <code>struct</code> definition can be included in our main program file, or preferably, in a separate file within the same namespace.</p> <p>We declare the <code>struct</code> variable as:</p> <pre><code>    Todo tasks;\n</code></pre> <p>Our main program can now use our newly created <code>struct</code> as a variable where each member field is accessed using the dot operator:</p> <pre><code>static void Main(string[] args)\n{\n    todo Tasks;\n\n    Console.Clear();\n    Console.WriteLine(\"TODO Manager\");\n\n    Console.WriteLine(\"Enter the task: \");\n    Console.Write(\"Due Date: &gt; \");\n    Tasks.taskDueDate = Convert.ToDateTime(Console.ReadLine());\n    Console.Write(\"Description: &gt; \");\n    Tasks.task = (Console.ReadLine());\n    Console.Write(\"Status: &gt; \");\n    Tasks.status = Console.ReadLine();\n\n    string filename = \"todo.txt\";\n    StreamWriter sw = new StreamWriter(filename, true);\n    using(sw)\n    {\n        sw.WriteLine(Tasks.ToCSV());\n        sw.Flush();\n    }\n</code></pre> <p>Perhaps, we've not gained much ... yet ... but, consider how you might handle a list (<code>array</code>) of these tasks.  It's also much easier to pass a single structure than lots of separate variables.</p> <p>The <code>struct</code> can be initialised with the keyword <code>new</code>:</p> <pre><code>Todo Tasks = new Todo();\n</code></pre> <p>When you create a structure object without using <code>new</code>, you must assign values to each member field before accessing them, otherwise it will give a compile time error.</p> <p>Also, the <code>struct</code> can contain its own methods:</p> <pre><code>struct Todo\n{\n    public DateTime taskDueDate;\n    public string task;\n    public string status;\n\n    public string ToCSV()\n    {\n        return $\"{taskDueDate.ToShortDateString()},{task},{status}\";\n    }\n}\n</code></pre> <p>We can call this method to write the entire line as:</p> <pre><code>sw.WriteLine(Tasks.ToCSV());\n</code></pre> <p>This is better written, as we'll see later, as a <code>ToString()</code> method.</p> <p>NB.  The <code>struct</code> can also have a constructor and properties in much the same way as a <code>class</code>.</p> <p>To declare an array of struct:</p> <pre><code>Todo[] Tasks = new Todo[20];\n</code></pre> <p>Each <code>Todo</code> item can be read using the index of the array:  <code>Tasks[1].task</code> etc..  Of course, this could also be a <code>List&lt;Todo&gt;()</code>.</p>"},{"location":"chapters/11_text_files/06_programming_task/","title":"Programming Task - Running Club","text":"<p>Peter runs a local running club.  He wants a program to keep membership information for his club members.  To keep it simple, he just needs to store the first name, last name and preferred running distance (5k, 10k, half-marathon, marathon, ultra) in a file.</p> <p>Write a program that enables Peter to add new members, display all members and to search for a member by surname.  </p> <p>NB.  Data should be saved to a file (<code>.TXT</code> or <code>.CSV</code>) and the program should use the <code>StreamReader</code> and <code>StreamWriter</code> classes.</p> <p>CHALLENGE:  </p> <ul> <li>Present a list of available distances so Peter can choose before saving the member to the file</li> <li>Amend the program so Peter can list the runners in his club that prefer a given distance</li> </ul>"},{"location":"chapters/11_text_files/07_questions/","title":"Questions","text":"<ol> <li>What is a file?</li> <li>What is a text file?</li> <li>How is the end of a line in a text file indicated?</li> <li>Find three other control codes that can be embedded in a text file.  How are these used in C#?</li> <li> <p>The <code>File</code> class in the namespace <code>System.IO</code> has a number of static methods.  Find the method that provides the following functionality:</p> <p>a. Copies one file to another b. Moves a file to another location c. Reads all lines in the file to a string d. Checks if a file exists in a given location e. Appends a string to a file f. Opens a FileStream with read/write access</p> </li> <li> <p>Describe a <code>struct</code> to hold details of a Book, including the fields Title, Author, ISBN, PublicationYear and Price.</p> </li> <li>What exceptions might occur when opening a file programmatically?</li> <li> <p>Given the following recursive method, an input string of <code>\"Peter,Jones,Marketing Manager,Ext. 788\"</code> and the <code>,</code> as the delimiter, what will be the output on the screen:</p> <pre><code>static void OutputCSVLines(string input, char delimiter)\n{\n    int location = input.IndexOf(delimiter)+1;\n    string word = input.Substring(0, location);\n    string rest = input.Substring(location);\n    if (location &gt; 0)\n    {\n        Console.WriteLine(word.Trim());\n        OutputCSVLines(rest,',');\n    }\n    else\n    {\n        Console.WriteLine(rest);\n    }\n}\n</code></pre> </li> </ol>"},{"location":"chapters/11_text_files/07_questions/#additional-exercises","title":"Additional Exercises","text":"<ol> <li>Write a program that reads the contents of a text file and inserts the line numbers at the beginning of each line, then rewrites the file contents.</li> <li>Modify the Caesar Cipher program to read the plaintext from a file, output the cipher text to a different file.</li> <li>Modify the Maze program to read a maze pattern from a file</li> <li>Write a program to read a list of names from a file, sorts them (using a bubble sort or alternative sorting algorithm) and writes the sorted list back to the file</li> <li>Write a program to read a file of text and count the number of words in the file</li> </ol>"},{"location":"chapters/11_text_files/08_finite_state_machines/","title":"Extended Theory -  Finite State Machines","text":"<p>A state machine is a rather abstract concept though in the real world, and in our code world, we will encounter them often without really knowing it.  Many of the physical devices we interact with are examples of state machines e.g. a cashpoint machine (or ATM).  As we proceed to the end state of getting our cash out the machine will move through various states only capable of accepting certain inputs before moving on to the next state, or reverting back to the previous; or a vending machine where once we've inserted our coins will move to a state where it will accept out choice of item, through to dropping that item to the floor of the machine where we can collect etc..</p> <p>The state machine can be a useful concept when input is received and what happens next is dependent on that input.  This can be illustrated simply by a light switch.  There are two states \"on\" and \"off\" associated by two events \"push switch down\" and \"pull switch up\".</p> Light Switch <p>Thus a finite state machine:</p> <ul> <li>can be in one of a number of defined states at any given time, and</li> <li>changes from one state to another in response to an input, or event</li> </ul> <p>This behaviour can be represented using a state-transition diagram where each of the states is an ellipse and the events that move the switch from one state to the other indicated by arrows:</p> A Switch, finite state machine <p>It should be clear the greyed out lines and actions are redundant as the state will not be changed.  Sometimes, it is important to show these redundant actions but common sense should prevail when managing the potential complexity of the diagram.</p> <p>Another simple example of a state machine would be a set of traffic lights.  At any point in time the lights, in the UK, will be in one of four states:</p> <ul> <li>red on, amber off, green off</li> <li>red on, amber on, green off</li> <li>red off, amber on, green off</li> <li>red off, amber off, green on</li> </ul> red on, amber off, green off <p>Each scenario is known as a state, whether the lights are on or off is the output and the movement from one state to another is called the transition.  In our traffic light scenario the transition will be triggered by a timer counting down from a fixed value.  (We'll exclude triggers such as road mounted pressure pads, or pedestrians pushing a button on a crossing.)</p> <p>There are only four states, this is fixed and finite, hence it is a finite state machine.  Any light can be described as a finite state machine, it has two states either 'on' or 'off'.  If we add, say, a dimmer switch to our light switch the number of states is no longer finite, there's an infinite number of states it can be in.</p> <p>We can visualise our traffic light state machine using a simple diagram:</p> Traffic Light Transitions <p>We'll start with the light on red, after a number of seconds the lights move to the red-amber state, more seconds elapse and the trigger to move to the green state for the traffic to go, then transitioning to the amber state before returning to red and the cycle continues.</p> <p>This can also be modelled using a state transition table:</p> State Input Next State S0: RED Timer S1: RED-AMBER S1: RED-AMBER Timer S2: GREEN S2: GREEN Timer S3: AMBER S3: AMBER Timer S0: RED <p>Modelling a system in terms of its states and how it moves from one state to another enables us to have a better understanding of the systems we are implementing.  Our traffic lights can only be in one of the four proscribed states, no others are permitted e.g. there is no state where both the red and green lights are lit at the same time.</p> <p>It's similar for a system such as a lift, though there may be more states e.g. lift is ascending, lift is descending, lift is stationary, doors are open, doors are closed, users entering etc and triggered by the user pushing a button.  If the lift is on another floor it will need to go to the requested floor (moving into either the ascending or descending state), when stationary the doors will open and users enter the lift and wait for a further trigger to either ascend or descend etc.</p> <p>The use of finite state machines are common in games too.  Think of the ghosts in a game like Pacman, once released from their enclosure, they are always in one of three states.  Their normal state is to chase Pacman using Pacman's position in selecting their direction, or they are in scatter mode towards the corners of the game space but once the Pacman consumes an energy pill they move to a frightened state, change colour and move more slowly.  Their behaviour, their actions are determined by their state.</p> <p>It's fair to say, every application is a state machine but perhaps those states and how they transition has not been explicitly defined.</p> <p>To implement a traffic light state machine it'd be common to use a <code>switch</code> statement where each state is changed by each <code>case</code> clause.  The selection of the <code>case</code> clause will be dependent on either:</p> <ul> <li>an event triggered by an external factor e.g. user pressing a button on a pedestrian crossing, or pressure pads built into the road</li> <li>a timer counting down an allotted amount of time</li> </ul> <p>In our traffic lights there is a sequence in that each state has only one following state, and we'll omit any intervening event to disrupt this cycle.</p> <p>Firstly, an <code>enumeration</code> captures the states:</p> <pre><code>enum State \n{\n    RED, RED_AMBER, AMBER, GREEN\n}\n</code></pre> <p>Assuming the presence of a variable for the <code>currentState</code> of the light, our switch statement captures the sequence:</p> <pre><code>switch(currentState)\n{                  \n    case State.RED:\n        currentState = State.RED_AMBER;\n        break;\n    case State.RED_AMBER:\n        currentState = State.GREEN;\n        break;\n    case State.GREEN:\n        currentState = State.AMBER;\n        break;\n    case State.AMBER:\n        currentState = State.RED;\n        break;                            \n}      \n</code></pre> <p>Nothing complicated here, and we can define a <code>struct</code> for a TrafficLight and embed the logic:</p> <pre><code>public struct TrafficLight\n{\n    public State currentState { get; set; }\n\n    public TrafficLight(State stateStart)\n    {\n        currentState = stateStart;\n    }\n\n    public string Change()\n    {\n        switch(currentState)\n        {                  \n            case State.RED:\n                currentState = State.RED_AMBER;\n                break;\n            case State.RED_AMBER:\n                currentState = State.GREEN;\n                break;\n            case State.GREEN:\n                currentState = State.AMBER;\n                break;\n            case State.AMBER:\n                currentState = State.RED;\n                break;                            \n        }   \n        return currentState.ToString();\n    }\n}\n</code></pre> <p>Then our main program can create the traffic light and use either a timer or some other trigger to model the changing state:</p> <pre><code>static void Main(string[] args)\n{\n    TrafficLight tl = new TrafficLight(State.RED);\n    Console.WriteLine(\"Starting on \" + tl.currentState);  // RED\n    Console.WriteLine(\"Moving to   \" + tl.Change());      // RED_AMBER\n    Console.WriteLine(\"Moving to   \" + tl.Change());      // GREEN\n    Console.WriteLine(\"Moving to   \" + tl.Change());      // AMBER   \n}\n</code></pre> <p>The output for our traffic light system is dependent on the current state alone and is thus classified as a Moore Machine.</p> <p>Another common use for Finite State Machines is to check acceptable inputs for a given alphabet of characters e.g. does the entered string consist only of ones and zeros, or does the binary string have an even number of ones when checking for even parity:</p> Finite State Machine - Even Parity <p>The goal here is to reject, or accept some value based on a definition of what is, or is not, acceptable.  It requires:</p> <ul> <li>a set of permitted symbols</li> <li>a set of acceptable states</li> </ul> <p>Consider the following scenario:</p> Finite State Machine - alphabet <p>This, like the binary example, describes a deterministic finite-state machine, which simply means a given string from the alphabet is either accepted or rejected.  We can model the states and the inputs using an <code>enum</code>:</p> <pre><code>public enum State { S1, S2, S3, S4, ERROR };\npublic enum Input {a = 'a',b = 'b',c = 'c',d = 'd'};\n</code></pre> <p>Handling the change of states is through a <code>switch</code> construct (which in later versions of .NET accepts multiple variables to check against):</p> <pre><code>static State ChangeState(State current, Input input)\n{\n    switch(current,input)\n    {\n        case(State.S1,Input.a):\n            current = State.S2;\n            break;\n        case(State.S2,Input.b):\n            current = State.S1;\n            break;\n        case(State.S2,Input.c):\n            current = State.S4;\n            break;\n        case(State.S2,Input.a):\n            current = State.S2;\n            break;\n        case(State.S4,Input.d):\n            current = State.S3;\n            break;\n        case(State.S3,Input.b):\n            current = State.S4;\n            break;\n        case(State.S3,Input.a):\n            current = State.S1;\n            break;\n        default:\n            current = State.ERROR;\n            break;\n    }\n    return current;\n}\n</code></pre> <p>The <code>switch</code> mimics the state transition table for this scenario:</p> Current State Input New State S1 a S2 S2 a S2 S2 b S1 S2 c S4 S3 a S1 S3 b S4 S4 d S3 <p>Now we can pass values to our \"machine\" to check for validity:</p> <pre><code>static void Main(string[] args)\n{\n\n    Console.Write(\"Enter a string to test &gt; \");\n    string str = Console.ReadLine();\n    var current = State.S1;\n    foreach(char c in str)\n    {\n        current = ChangeState(current, (Input)c);\n    }\n    if (current == State.S4)\n        Console.WriteLine($\"{current}: A valid string \");\n    else\n    {\n        Console.WriteLine($\"{current}: An invalid string\");\n    }\n}\n</code></pre> <p>The same approach can be taken with e.g. a vending machine, here the user enters coins (limited to 10p, 20p and 50p) to purchase a drink costing 50p.  Our machine also provides output to the user informing them of how much is left to pay.</p> <p>The state transition diagram is:</p> Finite State Machine - Vending <p>This extract is incomplete but illustrates how the same structure from our previous example can be applied here, the difference being that our machine now generates some output.  A finite state machine whose output is determined by both its current state and current inputs is known as a Mealy Machine:</p> <pre><code>class Program\n{\n    public enum States { S0, S1, S2, S3, S4, S5, ERROR };\n    public enum Input { ZERO = 0, TEN = 10, TWENTY = 20, FIFTY = 50 };\n    static void Main(string[] args)\n    {\n        States currentState = States.S0;\n        int remaining = 0;\n        Input input = Input.TEN;\n        (currentState,remaining) = ChangeState(currentState, input);\n        Console.WriteLine($\"State is now {currentState}\");\n        Console.WriteLine($\"Money to input is now {remaining} pence\"); \n    }\n\n    static (States nextState, int nextInput) ChangeState(States current, Input input)\n    {\n        States nextState = current;\n        int nextInput = 0;\n        switch(current,input)\n        {\n            case(States.S0,Input.FIFTY):\n                nextState = States.S5;\n                nextInput = 0;\n                break;\n            case(States.S0,Input.ZERO):\n                nextState = States.S0;\n                nextInput = 50;\n                break;\n            case(States.S0,Input.TEN):\n                nextState = States.S1;\n                nextInput = 40;\n                break;\n            // additional states go here\n            default:\n                nextState = States.ERROR;\n                nextInput = 50;\n                break;\n        }\n        return (nextState,nextInput);\n    }\n}\n</code></pre> <p>Note how this method returns multiple inputs, there are several ways of getting more than one output from a method and it's worth spending some time trying each of these out.  The example above uses the <code>tuple</code> syntax now available in .NET, but could also have been achieved using <code>ref</code> parameters, and an <code>out</code> parameter or bundling the data into a <code>struct</code> (or <code>class</code>).</p> <p>As a final C# example of a finite state machine, consider this example of parsing a string of HTML text and wanting to highlight the digits in that text by making them italicised:</p> <pre><code>using System;\nusing System.Text;\n\nnamespace fsm_bold\n{\n    class Program\n    {\n        public enum States\n        {\n            NAN,                        // not a number\n            NUMBER\n        }\n        static void Main(string[] args)\n        {\n            string testString = \"I am 18 years of age, and was born in 1896.\";\n            StringBuilder sb = new StringBuilder();\n            States state = States.NAN;\n            for (int i = 0; i &lt; testString.Length; i++)\n            {\n                char ch = testString[i];\n                switch(state)\n                {\n                    case States.NAN:\n                        if (Char.IsDigit(ch))\n                        {\n                            sb.Append(\"&lt;i&gt;\" + ch);\n                            state=States.NUMBER;\n                            break;\n                        }\n                        else\n                        {\n                            sb.Append(ch);\n                        }\n                        break;\n                    case States.NUMBER:\n                        if (!Char.IsDigit(ch))\n                        {\n                            sb.Append(\"&lt;/i&gt;\" + ch);\n                            state = States.NAN;\n                            break;\n                        }\n                        else\n                        {\n                            sb.Append(ch);\n                        }\n                    break;\n                }\n            }\n            Console.WriteLine(sb.ToString());\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/12_binary_files/","title":"Binary Files","text":"<p>In this chapter</p> <ul> <li>Know the difference between a text file and a binary file</li> <li>Be able to read and write with binary files</li> <li>Explore classes for dealing with JSON and XML files</li> <li>Introduce serialization of structs</li> </ul> <p>A binary file is a non-text file, a sequence of bytes, where each byte can be interpreted as text or something other than text.  It does not have any concept of \"lines\", only bytes of data.  Put simply, a text file can be read by humans, a binary file can be read by a computer.  They are a collection of \\(0\\)s and \\(1\\)s and are processed byte by byte.</p> <p>Binary files have (are) falling out of favour as systems move to formats such as .JSON and .XML but there are many legacy systems that make use of them and there are lot of file formats which are neither ASCII (Unicode) nor .XML.  Binary files deal in the raw data, they are likely to be more efficient than text files but with a language like C# (.NET) which is strongly typed the stream of bytes will need to be converted into the data types you want.</p> <p>Binary files are generally faster and smaller than text files and have to be read by specific programs to be useable. For example, a Microsoft Word binary file can only be read by the Word application. Try opening a binary .doc/.docx Word file in a text editor such as notepad and marvel at the \"garbage\" it produces!</p> <p>Here is a simple example to illustrate one way of reading and writing bytes to a file:</p> <pre><code>byte[] buffer = File.ReadAllBytes(\"myfile.mp4\");\nFile.WriteAllBytes(\"myfileCopy.mp4\", buffer);\n</code></pre> <p>First the contents of the file are read into the `buffer``, then written out to a new file.  This should work fine for small files but for larger files we need to read the file byte-by-byte:</p> <pre><code>Stream inputFile = File.OpenRead(\"myfile.mp4\");\nStream outputFile = File.Create(\"myfileCopy.mp4\");\n\nconst int maxRead = 1024;\nbyte[] buffer = new byte[maxRead];\nwhile (true)\n{\n    int n = inputFile.Read(buffer, 0, maxRead);\n    if (n == 0) break;\n    outputFile.Write(buffer, 0, n);\n}\ninputFile.Close();\noutputFile.Close();\n</code></pre> <p>Having defined our files an array of bytes is declared for the buffer to hold the data, and a maximum number of bytes to read assigned which is then used in the <code>Read()</code> method.  This method returns the number of bytes that have been read, if none are read we've reached the end of the file so <code>break</code> out of the loop.</p>"},{"location":"chapters/12_binary_files/01_binary_files/","title":"Binary Files","text":"<p>The class <code>BinaryWriter()</code> creates the binary file:</p> <pre><code>string filename = \"test.bin\";\nBinaryWriter bw = new BinaryWriter(File.Open(filename, FileMode.Create));\n</code></pre> <p>The class takes a <code>File</code> object which needs the name of the file and how that file is to be opened, a <code>FileMode</code>, which can be <code>Create</code>, <code>Open</code>, <code>Append</code>, <code>OpenOrCreate</code>).</p>"},{"location":"chapters/12_binary_files/01_binary_files/#writing-to-a-binary-file","title":"Writing to a binary file","text":"<p>For this example, we'll simply write one record to a file.  </p> <p>The data is defined in a <code>struct</code> with a constructor method:</p> <pre><code>private struct Book\n{\n    public int Id;\n    public string Title;\n    public string Author;\n    public double Price;\n    public int Year;\n\n    public Book(int id, string title, string author, double price, int year)\n    {\n        Id = id;\n        Title = title;\n        Author = author;\n        Price = price;\n        Year = year;\n    }\n}\n</code></pre> <p>The constructor method used here, with the same name is the <code>struct</code>, creates the <code>struct</code> object and passes into it default values when the variable of type <code>Book</code> is declared with the <code>new</code> keyword:</p> <pre><code>Book willows = new Book(1,\"Wind in the Willows\", \"Kenneth Grahame\", 14.99, 1908);\n</code></pre> <p>The constructor method must take the same name as the <code>struct</code>, and, if using a constructor, the parameters must be provided.</p> <p>To write to the file, call the <code>Write()</code> method of the <code>BinaryWriter</code> object:</p> <pre><code>using(BinaryWriter writer = new BinaryWriter(File.Open(filename, FileMode.Create)))\n{\n    writer.Write(willows.Id);           // dot operator access the fields of the struct\n    writer.Write(willows.Title);\n    writer.Write(willows.Author);\n    writer.Write(willows.Price);\n    writer.Write(willows.Year);\n}\n</code></pre> <p>As an aside, we can get some information about this file by using a <code>FileInfo</code> class, e.g.</p> <pre><code>FileInfo fInfo = new FileInfo(filename);\nConsole.WriteLine($\"{fInfo.Length} bytes\");\n</code></pre>"},{"location":"chapters/12_binary_files/01_binary_files/#reading-from-a-binary-file","title":"Reading from a binary file","text":"<p>Reading from a binary file infers that we know the structure of the file we are reading, because we need to read the data in the correct format, e.g. we cannot read an <code>integer</code> field to a <code>string</code> field.  The <code>BinaryReader</code> class comes with a number of <code>Read</code> methods for each of the available data types and we have to use the right one at the right time.</p> <p>Some of the methods available include:</p> <ul> <li><code>ReadString()</code></li> <li><code>ReadInt32()</code></li> <li><code>ReadDouble()</code></li> <li><code>ReadBoolean()</code></li> </ul> <p>With each <code>Read()</code> the file pointer advances the correct number of bytes ready to read the next item from the file.  Thus calling a <code>ReadBoolean()</code> when we need to use <code>ReadInt32()</code> will only advance the pointer one byte rather than the required four and we will end up with a mess!</p> <p>Here's the sample code for reading our book data from our newly created file and prints it to the screen:</p> <pre><code>BinaryReader br = new BinaryReader(File.OpenRead(filename));\n\nusing(br)\n{\n    willows.Id = br.ReadInt32();\n    willows.Title = br.ReadString();\n    willows.Author = br.ReadString();\n    willows.Price = br.ReadDouble();\n    willows.Year = br.ReadInt32();                \n}\n\nConsole.WriteLine($\"Id:     {willows.Id}\");\nConsole.WriteLine($\"Title:  {willows.Title}\");\nConsole.WriteLine($\"Author: {willows.Author}\");\nConsole.WriteLine($\"Price:  \u00a3{willows.Price}\");\nConsole.WriteLine($\"Year:   {willows.Year}\");\n</code></pre> <p>In theory there are ways to read the entire <code>struct</code> in one go but it's tricky and not recommended.  It's far preferable to read the data field by field as above.</p> <p>These two samples could both be put into their own methods:</p> <pre><code>static void WriteBinaryFile(Book book)\n{\n    //\n}\n\nstatic Book ReadBinaryFile()\n{\n    //\n    return book;\n}\n</code></pre> <p>As with text files, you are strongly recommended to handle exception errors if the file cannot be found, or opened etc..</p> <p>The Microsoft documentation has a good summary of all types of file handling available via the <code>System.IO</code> namespace:  https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms404278(v=vs.100)?redirectedfrom=MSDN.</p>"},{"location":"chapters/12_binary_files/02_xml_files/","title":"XML files","text":"<p>As noted earlier binary files are falling out of favour and being replaced by either XML or JSON for transferring, storing, data.  Both are human readable, they are a form of text file therefore but we'll finish our exploration of file handling with each of these types of file.</p> <p>XML is short for Extensible Markup Language and is widely used in exchanging data.  It's easily readable by both machines and humans and imposes a structure on the data.</p> <p>Using our book example from earlier, the XML file for this data may look like the following, with capacity for several books to be defined in a collection of books:</p> <pre><code>&lt;books&gt;\n    &lt;book id=\"1\"&gt;\n        &lt;title&gt;Wind in the Willows&lt;/title&gt;\n        &lt;author&gt;Kenneth Grahame&lt;/author&gt;\n        &lt;price&gt;14.99&lt;/price&gt;\n        &lt;year&gt;1908&lt;/year&gt;\n    &lt;/book&gt;\n&lt;/books&gt;\n</code></pre> <p>It looks very similar to HTML used for web pages. It consists of tags, <code>&lt; ... &gt;</code>, attributes, e.g <code>id = \"1\"</code> (which must be in quotes), and values.  It is structured like a tree with a root element (<code>&lt;books&gt;</code>) and branches to child elements (<code>&lt;book&gt;</code>) which in turn has further child elements (<code>&lt;title&gt;</code>).  The tags must be closed, <code>&lt;/title&gt;</code>, with the backslash before the element name and they are case-sensitive.</p> <p>The format is easy to read and C# comes with a number of built-in classes and methods for handling files using the XML format via the <code>System.xml</code> namespace.</p> <p>There are some important classes:</p> <ul> <li><code>XmlDocument</code>: reads in the entire XML file</li> <li><code>XmlReader</code>: reads in the XML file one element at a time</li> <li><code>XmlWriter</code>: writes out the entire document</li> </ul> <p>They function similarly to the classes we've used already for file handling.</p>"},{"location":"chapters/12_binary_files/02_xml_files/#writing-to-xml-files","title":"Writing to XML files","text":"<p>We must include the namespace <code>using System.xml</code> at the top of our program.</p> <pre><code>static void Main(string[] args)\n{\n    Console.WriteLine(\"XML files\");\n    Book willows = new Book(1,\"Wind in the Willows\",\"Kenneth Grahame\",14.99,1908);\n\n    using(XmlWriter xmlWriter = XmlWriter.Create(\"books.xml\"))\n    {\n        xmlWriter.WriteStartDocument();\n        xmlWriter.WriteStartElement(\"books\");\n\n        xmlWriter.WriteStartElement(\"book\");\n        xmlWriter.WriteAttributeString(\"id\", willows.Id.ToString());\n\n        xmlWriter.WriteStartElement(\"title\");\n        xmlWriter.WriteString(willows.Title);\n        xmlWriter.WriteEndElement();\n\n        xmlWriter.WriteStartElement(\"author\");\n        xmlWriter.WriteString(willows.Author);\n        xmlWriter.WriteEndElement();\n\n        xmlWriter.WriteStartElement(\"price\");\n        xmlWriter.WriteString(willows.Price.ToString());\n        xmlWriter.WriteEndElement();\n\n        xmlWriter.WriteStartElement(\"year\");\n        xmlWriter.WriteString(willows.Year.ToString());\n        xmlWriter.WriteEndElement();\n\n        xmlWriter.WriteEndDocument();\n    }\n}\n</code></pre> <p>We create the <code>XmlWriter</code> object using the <code>Create()</code> method and pass in the name of the file.  Then we have to start the document calling <code>WriteStartDocument()</code>. This is then followed by the elements in the order of the element tree starting with the root and then each of the child elements following.  Where there is an attribute we use <code>WriteAttributeString()</code>.  Notice, the XML file is text so all not-text data items need to be converted to strings before they can be written.  Each child element needs to be closed using <code>WriteEndElement()</code> before writing the next child element.  Finally, we indicate the end of the document <code>WriteEndDocument()</code> and close the file <code>Close()</code>.</p>"},{"location":"chapters/12_binary_files/02_xml_files/#reading-from-xml-files","title":"Reading from XML files","text":"<p>We reverse the process when reading from an XML file using the <code>Read()</code> method of the <code>XmlTextReader</code> class:</p> <pre><code>using (XmlReader xmlReader = XmlReader.Create(\"books.xml\"))\n{\n    while (xmlReader.Read())\n    {\n        if (xmlReader.IsStartElement())\n        {\n            switch (xmlReader.Name.ToString())\n            {\n                case \"title\":\n                    Console.WriteLine(\"Title: \" + xmlReader.ReadString());\n                    break;\n                case \"author\":\n                    Console.WriteLine(\"Author: \" + xmlReader.ReadString());\n                    break;\n                case \"price\":\n                    Console.WriteLine(\"Price: \" + xmlReader.ReadString());\n                    break;\n                case \"year\":\n                    Console.WriteLine(\"Year: \" + xmlReader.ReadString());\n                    break;\n            }\n        }\n    }\n}\n</code></pre> <p>A reference to the <code>xmlReader</code> object is created with the filename as a parameter.  The <code>Read()</code> method starts to read from the file and returns a boolean value if there is an XML statement to read or not, if there is we enter the loop. If we have a <code>StartElement()</code> we proceed to read.  There are a number of such elements in our XML file so we put this into a <code>switch</code> block determined by the name of the element.  We're printing to the screen so for each <code>ReadString()</code> is used.</p> <p>A single book is not that useful.  We can use an array of books (or a <code>List&lt;Book&gt;()</code>):</p> <pre><code>Book[] books = new Book[2]\n{\n    new Book(1,\"Wind in the Willows\",\"Kenneth Grahame\",14.99,1908),\n    new Book(2, \"Alice in Wonderland\",\"Lewis Carroll\",9.99,1865)\n};\n</code></pre> <p>The <code>XmlReader</code> section does not need to be changed but when writing each element we need to iterate through the array:</p> <pre><code>for(int i = 0; i &lt; books.Length; i++)\n{\n    xmlWriter.WriteStartElement(\"book\");\n    xmlWriter.WriteAttributeString(\"id\", books[i].Id.ToString());\n\n    xmlWriter.WriteStartElement(\"title\");\n    xmlWriter.WriteString(books[i].Title);\n    xmlWriter.WriteEndElement();\n\n    xmlWriter.WriteStartElement(\"author\");\n    xmlWriter.WriteString(books[i].Author);\n    xmlWriter.WriteEndElement();\n\n    // etc...\n}\n</code></pre>"},{"location":"chapters/12_binary_files/03_serialization/","title":"Serialization","text":"<p>An alternative approach to reading and writing with XML files (and other types of file) is to use serialization.  </p> <p>Serialization converts an object (or struct) into a stream of bytes, this can then be reversed using deserialization.</p> <p>Serialization comes in two \"flavours\": Binary and Human Readable.  For the former we'd use the <code>BinaryFormatter</code> class, and for the latter <code>XmlSerializer</code> (or <code>JsonSerializer</code>).  Microsoft no longer recommends using <code>BinaryFormatter</code> (see here) so we're not going to cover its use.  They do recommend <code>XmlSerializer</code>, <code>BinaryWriter</code> and <code>BinaryReader</code> and the Json API.  It's also the preferred method for saving objects, and structs, to files so it's worth understanding how serialization works.</p> <p>C# comes with a namespace for XML serialization <code>System.Xml.Serialization;</code> so to access the methods this must be included as a <code>using</code> statement at the top of your program.</p> <pre><code>Book book = new Book();\nbook.Id = 1;\nbook.Title = \"Wind in the Willows\";\nbook.Author = \"Kenneth Grahame\";\nbook.Price = 9.99;\nbook.Year = 1908;\n\nXmlWriter writer = XmlWriter.Create(\"books.xml\");\nXmlSerializer serializer = new XmlSerializer(typeof(Book));\nserializer.Serialize(writer, book);\nwriter.Flush();\nwriter.Close();\n\nXmlReader reader = XmlReader.Create(\"books.xml\");\nbook = (Book)serializer.Deserialize(reader);\nConsole.WriteLine(book.Title);\nConsole.WriteLine(book.Author);\nConsole.WriteLine(book.Price);\nConsole.WriteLine(book.Year);\n</code></pre> <p>This code illustrates the process of writing and reading using the <code>XmlSerializer</code> class.  It's more straightforward than the previous example.  </p> <p>Having initialised a <code>book</code> with default values we open the <code>books.xml</code> file with the <code>XmlWriter</code> object.  We need to tell the serializer object the data type we are serializing so when creating the <code>XmlSerializer</code> object we pass it the book type using the <code>typeof()</code> method.  Calling the <code>Serialize()</code> method is all we need, passing it the <code>writer</code> and <code>book</code> as parameters.  </p> <p>As with all writing to file methods the stream must be closed.</p> <p>Reading back the serialized object (struct) is just the reverse process, this time using the <code>XmlReader</code> class.  We need to cast what is being read back as a <code>Book</code> object.</p> <p>Note</p> <p>For this code to work extract the definition of the <code>Book</code> struct and move to a new file in the project directory, and ensure the namespace is the same as for your main program.  The reason is that structs (or classes) defined in the main program file are <code>private</code> to that file and the <code>Serialize()</code> method only works with public structures.</p> <p>We'll see the same process being used for JSON files in the next section.</p>"},{"location":"chapters/12_binary_files/04_json_files/","title":"JSON files","text":"<p>JavaScript Object Notation (JSON) is another standard for representing structured data.  It's similar in that sense to XML but the syntax used is different.  It is shorter and people often find it easier to read though, of course, it's not really meant to be read by humans.</p> <p>To illustrate the process we'll extend our Books system by storing a number of books in a List structure, we could use an array but the <code>List</code> gives us more flexibility.  As we saw earlier the <code>List&lt;T&gt;</code> is a collection of items, the item data type represented by <code>&lt;T&gt;</code> here, held in a particular order which can be accessed using an index.  It's similar in that sense to an <code>array</code> but the the size of the List does not have to be declared so it can grow and shrink as new items are added or removed i.e. it is a dynamic data structure.  To use the <code>List&lt;T&gt;</code> include the <code>System.Collection.Generic</code> namespace.</p> <p>The list is initialised and a new book added to the list with the following statements:</p> <pre><code>List&lt;Book&gt; Books = new List&lt;Book&gt;();\nBooks.Add(new Book(1,\"Wind in the Willows\",\"Kenneth Grahame\",14.99,1908));\n</code></pre> <p>We'll create several books and add them to the list:</p> <pre><code>Books.Add(new Book(1,\"Wind in the Willows\",\"Kenneth Grahame\",14.99,1908));\nBooks.Add(new Book(2,\"Alice in Wonderland\",\"Lewis Carroll\",9.99,1895));\nBooks.Add(new Book(3,\"Treasure Island\",\"R.L.Stevenson\",14.99,1883));\nBooks.Add(new Book(4,\"Oliver Twist\",\"Charles Dickens\",9.99,1838));\nBooks.Add(new Book(5,\"Moby Dick\",\"Herman Melville\",2.99,1851));\nBooks.Add(new Book(1,\"Frankenstein\",\"Mary Shelley\",4.99,1818));\n</code></pre> <p>Using a method this time we can save this list of books to a JSON file with the following code calling on the <code>JsonSerializer</code> class method to serialize our data:</p> <pre><code>static void SaveAll(List&lt;Book&gt; books, string filename)\n{\n    using (StreamWriter writer = new StreamWriter(filename))\n    {\n        var options = new JsonSerializerOptions { WriteIndented = true };\n        string json = JsonSerializer.Serialize(books, options);\n        writer.Write(json);\n        writer.Flush();\n    }\n}\n</code></pre> <p>This is similar to the <code>XmlSerializer</code>, though we've additionally passed an option to the <code>JsonSerializer</code> method to indent the output.  The <code>Serialize</code> method returns a string which we then write to the stream.</p> <p>Our newly created JSON file will be:</p> <pre><code>[\n  {\n    \"Id\": 1,\n    \"Title\": \"Wind in the Willows\",\n    \"Author\": \"Kenneth Grahame\",\n    \"Price\": 14.99,\n    \"Year\": 1908\n  },\n  {\n    \"Id\": 2,\n    \"Title\": \"Alice in Wonderland\",\n    \"Author\": \"Lewis Carroll\",\n    \"Price\": 9.99,\n    \"Year\": 1895\n  },\n  {\n    \"Id\": 3,\n    \"Title\": \"Treasure Island\",\n    \"Author\": \"R.L.Stevenson\",\n    \"Price\": 14.99,\n    \"Year\": 1883\n  },\n  {\n    \"Id\": 4,\n    \"Title\": \"Oliver Twist\",\n    \"Author\": \"Charles Dickens\",\n    \"Price\": 9.99,\n    \"Year\": 1838\n  },\n  {\n    \"Id\": 5,\n    \"Title\": \"Moby Dick\",\n    \"Author\": \"Herman Melville\",\n    \"Price\": 2.99,\n    \"Year\": 1851\n  },\n  {\n    \"Id\": 6,\n    \"Title\": \"Frankenstein\",\n    \"Author\": \"Mary Shelley\",\n    \"Price\": 4.99,\n    \"Year\": 1818\n  }\n]\n</code></pre> <p>We reverse the process, this time using a <code>Load()</code> method, when reading from the JSON file, making sure the <code>Deserialize()</code> method knows the format of the data we are retrieving:</p> <pre><code>static List&lt;Book&gt; Load(string filename)\n{\n    using(StreamReader reader = new StreamReader(filename))\n    {\n        string json = reader.ReadToEnd();\n        return JsonSerializer.Deserialize&lt;List&lt;Book&gt;&gt;(json);\n    }\n}\n</code></pre> <p>Note</p> <p>To get the code to work we need to convert the fields of our <code>Book</code> struct into properties.  A property is a member of a class (or struct) that include accessor methods, that is \"getters\" and \"setters\".  Compare the following where a field is declared, and then a property:</p> <pre><code>public struct Person\n{\n    public string firstName;        // a humble field\n    public int age { get; set; }    // a property\n}\n</code></pre> <p>To ensure the <code>JsonSerializer</code> picks up the member fields as properties our <code>Book</code> struct has to be defined as:</p> <pre><code>public struct Book\n{\n        public int Id { get; set;}\n        public string Title { get; set;}\n        public string Author { get; set;}\n        public double Price { get; set;}\n        public int Year { get; set;}\n\n        public Book(int id, string title, string author, double price, int year)\n        {\n            Id = id;\n            Title = title;\n            Author = author;\n            Price = price;\n            Year = year;\n        }        \n}\n</code></pre> <p>The serialize methods (both <code>XmlSerializer</code> and <code>JsonSerializer</code>) are powerful classes with many more methods and properties and the above discussion just scratches the surface of each.</p> <p>Also ... they simplify the process of writing and reading to files significantly and avoid the vagaries of <code>BinaryWriter</code> and <code>BinaryReader</code>.  Though, of course, they are not binary files, but when working with <code>struct</code>s, or classes as we will later serialization is the way to go.</p>"},{"location":"chapters/12_binary_files/05_programming_task/","title":"Programming Task - Running Club revised","text":""},{"location":"chapters/12_binary_files/05_programming_task/#running-club","title":"Running Club","text":"<p>Rewrite the running club program from the last chapter but this time read/write all data to a JSON (or XML) file using serialization.</p> <p>Create a separate file to hold the Member struct (this must be wrapped in the same <code>namespace</code> as your main program file):</p> <pre><code>public struct Member\n    {\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        public string Distance { get; set; }\n    }\n</code></pre> <p>Present the user with a menu of options:</p> <pre><code>Console.Clear();\nConsole.WriteLine(\"MAIN MENU\\n\");\nConsole.WriteLine(\"1 - Add Member\");\nConsole.WriteLine(\"2 - Show Members\");\nConsole.WriteLine(\"3 - Search for Member\");\nConsole.WriteLine(\"4 - Save All\");\nConsole.WriteLine(\"5 - QUIT\");\nConsole.Write(\"&gt; \");\nmenuOption = Convert.ToInt32(Console.ReadLine());\n</code></pre> <p>Use a <code>switch</code> to select one of the options.  Each option should call a relevant method to handle the option.</p>"},{"location":"chapters/12_binary_files/05_programming_task/#todo-manager","title":"Todo Manager","text":"<p>Chapter 11 included code to implement a simple task manager.  Adapt and extend this code to read and write data from the JSON file using serialization.  Create a <code>struct</code> for the task in the project directory (e.g. <code>taskItem.cs</code>).</p> <p>Extend the program to include:</p> <ul> <li><code>Boolean</code> field to indicate if the task has been completed</li> <li>A Category field e.g. \"Home\", \"College\".  Choose categories that suit your own circumstances</li> <li>Provide an option for the user to select only those tasks from a given category</li> </ul>"},{"location":"chapters/12_binary_files/06_questions/","title":"Questions","text":"<p>// TODO</p> <ol> <li>What is the difference between the way data is stored in a text file and the way data is stored in a binary file?</li> </ol>"},{"location":"chapters/12_binary_files/06_questions/#additional-exercises","title":"Additional exercises","text":"<p>// TODO</p>"},{"location":"chapters/12_binary_files/07_networking/","title":"Extended Theory - Networking","text":"<p>So much of our current work with computers relies on communicating with remote devices either on a local network or through the Internet.  As you'd probably expected C# comes with namespaces, <code>System.Net</code> and <code>System.Net.Protocols</code>, containing various classes for managing network communication for the many protocols used on current networks.  For each of the following examples it is assumed the computer being used is connected to a network.</p> <p>Network programming is a big topic, employing a lot of different protocols coupled with issues related to security, encryption and various types of communications channels etc. so we can only scratch the surface here.  However, the principle is just to use a computer network to transfer information between applications. It's an I/O stream of data as we've seen in this and the preceding chapter except the stream of data is between nodes on the network.</p>"},{"location":"chapters/12_binary_files/07_networking/#ip-addresses-and-domain-names","title":"IP Addresses and domain names","text":"<p>Every computer connected to the Internet is allocated a unique address, an IP address (Internet Protocol). Its a \\(32\\)-bit (IPv4) or \\(128\\)-bit (IPv6) number usually expressed in dotted quad notation i.e. 192.168.1.1, 216.58.210.195 where each part is an \\(8\\)-bit number (a byte). IP addresses are assigned by the Internet Service Provider but managed globally by the Internet Assigned Numbers Authority.</p> <p>You can use the following C# code to get the IP address of your machine:</p> <pre><code>using System;\nusing System.Net;\n\nnamespace getIpAddress\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string hostname = Dns.GetHostName();\n            string myIp = Dns.GetHostEntry(hostname).AddressList[0].ToString();\n            Console.WriteLine($\"{hostname} : {myIp}\");\n        }\n    }\n}\n</code></pre> <p>These numbers, the IP addresses, are not easy to remember so a naming system was introduced: Domain Name System (DNS). The main function of DNS is to translate easier to remember domain names such as <code>bbc.co.uk</code> or <code>hillsroad.ac.uk</code> into their IP address. Think of it like a phone book for the Internet. It is a distributed database which keeps track of domain names and their associated IP addresses. There is not one database but several and they are organised into hierarchies best visualised as a tree structure. The path through this tree is shown through the full stops in the domain name.</p> <p>The previous example can be modified to retrieve the IP address of any given domain, again using the <code>Dns</code> class from the <code>System.Net</code> namespace:</p> <pre><code>using System;\nusing System.Net;\n\nnamespace getIpAddress\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string hostname = \"bbc.co.uk\";\n            IPHostEntry host = Dns.GetHostEntry(hostname);\n            Console.WriteLine($\"{hostname.ToUpper()}: \");\n            foreach(IPAddress address in host.AddressList)\n            {\n                Console.WriteLine($\"    {address}\");\n            }\n        }\n    }\n}\n</code></pre> <p>In our examples, we'll be using a special IP address, the localhost, <code>127.0.0.1</code>, which refers to your local computer so our programs will run without needing to be connected to a network for real, it's simulating a network on your local machine.  However, they will still work if your have to another machine on a network and know its IP address, and if not located on your local area network you have access through that network's firewall.</p>"},{"location":"chapters/12_binary_files/07_networking/#tcpip","title":"TCP/IP","text":"<p>The Transmission Control Protocol/Internet Protocol (TCP/IP) is the set of rules ensuring communication for devices on the Internet. It determines how data should be packaged, transmitted and received as well as how the data makes its way to its destination. The term protocol means, variously, a code of conduct or even the etiquette observed by foreign diplomats, a protocol sets out the way things are to be done and how the business of communication between two parties should be carried out.</p> <p>Strictly speaking TCP/IP is a suite of protocols including:</p> <ul> <li>HTTP:  HyperText Transfer Protocol for the world wide web (using HTML)</li> <li>FTP:  File Transfer Protocol for transferring files between devices</li> <li>SMTP: Simple Mail Transfer Protocol for sending email messages</li> <li>POP3: Post Office Protocol for downloading email messages</li> <li>etc..</li> </ul> <p>There's insufficient space to explore TCP/IP in depth and its layered architecture but it's worth stating the principles that governed its invention:</p> <ul> <li>Network connectivity: any network can connect to any other network via a gateway or router</li> <li>Distribution: there would be no central network administration or control</li> <li>Error recovery: lost packets of data would be retransmitted</li> <li>Black box design: no internal changes to a network to allow it to connect to another</li> </ul>"},{"location":"chapters/12_binary_files/07_networking/#client-and-servers","title":"Client and Servers","text":"<p>The classic model when interacting with devices on a network, including those using TCP/IP, is one of <code>client-server</code>.  For example, in our browser we, the client, make a request to view a web page from a web server, or our email client asks a mail server to download our email messages etc..  It's a simple pattern where the server is \"listening\" for any incoming connections or requests and responding appropriately when that request arrives.</p> <p>For example, we can download a web page and save its contents to a file using the <code>WebClient</code> class:</p> <pre><code>using(var webClient = new WebClient())\n{\n    webClient.DownloadFile(\"https://stackoverflow.com/questions/tagged/network-programming\", \"se_networking.html\");\n}\n</code></pre> <p>As with other file handling wrapping the request in a <code>using</code> block ensures resources are released when finished.  Here we access the web using a <code>WebClient</code> class and request a web page using <code>DownloadFile()</code> method which takes the <code>Uniform Resource Identifier</code> and the name of a file to save the data to as parameters.</p>"},{"location":"chapters/12_binary_files/07_networking/#sockets","title":"Sockets","text":"<p>To make the connection between the client and server we need two pieces of information:</p> <ul> <li>the IP Address of the server</li> <li>the port on the server \"listening\" for requests from clients</li> </ul> <p>These two pieces of data form the socket.  Network I/O is based on the use of streams with sockets.  Think of the socket as an endpoint for processes communicating on a network.</p> <p>To write a client server application therefore we need two programs, the client and the server.  The client will communicate with the server via a socket and vice versa.  The socket uses an IP address and a port number (which usually determines the protocol to be used i.e. HTML, FTP etc).  Data sent on the Internet has to use the Internet Protocol which provides low level access to the suite of functionality required to effect data transfer via packets of data.</p> <p>The port is a \\(16\\) bit value that determines the protocol to be used for the communication.  It works as an identifier for a process, for example, when you have two web-pages open in your browser each will be assigned a different port number, similarly any email traffic is differentiated from web traffic using the assigned port number.  The range of ports between \\(0\\) and \\(1023\\) are reserved for well-known protocol services e.g. port \\(80\\) is used for HTTP.  The range between \\(1024\\) and \\(49151\\) are registered by specific software vendors leaving the remaining values to be used as private ports.  No two applications can use the same port.</p> Image caption <p>As in the diagram, messages get passed between the client and server machines through the network.  In C# this is handled by two classes, on the client side the <code>TcpClient</code>, and on the server side the <code>TcpListener</code> so called because it is listening for any inbound connections.  Each effects this transfer through the socket at the low level and data is passed to the socket through a stream which controls the flow of information between the client and the server.</p> <p>When you request a web page from a browser application your operating system will allocate a port.  This can be viewed from a terminal using the command <code>netstat -a</code>, this command will display all of the active sockets on your system.  If you're running a server, you need to specify its port number, the port number it is listening to for connections from clients which itself might be reaching out to make a connection with the server.  </p>"},{"location":"chapters/12_binary_files/07_networking/#the-server","title":"The Server","text":"<p>Thus for the server application, once the socket has been created it needs to be opened by using <code>Start()</code>, so it can begin to accept network communications.  When it is ready we call <code>AcceptSocket()</code>.  This method is a blocking method which means that no other machine can access the server while the current connection is active.  This can be solved by using threading but that will not be covered here.</p> <p>The socket only knows how to be an endpoint but not how to create and accept the connection, for this we need the <code>TcpListener</code> class which handles some of these higher level services.</p> <p>Thus, the code to create a socket, accept and handle connections on the server will be:</p> <pre><code>IPAddress myIp = IPAddress.Parse(\"127.0.0.1\");          // set up the IP address\nTcpListener listener = new TcpListener(myIp, 8080);     // and create the socket\nlistener.Start();                                       // start\nwhile(true)                                             // forever loop ...\n{\n    Socket socket = listener.AcceptSocket();            // listen for connections\n    // handle the incoming connection\n    if (socket.connected)                               // handle a connection\n    {\n        //\n    }\n}\n</code></pre> <p>Tip</p> <p>Make liberal use of <code>try ... catch</code> blocks.  For example, this code will throw an exception if the requested port is in use when we call <code>listener.Start()</code>.  It is advisable to wrap this inside a <code>try ... catch</code> block to handle the exception.</p> <p>As explained above, our server can now start to accept connections through this socket using the <code>AcceptSocket()</code> method.  Alternatively, we can call <code>TcpClient client = listener.AcceptTcpClient();</code>.  In practical terms there is no difference between the two, the latter is a wrapper for the Socket class.  </p> <p>Whichever is used our next stage is to get hold of the data being sent by the client.  As with reading and writing data to a file we employ a stream, this time a <code>NetworkStream</code> and then create a <code>StreamWriter</code> and a <code>StreamReader</code> on this class, passing it in as a parameter.  Now when we write to this stream it is sent via the network connection we've just established:</p> <pre><code>TcpClient client = listener.AcceptTcpClient();\n// Socket socket = listener.AcceptSocket();                     // or use this method\nConsole.WriteLine(\"Client connection accepted\");\nNetworkStream ns = client.GetStream();\n// NetworkStream socketStream = new NetworkStream(socket);      // or this call is using socket class\nStreamReader sr = new StreamReader(ns);\nStreamWriter sw = new StreamWriter(ns);\ntry\n{\n    byte[] buffer = new byte[1024];\n    ns.Read(buffer, 0, buffer.Length);\n    int received = 0;\n    foreach (byte b in buffer)\n    {\n        if (b != 0) received++;\n    }\n    string request = Encoding.ASCII.GetString(buffer, 0, received);\n    Console.WriteLine(\" &gt;&gt; Client said \" + request);\n    sw.WriteLine($\"Hello, thank you for your message (\\\"{request}\\\")\");\n    sw.WriteLine(\"Goodbye\");\n    sw.Flush();\n\n}\ncatch (Exception e)\n{\n    Console.WriteLine(\"Something went wrong\");\n    sw.WriteLine(e.Message);\n}\n</code></pre> <p>Our data, sent by a client, will be a sequence of bytes, and they will be transmitted in a series of packets.  Clearly, we need to grab these bytes and put them somewhere for subsequent processing.  We set up a byte array, estimating the amount of data being sent which in this case is \\(1024\\) bytes.  We call the <code>Read</code> method on the network stream and assign the bytes read to the byte array.  Our next <code>foreach</code> loop keeps a count of the number of bytes read.</p> <p>The next step is to convert that data into a usable format to display using the <code>Encoding.ASCII.GetString()</code> method, (the encoding might also be <code>UTF8</code> etc..).</p> <p>The final lines write some data back to the client using the <code>StreamWriter</code> class.  This is identical to using <code>Console.WriteLine()</code> or its use when writing to a file etc, except now we're writing to the <code>NetworkStream</code>.  In this trivial example we send a message back to the client, with a copy of what was received by the server.</p>"},{"location":"chapters/12_binary_files/07_networking/#the-client","title":"The Client","text":"<p>For the client side application there are some similar steps. We need the socket and a <code>TcpClient</code>:</p> <pre><code>TcpClient clientSocket = new TcpClient();\nclientSocket.Connect(\"127.0.0.1\", 8080);\n</code></pre> <p>This can be combined into one statement:</p> <pre><code>TcpClient client = new TcpClient(\"127.0.0.1\", 8080);\n</code></pre> <p>Next we need to set up the stream, a <code>NetworkStream</code> which, as for the server, can use <code>StreamWriter</code> and <code>StreamReader</code> classes.  When we pass a message to the <code>Write()</code> method it will send the data as a sequence of bytes to the designated server:</p> <pre><code>Console.Write(\"Enter text to send to the server: \");\nstring message = Console.ReadLine();\nNetworkStream ns = client.GetStream();\nStreamWriter sw = new StreamWriter(ns);\nsw.Write(\"I am your client\");\nsw.Flush();\nConsole.WriteLine(\"Sending message to the server\");\n</code></pre> <p>Note</p> <p>The <code>NetworkStream</code> class has its own <code>Write()</code> method, it takes a byte array as a parameter so if using this class we'd need to convert our string into a byte array first, e.g.</p> <pre><code>TcpClient client = new TcpClient(\"127.0.0.1\", 8080);\nConsole.Write(\"Enter text to send to the server: \");\nstring message = Console.ReadLine();\nint byteCount = Encoding.ASCII.GetByteCount(message + 1);\nbyte[] dataToSend = Encoding.ASCII.GetBytes(message);\nNetworkStream ns = client.GetStream();\nns.Write(dataToSend, 0, dataToSend.Length);\nConsole.WriteLine(\"Sending message to the server\");\n</code></pre> <p>Finally, the client can read data sent from the server using the <code>StreamReader</code> class:</p> <pre><code>StreamReader sr = new StreamReader(ns);\nstring response = sr.ReadLine();\nConsole.WriteLine(response);\nns.Close();\nclient.Close();\n</code></pre> <p>As a final example, here is the code for both a client and a server illustrating a moderately more complex use case, in this case the client will send a command to the server and some data for the server to process, depending on the command used.  The command is given on the command line when the client is called e.g. <code>simpleClient /u \"Hello World\"</code>.  The command is the <code>/u</code> which when received by the server will upper case the string provided and return that back to the client.</p> <p>The client:</p> <pre><code>using System;\nusing System.Net.Sockets;               // the socket library\nusing System.IO;\n\npublic class Connect\n{\n    static void Main(string[] args)\n    {\n        // open a connection to the server (localhost, port 8080)\n        TcpClient clientSocket = new TcpClient();\n        clientSocket.Connect(\"127.0.0.1\", 8080);\n        NetworkStream ns = clientSocket.GetStream();\n        // need to send and receive data to and from the server\n        StreamWriter sw = new StreamWriter(ns);\n        StreamReader sr = new StreamReader(ns);\n        // check the arguments supplied by the user\n        if (args.Length == 1)\n        {\n            // /n a NOOP, no operation\n            if (args[0] == \"/n\")\n            {\n                sw.WriteLine(\"NOOP\");\n            }\n            else\n            {\n                Console.WriteLine(\"Unrecognised command\");\n                return;\n            }\n        } else if (args.Length == 2)\n        {\n            switch (args[0])\n            {\n                // echo the string back\n                case \"/e\":\n                    sw.WriteLine(\"ECHO \" + args[1]);\n                    break;\n                // upper case the string and send it back\n                case \"/u\":\n                    sw.WriteLine(\"UPPER \" + args[1]);\n                    break;\n                default:\n                    Console.WriteLine(\"Unrecognised command\");\n                    return;\n            }\n        }\n        else\n        {\n            Console.WriteLine(\"Wrong number of arguments\");\n            return;\n        }\n        sw.Flush();\n        string response = sr.ReadToEnd().Trim();\n        if (response == \"\")\n        {\n            Console.WriteLine(\"SERVER: No response\");\n        }\n        else\n        {\n            Console.WriteLine($\"SERVER: {response}\");\n        }\n        Console.WriteLine();\n        clientSocket.Close();\n    }\n}\n</code></pre> <p>The server:</p> <pre><code>using System;\nusing System.Net;\nusing System.Net.Sockets;               // the socket library\nusing System.IO;\n\npublic class SimpleServer {\n\n    static void Main(string[] args) \n    {\n        runServer();\n    }\n\n    static void runServer()\n    {\n        try { \n            // create a new listener on port 8080\n            IPAddress myIp = IPAddress.Parse(\"127.0.0.1\");\n            TcpListener listener = new TcpListener(myIp, 8080);\n            // start to listen on designated port\n            listener.Start();\n            Console.WriteLine(\"Listening for connections on port 8080 ....\");\n            while (true)\n            {\n                Socket socket = listener.AcceptSocket();\n                // all requests and responses travel via this stream\n                if (socket.Connected)\n                {\n                    NetworkStream socketStream = new NetworkStream(socket);\n                    Console.WriteLine(\"Connection received\");\n                    // Handle the input\n                    doRequest(socketStream);\n                    // request is complete so close the connection\n                    socketStream.Close();\n                    socket.Close();\n                }\n                Console.WriteLine(\"Connection closed ... server still running (Ctrl-C to quit) ...\");\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n        }\n    }\n\n    static void doRequest(NetworkStream socketStream)\n    {\n        try\n        {\n            // handle the socket I/O\n            // assumed data will be ASCII text (no need for byte arrays)\n            StreamWriter sw = new StreamWriter(socketStream);\n            StreamReader sr = new StreamReader(socketStream);\n            // read a line from the stream reader, trim off any line feed\n            string line = sr.ReadLine().Trim();\n            // split message into words received\n            String[] parts = line.Split(new char[] { ' ' }, 2);\n            // respond according to the message received\n            switch (parts[0])\n            {\n                case \"NOOP\":\n                    Console.WriteLine(\"Command: NOOP received\");\n                    break;\n                case \"ECHO\":\n                    Console.WriteLine(\"Command: ECHO received\");\n                    Console.WriteLine($\"Sending: {parts[1]}\");\n                    sw.WriteLine(parts[1]);\n                    sw.Flush();\n                    break;\n                case \"UPPER\":\n                    Console.WriteLine(\"Command: UPPER received\");\n                    string msg = parts[1].ToUpper();\n                    Console.WriteLine($\"Sending: {msg}\");\n                    sw.WriteLine(msg);\n                    sw.Flush();\n                    break;\n                default:\n                    Console.WriteLine(\"Unrecognised command\");\n                    break;\n\n            }\n        }\n        catch\n        {\n            Console.WriteLine(\"Something went wrong\");\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/13_project/","title":"Putting it into Practice","text":"<p>We've come a long way!  Time now to tackle a larger problem that will call on all of what has been covered thus far.  Before getting into the brief though we'll look at an approach to tackling any larger problem from scratch.</p> <ol> <li>Resist the temptation to start coding too quickly.  Time should be spent thinking about the problem to be solved and using pen and paper make notes, diagrams, calculations as needed etc..  Sketch out sample solutions and work through the solution in the same way a computer might to convince yourself it is a good solution.</li> <li>What problem is the program going to solve?  List the objectives of the problem.</li> <li>List both the inputs to the program, and the outputs.  What data, and what type of data, is needed.  The list is the data dictionary.  Does data need to be saved to a file?  What format should that be?</li> <li>Can the data be organised into structures?  That is, arrays or structs etc..</li> <li>Break the problem down into smaller sub-problems, and as needed break these sub-problems down into sub-sub-problems!  This will reveal the required methods.  Again, make a list of these noting their signature (i.e. their name and any parameters required).</li> <li>Create a structure/hierarchy diagram to show how the methods connect with each other</li> <li>Sketch out the algorithm for each of these methods.  This needn't (and probably shouldn't) use C# just use a form of pseudocode, structured English, or flowcharts (or a combination).</li> <li>Design the user interface.  We're in console mode at the moment so it'll be text but will you need different screens showing different information?  Plan them, and draw them.  What is the purpose for each screen?</li> <li>How can you test if your program, or method, is functioning correctly?  What tests should be used to prove this?  Don't forget validation of inputs and handling of exceptions.  Just because you ask the user to enter a 'Y', does not mean they will!</li> <li>Once all these things have been considered you're in a position to start implementing.  Write the code step by step, testing each new method you write as you go, adding in new functionality gradually working your way through the list of required methods.</li> <li>Remember the maxim: \"If you fail to plan, you're planning to fail\"</li> </ol> <p>Go to the next section to start the project.</p>"},{"location":"chapters/13_project/01_scenario/","title":"The Scenario","text":"<p>BattleShip is a turn based strategy game where players eliminate their opponents fleet of boats by 'firing' at a location on a grid in an attempt to sink them. The first player to sink all of their opponents boats is declared the winner.  </p> <p>Each player has two eight by eight grids. The first, the Fleet Grid is used for their own battle boats, marked with a 'B' in the diagram:</p> Fleet Grid <p>The second is used to record any hits or misses placed on their opponent:</p> Target Tracker Grid <p>At the beginning of the game, players decide where they wish to place their fleet of five boats.  Once placed, players take it in turns to fire at a location on their opponent's board. They do this by stating the coordinates for their target. If a player hits their opponent's boat then this is recorded as a hit ('H'). If they miss then this is recorded as a miss ('M').  </p> <p>The game ends when a player's fleet of boats have been sunk. The winner is the player with boats remaining at the end of the game.</p> <p>You have been asked to design a BattleShip game where the player fights against the computer to try and defeat its fleet.</p>"},{"location":"chapters/13_project/02_design_tasks/","title":"Design Tasks","text":"<p>Go and get that pen and paper!</p> <p>What are your initial thoughts about the problem?  What data needs to be handled e.g. the playing grid(s), the coordinates for firing etc..?  How will that data be structured?  What algorithms do you expect will be required e.g. Fire(), DisplayGrid(), GetSquareToHit(), SaveGameState(), Quit() etc..</p> <p>There will be two players, each player will have their own grids and methods to e.g. <code>PlaceBoats()</code>, <code>Fire()</code> etc..  How might the <code>Player</code> be structured?</p> <ol> <li> <p>Create a flowchart of the game play. The first screen presented to the user should be the main menu where the user can choose from one of the following options:</p> </li> <li> <p>New Game</p> </li> <li>Resume Game</li> <li>Read Instructions</li> <li> <p>Quit Game</p> </li> <li> <p>Design the menu screen and implement it.  (Hints:  The user should always be taken back to the main menu following any of the options. Create method stubs for NewGame(), ResumeGame() etc and test your menu).</p> </li> <li> <p>Develop the part of the program in such a way that when \"New Game\" is selected, the player is presented with a blank fleet grid. The program should:</p> <ul> <li>Prompt the player to enter coordinates for each ship</li> <li>Check if a ship has already been placed in the specified location</li> <li>Display each ship on the fleet grid after each entry</li> <li>Only allow the player to enter five ship locations</li> </ul> <p>Tip</p> <p>There is scope here for creating a data structure (<code>struct</code>) to hold the player information including their name, their playing grid etc..  Remember though, a <code>struct</code> is a value data type, if you pass it into a method and want it to get updated you MUST use the <code>ref</code> parameter to pass it in by reference and not by value.</p> <p>Tip</p> <p>The columns are labelled by letter, A-H; the rows numerically.  This could be entered separately (i.e. \"Enter row &gt;\", \"Enter column &gt;\") or as one string. If the latter (which is easier for the user?) the row will need to separated from the column (e.g. <code>row = position[0];</code>).  But what about the column: a letter?  This needs to be converted into an integer representing the column number (A=0,B=1 etc..).  One approach, but not the only one, would be to create an array of the letters (<code>char[] colArray = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };</code>).  Then use the <code>IndexOf()</code> method to return the found position: <pre><code>char[] colArray = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' };\n// ...\nint col = Array.IndexOf(colArray,position[1]);\n</code></pre></p> <p>The rest of these requirements should be straightforward ... except ... validation of user input.  Did you think of this in your pen and paper planning? Not tricky but need to check they have entered a valid digit followed by a valid character.  One possibility would be use a regular expression.</p> </li> <li> <p>Develop the part of the program that randomly selects five unique locations for the computer's fleet. These locations should not be revealed to the player. NOTE: The computer's fleet will not be displayed to the user at any point in the game. For testing purposes it will be necessary to display the locations but these should not appear in the finished game.</p> <p>Tip</p> <p>Displaying the grid is used frequently.  There are 2 types of grid and two players.  Generalise this into one method that takes as parameters (a) the grid belonging to a particular player; (b) the player; and, optionally, (c) a label for the grid (e.g. \"FLEET GRID\", \"TARGET GRID\")</p> <p>Tip</p> <p>Consider using constants in your program.  This is useful for e.g. the number of rows and column, the \"playing pieces\" i.e. 'S' for a ship, 'H' for a hit etc..  These could be put into their own <code>struct</code> ... Then, should you wish to change the size of the grid, or the total number of ships to be placed, there is just one place to update rather than several.  Similarly, it may be appropriate to use an <code>enum</code> for the states of each square in the grid.</p> </li> <li> <p>Develop the part of the program that displays a blank target tracker for the player.</p> <p>Note</p> <p>This should be trivial if you've followed the earlier tip about displaying a grid.</p> </li> <li> <p>Develop the part of the program that allows the player to take their turn. The program should:</p> <ul> <li>Prompt for the target coordinates. NOTE: The program should not allow the player to select the same coordinates twice.  </li> <li>Check if the target is a hit or a miss</li> <li>If the target is a hit then an H should be displayed on the target tracker</li> <li>If the target is a miss then an M should be displayed on the target tracker</li> </ul> <p>Tip</p> <p>You've already asked the player for coordinates!  Remember, \"Don't Repeat Yourself\".  Looks like an opportunity for a method!  Here's a chance to learn something new:  tuples.  A tuple is a lightweight data structure used to group multiple data elements together:</p> <pre><code>    (int, double) tuple1 = (42, 2.57);\n</code></pre> <p>We can write a method that returns a tuple e.g.</p> <pre><code>    static (int,int) GetPosition()\n    {\n        // body of method\n        return (row, col);\n    }\n</code></pre> <p>This method can then be used whenever you ask the user for some coordinates. (Don't forget to validate the input too).</p> </li> <li> <p>Develop the part of the program that allows the computer to take its turn. The program should:</p> <ul> <li>Randomly generate target coordinates. NOTE: The program should not allow the computer to select the same location twice.</li> <li>Display the coordinates to the player.</li> <li>Check if the target is a hit or a miss.</li> <li>If the target is a hit then an H should replace the S on the player's fleet grid.  </li> <li>If the target is a miss then this should be recorded by the program. There is no need to display a miss on the player's fleet grid.</li> </ul> </li> <li> <p>Develop the part of the program that continues to play the game until there is a winner. A game has been won when a player has sunk all of their opponent's battle boats. The winner of the game should be displayed to the player.</p> </li> </ol>"},{"location":"chapters/13_project/03_challenge_tasks/","title":"Challenge task -  Resume a game","text":"<ol> <li> <p>Develop the part of the program that saves the progress of the game externally. Progress should be saved after each turn. If the player closes the game window (stops the execution) then all progress should be saved.</p> <p>Note</p> <p>Saving the state of the game at the end of each turn is straightforward (<code>SaveGame()</code> method that saves the data for both the player and the computer to a file, simplest is a text file depending on your implementation) but do we need to consider it the game stops when the player is only part-way through entering a co-ordinate?  Easiest here to make an assumption that turn is lost ...</p> </li> <li> <p>Develop the part of the program in such a way that when \"resume a game\" is selected, the player is presented with their progress from their previous game. The game should continue from this point.  </p> <p>Note</p> <p>We can make no assumptions about whose turn is next when the game resumes (though depending on your implementation the computer will go straight after the human player and it'll be quick, returning control back to the human player).  Do we need a variable holding e.g. <code>currentPlayer</code>?</p> </li> </ol>"},{"location":"chapters/13_project/04_further_challenge/","title":"Further challenge task -  Allow for a variety of ships","text":"<ol> <li> <p>Extend the game so that the user can play a version of the game that uses a variety of ships.  The ships will come in three categories:</p> <ul> <li>2 x Destroyers (1 cell)</li> <li>2 x Submarines (2 cells)</li> <li>1 x Carrier (3 cells)</li> </ul> <p>The boats can be placed horizontally or vertically.</p> <p> New Fleet </p> </li> <li> <p>To allow for varying boat sizes. Develop the program so that it now checks for a hit, a miss and a sunken boat. The boat will only sink if all parts of the boat have been hit.</p> </li> </ol>"},{"location":"chapters/14_appendix/A1_UsefulResources/","title":"Appendix 1 - Useful Resources","text":"<p>The following is a list of resources you may find useful to enhance your study of both programming in general, and C# in particular.</p>"},{"location":"chapters/14_appendix/A1_UsefulResources/#software","title":"Software","text":"<ul> <li>Visual Studio Code</li> <li>Visual Studio Community Edition</li> <li>GitHub Desktop</li> </ul>"},{"location":"chapters/14_appendix/A1_UsefulResources/#books","title":"Books","text":"<ul> <li>The Yellow Book - Rob Miles</li> <li>C# Essentials</li> <li>C# Notes for Professionals</li> </ul>"},{"location":"chapters/14_appendix/A1_UsefulResources/#video-tutorials","title":"Video Tutorials","text":"<p>There are a lot of C# tutorials available on YouTube.  Tim Corey's series is among the best.</p> <ul> <li>I Am Tim Corey</li> <li>C# Basics in 1 hour (Mosh)</li> </ul> <p>Microsoft Virtual Academy - also a great resource:</p> <p>Microsoft Virtual Academy</p>"},{"location":"chapters/14_appendix/A1_UsefulResources/#online-text-tutorials","title":"Online (Text) Tutorials","text":"<ul> <li>https://www.learncs.org/</li> <li>C# Station</li> <li>Codecademy</li> </ul>"},{"location":"chapters/14_appendix/A2_Solutions/","title":"Appendix 2 - Sample solutions","text":"<p>This appendix contains sample code listings for the exercises referenced in the text.  They are to be regarded as examples of possible solutions and not definitive.  When programming a solution there is often more than one way to arrive at a workable answer.</p> <p>Solutions do not, or rarely, include concepts covered in later chapters.</p>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-1","title":"Chapter 1","text":"<p>Write a program to calculate the area of a triangle</p> <pre><code>using System;\n\nnamespace triangle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Calculate the area of a triangle\");\n\n            int height;\n            int width;\n            double area;\n\n            Console.Write(\"Enter the height of the triangle &gt; \");\n            height = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"Enter the width of the triangle  &gt; \");\n            width = Convert.ToInt32(Console.ReadLine());\n\n            area = height * width;\n\n            Console.WriteLine($\"The triangle's area is {area} units\");\n\n            Console.WriteLine(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-2","title":"Chapter 2","text":"<p>Write a program that converts a temperature in degrees Fahrenheit into Centigrade/Celsius</p> <pre><code>using System;\n\nnamespace TempConv\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double fahrTemp;\n            double celTemp;\n\n            Console.Clear();\n            Console.WriteLine(\"Temperature Conversion\");\n\n            Console.Write(\"Enter a temperature in degrees Fahrenheit &gt; \");\n            fahrTemp = Convert.ToDouble(Console.ReadLine());\n\n            celTemp = (fahrTemp - 32) * 5/9;\n\n            Console.WriteLine($\"{fahrTemp} degrees F is {celTemp} degrees C\");\n\n            Console.WriteLine(\"Press any key to continue ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Declare two variables of type <code>int</code>.  Assign them the values \\(8\\) and \\(5\\).  Swap their values and print them to the screen</p> <pre><code>using System;\n\nnamespace swap\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int first = 8;\n            int second = 5;\n\n            Console.Clear();\n            Console.WriteLine(\"Simple swap\");\n\n            Console.WriteLine($\"Before the swap:  First = {first}, Second = {second}\");\n\n            int Temp = first;\n            First = second;\n            second = Temp;\n\n            Console.WriteLine($\"After the swap:   First = {first}, Second = {second}\");\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Write a program which inputs the length and width of a rectangular garden. Calculate the area of the garden and the cost of turfing a lawn if a 1m unturfed border is around the perimeter of the garden. Assume the cost of turf is 10 per square metre</p> <pre><code>using System;\n\nnamespace Turf\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int costPerSqMetre = 10;\n            double length;\n            double width;\n            double lawnArea;\n            double cost;\n\n            Console.WriteLine(\"How much to turf a lawn?\");\n\n            Console.Write(\"Enter length of the lawn &gt; \");\n            length = Convert.ToDouble(Console.ReadLine());\n            Console.Write(\"Enter width of the lawn  &gt; \");\n            width = Convert.ToDouble(Console.ReadLine());\n\n            lawnArea = (length - 2) * (width-2);\n            cost = lawnArea * costPerSqMetre;\n\n            Console.WriteLine($\"Total cost = ${cost}\");\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey(); \n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-3","title":"Chapter 3","text":"<p>Displaying a pack of cards</p> <p>To avoid repetition in the code, this solution uses two methods (see Chapter 9) to return a string representation of the playing card, <code>GetRankAsString()</code> and <code>GetSuitAsString()</code>.</p> <pre><code>using System;\n\nnamespace cards\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string rank = \"\";\n            string suit = \"\";\n\n            Console.Clear();\n            Console.WriteLine(\"Cards Complete\");\n\n            // Pick a card\n            Console.Write(\"Enter a number (1-52) to pick a card from the deck, or 0 to select a random card &gt; \");\n\n            int myCardNum = Convert.ToInt32(Console.ReadLine());\n\n            if (myCardNum == 0)\n            {\n                Random rnd = new Random();\n                myCardNum = rnd.Next(52);\n            }\n\n            rank = GetrankAsString(m - 1);          // -1 to ensure first card can be selected\n            suit = GetsuitAsString(m);    \n            Console.WriteLine($\"Your card is the {rank} of {suit}\");\n\n\n            Console.WriteLine(\"The whole deck ...\");\n            for (int i = 0; i &lt; 52; i++)\n            {\n                //rankNum = (i % 13) + 1;\n                //suitNum = i / 13;\n                rank = GetrankAsString(i);\n                suit = GetsuitAsString(i);    \n                Console.WriteLine($\"{rank} of {suit}\");\n            }\n\n            Console.WriteLine(\"Press any key to continue ...\");\n            Console.ReadKey();\n        }\n\n        static string GetrankAsString(int rank)\n        {\n            int rankNum = (rank % 13) + 1;\n            string rankStr = \"\";\n            switch (rankNum)\n            {\n                case 1:\n                    rankStr = \"Ace\";\n                    break;\n                case 2:\n                    rankStr = \"Two\";\n                    break;\n                case 3:\n                    rankStr = \"Three\";\n                    break;\n                case 4:\n                    rankStr = \"Four\";\n                    break;\n                case 5:\n                    rankStr = \"Five\";\n                    break;\n                case 6:\n                    rankStr = \"Six\";\n                    break;\n                case 7:\n                    rankStr = \"Seven\";\n                    break;\n                case 8:\n                    rankStr = \"Eight\";\n                    break;\n                case 9:\n                    rankStr = \"Nine\";\n                    break;\n                case 10:\n                    rankStr = \"Ten\";\n                    break;\n                case 11:\n                    rankStr = \"Jack\";\n                    break;\n                case 12:\n                    rankStr = \"Queen\";\n                    break;\n                case 13:\n                    rankStr = \"King\";\n                    break;\n            }\n            return rankStr;\n        }\n\n        static string GetsuitAsString(int suit)\n        {\n            string suitStr = \"\";\n            int suitNum = suit / 13;\n            if (suitNum == 0)\n                suitStr = \"\\u2663\";      // club\n            else if (suitNum == 1)\n                suitStr = \"\\u2666\";   // diamond\n            else if (suitNum == 2)\n                suitStr = \"\\u2665\";      // heart\n            else if (suitNum == 3)\n                suitStr = \"\\u2660\";     // spades\n            else\n                suitStr = \"ERROR\";\n            return suitStr;\n        }\n    }\n}\n</code></pre> <p>Using a bitwise operator write a program that checks if an integer is odd or even</p> <pre><code>using System;\n\nnamespace oddOrEven\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Odd Or Even\");\n\n            Console.Write(\"Enter a number &gt; \");\n            int value = Convert.ToInt32(Console.ReadLine());\n\n            if ((value &amp; 1) == 1)\n                Console.WriteLine($\"{value} is odd\");\n            else\n                Console.WriteLine($\"{value} is even\");\n            Console.WriteLine(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Write a program that takes as input a four digit number and calculates the sum of the digits</p> <pre><code>using System;\n\nnamespace sumOfDigits\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Sum Of Digits\");\n\n            Console.Write(\"Enter a number with 4 digits only &gt; \");\n            string numString = Console.ReadLine();\n\n            int sum = 0;\n            sum += Convert.ToInt32(numString[0]) - '0';     // input is in ASCII, need to subtract 48, or '0'\n            sum += Convert.ToInt32(numString[1]) - 48;\n            sum += Convert.ToInt32(numString[2]) - '0';\n            sum += Convert.ToInt32(numString[3]) - '0';\n\n            Console.WriteLine($\"Sum is {sum}\");\n\n            sum = 0;\n\n            // alternatively a loop would help\n            for (int i = 0; i &lt; numString.Length; i++)\n                sum += numString[i] - 48;\n            Console.WriteLine($\"The looped sum is also {sum}\");\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-4","title":"Chapter 4","text":"<p>Returning the minimum and maximum of two values (not conditionals)</p> <pre><code>using System;\n\nnamespace max\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Max without an IF\");\n\n            int first = 8;\n            int second = 5;\n\n            Console.WriteLine($\"Smaller of ({first},{second}) is {Math.Min(first,second)}\");\n            Console.WriteLine($\"Larger of ({first},{second}) is {Math.Max(first,second)}\");\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Printing in columns</p> <pre><code>using System;\n\nnamespace columns\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Printing in columns\");\n\n            int first = 0xFF;\n            double second = 245.7689;\n            double third = -123.456;\n            Console.WriteLine($\"|0x{first,-8:X}|{second,-10:f2}|{third,-10:f2}|\");\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-5-making-decisions","title":"Chapter 5: Making Decisions","text":"<p>Rock, Paper, Scissors</p> <pre><code>using System;\n\nnamespace rockPaperScissors\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string computerObject = \"\";\n            int computerChoice = 0;\n            bool computerWins = false;\n\n            Random random = new Random();\n\n            Console.Clear();\n            Console.Write(\"Enter your choice r(ock), p(aper), s(cissors): \");\n            string userObject = Console.ReadLine();\n\n            char userObjectFirst = userObject[0];               // get first character of user choice\n            computerChoice = random.Next(3);                    // get random value, 0..2, for selecting computer choice\n\n            switch (computerChoice)\n            {\n                case 0:\n                    computerObject = \"rock\";\n                    break;\n                case 1:\n                    computerObject = \"paper\";\n                    break;\n                case 2:\n                    computerObject = \"scissors\";\n                    break;\n            }\n\n            char computerObjectFirst = computerObject[0];\n            Console.WriteLine(\"Computer chose: \" + computerObject);\n\n            if (String.Equals(computerObjectFirst, userObject))\n            {\n                Console.WriteLine(\"It's a draw!\"); \n            }\n            else\n            {\n                if (computerObjectFirst == 'r' &amp;&amp; userObjectFirst == 'p') \n                {\n                    computerWins = false;\n                }\n                else if (computerObjectFirst == 'r' &amp;&amp; userObjectFirst == 's') \n                {\n                    computerWins = true;\n                }\n                else if (computerObjectFirst == 's' &amp;&amp; userObjectFirst == 'r') \n                {\n                    computerWins = false;\n                }\n                else if (computerObjectFirst == 's' &amp;&amp; userObjectFirst == 'p') \n                {\n                    computerWins = true;\n                }\n                else if (computerObjectFirst == 'p' &amp;&amp; userObjectFirst == 'r') \n                {\n                    computerWins = true;\n                }\n                else if (computerObjectFirst == 'p' &amp;&amp; userObjectFirst == 's') \n                {\n                    computerWins = false;\n                }\n\n                if (computerWins == true)\n                {\n                    Console.WriteLine(\"Computer has won!\");\n                }\n                else\n                {\n                    Console.WriteLine(\"You have won!\");\n                }\n            }\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Leap Year</p> <pre><code>using System;\n\nnamespace leapyear\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Leap year\");\n\n            int year;\n            bool leapyear = false;\n\n            Console.Write(\"Enter a valid year: \");\n            year = Convert.ToInt32(Console.ReadLine());\n\n            if ((year % 4 == 0) &amp;&amp; (year % 100 != 0))\n            {\n                leapyear = true;\n            }\n            else if (year % 100 == 0)\n            {\n                if (year % 400 == 0)\n                {\n                    leapyear = true;\n                }\n            }\n\n            if (leapyear)\n            {\n                Console.WriteLine(year + \" is a leap year\");\n            }\n            else\n            {\n                Console.WriteLine(year + \" is not a leap year\");\n            }\n        }\n    }\n}\n</code></pre> <p>Roots of a quadratic equation</p> <pre><code>using System;\n\nnamespace quadratic\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int a, b, c;\n            double discriminant;\n            double x1, x2;\n\n\n            Console.Clear();\n            Console.WriteLine(\"Quadratic Equation Solver\");\n\n            Console.Write(\"Enter first value (a) &gt; \");\n            a = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"Enter second value (b) &gt; \");\n            b = Convert.ToInt32(Console.ReadLine());\n            Console.Write(\"Enter third value (c) &gt; \");\n            c = Convert.ToInt32(Console.ReadLine());\n\n            discriminant = Math.Pow(b,2) - (4 * a * c);\n\n            if (a == 0)\n            {\n                Console.WriteLine(\"Not quadratic\");\n            }\n            if (discriminant == 0)\n            {\n                x1 = -b/(2.0*a);\n                x2 = x1;\n                Console.WriteLine($\"Both roots are equal: {x1}\");\n            }\n            else if (discriminant &gt; 0)\n            {\n                Console.WriteLine(\"There are two real roots\");\n                x1 = (-b + Math.Sqrt(discriminant))/(2 * a);\n                x2 = (-b - Math.Sqrt(discriminant))/(2 * a);\n                Console.WriteLine($\"First root = {x1}\");\n                Console.WriteLine($\"Second root = {x2}\");\n            }\n            else\n            {\n                Console.WriteLine(\"There are no roots\");\n            }\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-6-iteration","title":"Chapter 6: Iteration","text":"<p>Display table of ASCII codes (32-126)</p> <pre><code>using System;\n\nnamespace ascii\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"ASCII Table of printable characters\\n\");\n\n            Console.WriteLine(\"+----------+------------+-----------+\");\n            Console.WriteLine(\"|  Decimal |     Hex    | Character |\");\n            Console.WriteLine(\"+----------+------------+-----------+\");\n            for (int i = 32; i &lt; 126; i++)\n            {\n                Console.WriteLine($\"|{i,9} | {i,10:X} | {(char)i,10}|\");\n            }\n            Console.WriteLine(\"+----------+------------+-----------+\");\n            Console.WriteLine(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Fizz Buzz</p> <pre><code>using System;\n\nnamespace fizzbuzz\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Fizz Buzz\");\n\n            for (int i = 1; i &lt;= 100; i++)\n            {\n                if ((i % 5 == 0) &amp;&amp; (i % 3 == 0))\n                {\n                    Console.WriteLine(i + \" FIZZ BUZZ\");\n\n                }\n                else if (i % 3 == 0)\n                {\n                    Console.WriteLine(i + \" FIZZ\");\n                }\n                else if (i % 5 == 0)\n                {\n                    Console.WriteLine(i + \" BUZZ\");\n                }\n                else\n                {\n                    Console.WriteLine(i);\n                }\n            }\n            Console.WriteLine(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Sum the first \\(N\\) numbers of the Fibonacci series</p> <pre><code>using System;\n\nnamespace fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int number;\n            int sum = 0;\n            int temp = 0;\n            int first = 0;\n            int next = 1;\n            Console.Clear();\n            Console.WriteLine(\"sum of Fibonacci numbers to N\");\n\n            Console.Write(\"Enter a number: \");\n            number = Convert.ToInt32(Console.ReadLine());\n\n            Console.Write($\"[ {temp} \");\n            for (int i = 1; i &lt; number; i++)\n            {\n                first = next;\n                next = temp;\n                temp = first + next;\n                Console.Write($\"{temp} \");\n                sum += temp;\n            }\n\n            Console.WriteLine(\"]\");\n            Console.WriteLine($\"The sum of the first {number} numbers in Fibonacci sequence is {sum}\");\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-7-arrays","title":"Chapter 7:  Arrays","text":"<p>Initialise an array with square numbers</p> <pre><code>using System;\n\nnamespace squareArray\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int LENGTH = 20;\n            int[] myArray = new int[LENGTH];\n\n            Console.Clear();\n            Console.WriteLine(\"Initialising an array with square numbers\");\n\n            for (int i = 0; i &lt; LENGTH; i++)\n            {\n                myArray[i] = i * i;\n            }\n\n            foreach(int element in myArray)\n            {\n                Console.Write($\"{element} \");\n\n            }\n            Console.WriteLine();\n\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Searching for an element in an array</p> <pre><code>using System;\n\nnamespace randomSearch\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int MIN = 0;\n            const int MAX = 100;\n            const int NUM_ELEMENTS = 20;\n\n            int[] myArray = new int[NUM_ELEMENTS];\n            int searchKey;\n            bool found = false;\n            Random rnd = new Random();\n\n            Console.Clear();\n            Console.WriteLine(\"Searching for a value in an array\");\n\n            // initialise array\n            for (int i = 0; i &lt; myArray.Length; i++)\n            {\n                myArray[i] = rnd.Next(MIN,MAX);\n            }\n\n            // ask use for a search value/key\n            Console.Write(\"Enter a value to find: \");\n            searchKey = Convert.ToInt32(Console.ReadLine());\n\n            foreach (int e in myArray)\n            {\n                //Console.Write($\"{e} \");           // testing\n                if (e == searchKey)\n                {\n                    found = true;\n                    break;                          // only need first instance\n                }\n            }\n\n            // print result\n            if (found)\n            {\n                Console.WriteLine($\"\\nYour value {searchKey} was found!\");\n            }\n            else\n            {\n                Console.WriteLine($\"\\nYour value {searchKey} could not be found\");\n            }\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Merge two arrays</p> <pre><code>using System;\n\nnamespace merge\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int SIZE = 10;\n            const int MIN = 0;\n            const int MAX = 100;\n            int[] firstArray = new int[SIZE];\n            int[] secondArray = new int[SIZE];\n            int[] mergedArray = new int[SIZE * 2];\n\n            Console.Clear();\n            Console.WriteLine(\"Merge two arrays\");\n            Random rnd = new Random();\n            // initialise starting arrays with random values\n            int i;\n            for (i = 0; i &lt; SIZE; i++)\n            {\n                firstArray[i] = rnd.Next(MIN,MAX);\n                SecondArray[i] = rnd.Next(MIN,MAX);\n            }\n\n            // merge into a new array\n            for (i =0; i &lt; SIZE; i++)\n            {\n                mergedArray[i] = firstArray[i];\n            }\n            for(int j = 0; j &lt; SIZE; j++)\n            {\n                mergedArray[i] = SecondArray[j];        // note value for i\n                i++;\n            }\n\n            Array.Sort(mergedArray);\n\n            // Print arrays\n            Console.WriteLine(\"nFirst array\");\n            // first array\n            foreach(int e in firstArray)\n            {\n                Console.Write($\"{e} \");\n            }\n            Console.WriteLine(\"\\nSecond array\");\n            foreach(int e in SecondArray)\n            {\n                Console.Write($\"{e} \");\n            }\n            Console.WriteLine(\"\\nMerged array\");\n            // print merged array\n            foreach(int el in mergedArray)\n            {\n                Console.Write($\"{el} \");\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Press any key to quit ...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Multiplication table</p> <pre><code>using System;\n\nnamespace multiplicationTable\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int START = 1;\n            const int END = 12;\n            Console.Clear();\n            Console.WriteLine(\"Multiplication Table\");\n\n            // header row\n            Console.Write($\"      \");\n            for(int i = 1; i &lt;= END; i++)\n            {\n                Console.Write($\" {i,5} \");\n            }\n            // multiplication table\n            for (int row = START; row &lt;= END; row++)\n            {\n                Console.Write($\"{row,3} | \");\n                for (int col = START; col &lt;= END; col++)\n                {\n                    Console.Write($\" {row * col,5} \");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-8-strings-encryption-and-testing","title":"Chapter 8: Strings, Encryption and Testing","text":"<p>Searching for keywords</p> <pre><code>using System;\n\nnamespace stringChecking\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"I am going to check every word of this sentence for the keywords\";\n            string[] words;\n\n            Console.Clear();\n            Console.WriteLine(\"String Checking\");\n\n            words = str.Split(' ');\n\n            foreach(string w in words)\n            {\n                if ((w == \"check\") || (w == \"word\") || (w == \"sentence\"))\n                {\n                    Console.ForegroundColor = ConsoleColor.DarkRed;\n                    Console.Write($\"{w} \");\n                    Console.ForegroundColor = ConsoleColor.Black;\n                }\n                else\n                {\n                    Console.Write($\"{w} \");\n                }\n            }\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Counting characters</p> <pre><code>using System;\n\nnamespace countCharacters\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] charFrequency = new int[26];\n            string inputString;\n\n            Console.Clear();\n            Console.WriteLine(\"Counting characters\");\n\n            Console.Write(\"Enter a string: \");\n            inputString = Console.ReadLine();\n            inputString = inputString.ToUpper();\n\n            for(int i = 0; i &lt; inputString.Length; i++)\n            {\n                // only counting letters, not punctuation\n                if ((inputString[i] &gt;= 'A') &amp;&amp; (inputString[i] &lt;= 'Z'))\n                {\n                    charFrequency[inputString[i]-'A']++;\n                }\n            }\n\n            // print, getting the character represented by each index followed by the value\n            for (int i = 0; i &lt; charFrequency.Length; i++)\n            {\n                Console.Write((char)(i+65) + \": \" + charFrequency[i] + \" \");\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre> <p>Screen scraping</p> <pre><code>using System;\n\nnamespace screenScrape\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string html = \"&lt;html&gt;&lt;head&gt;&lt;title&gt;News&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Getting proficient with C# requires &lt;b&gt;practice&lt;/b&gt;, &lt;b&gt;practice&lt;/b&gt; and more &lt;b&gt;practice&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\";\n            string output = String.Empty;\n            bool openingTagMode = false;\n\n            Console.Clear();\n            Console.WriteLine(\"Screen scraping\");\n\n            for (int i = 0; i &lt; html.Length; i++)\n            {\n                if (html[i] == '&lt;')\n                {\n                    openingTagMode = true;\n                }\n                else if (html[i] == '&gt;')\n                {\n                    openingTagMode = false;\n                }\n                if ((!openingTagMode) &amp;&amp; (html[i] != '&gt;'))\n                {\n                    output += html[i];\n                }\n            }\n            Console.WriteLine(output);\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-9-methods","title":"Chapter 9 - Methods","text":"<p>Calculator</p> <pre><code>using System;\n\nnamespace calculator\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int menuOption;\n\n            Console.Clear();\n            Console.WriteLine(\"Welcome to the calculator program\\n\");\n\n            do\n            {\n                // Ask the user for two number and store them as floats\n                Console.Write(\"Enter the first number: \");\n                float number1 = GetFloat();\n                //float number1 = float.Parse(Console.ReadLine());\n\n                Console.Write(\"Enter the second number: \");\n                float number2 = GetFloat();\n                //float number2 = float.Parse(Console.ReadLine());\n\n                // Output the menu options\n                Console.WriteLine(\"\\nEnter the menu number of the calculation to perform: \");\n                Console.WriteLine(\"1 - Addition\");\n                Console.WriteLine(\"2 - Subtraction\");\n                Console.WriteLine(\"3 - Multiplication\");\n                Console.WriteLine(\"4 - Division\");\n                Console.WriteLine(\"5 - Modulus\");\n                Console.WriteLine(\"6 - Floor Division\");\n                Console.WriteLine(\"7 - QUIT\\n\");\n\n                // Ask for the menu option\n                menuOption = GetInt();\n\n                switch (menuOption)\n                {\n                    case 1:\n                        Console.WriteLine($\"The result = {Addition(number1, number2)}\");\n                        break;\n                    case 2:\n                        Console.WriteLine($\"The result = {Subtraction(number1, number2)}\");\n                        break;\n                    case 3:\n                        Console.WriteLine($\"The result = {Multiplication(number1, number2)}\");\n                        break;\n                    case 4:\n                        Console.WriteLine($\"The result = {Division(number1, number2)}\");\n                        break;\n                    case 5:\n                        Console.WriteLine($\"The result = {Modulus(number1,number2)}\");\n                        break;\n                    case 6:\n                        Console.WriteLine($\"The result = {Floor(number1, number2)}\");\n                        break;\n                }\n            } while ((menuOption &gt;= 1) &amp;&amp; (menuOption &lt;= 6));\n        }\n\n        // The addition procedure has two floats as parameters, adds them together and outputs the result\n        static float Addition(float num1, float num2)\n        {\n            return num1 + num2;\n        }\n\n        static float Subtraction(float num1, float num2)\n        {\n            return num1 - num2;\n        }\n\n        static float Multiplication(float num1, float num2)\n        {\n            return num1 * num2;\n        }\n\n        static float Division(float num1, float num2)\n        {\n            if (num2 != 0)\n                return num1 / num2;\n            else\n                return -1;\n        }\n\n        static float Modulus(float num1, float num2)\n        {\n            return num1 % num2;\n        }\n\n        static int Floor(float num1, float num2)\n        {\n            //Console.WriteLine(Math.Floor(Division(num1,num2)));\n            if (((num1 &lt; 0) ^ (num2 &lt; 0)) &amp;&amp; (num1 % num2 != 0))\n            {\n                return Convert.ToInt32(num1/num2);\n            }\n            else\n            {\n                return Convert.ToInt32(num1 / num2)-1;\n            }\n        }\n        static float GetFloat()\n        {\n            string input = Console.ReadLine();\n            float result = 0f;\n            while (!float.TryParse(input, out result))\n            {\n                Console.WriteLine(\"That is not a valid number, please try again.\");\n                Console.Write(\"Enter number &gt; \");\n                input = Console.ReadLine();\n            }\n            return result;\n        }\n\n        static int GetInt()\n        {\n            string input = Console.ReadLine();\n            int result = 0;\n            while (!Int32.TryParse(input, out result))\n            {\n                Console.WriteLine(\"That is not a valid number, please try again.\");\n                Console.Write(\"Enter number &gt; \");\n                input = Console.ReadLine();\n            }\n            return result;\n        }\n    }\n}\n</code></pre> <p>Secret Word</p> <pre><code>using System;\n\nnamespace secretWord\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Initialise the variables and secret word\n            int menuOption;\n            string secretWord = \"Computer\";\n\n            do\n            {\n                Console.Clear();\n                // Output the menu\n                Console.WriteLine(\"\\nWelcome to the guessing program menu - choose your option:\");\n\n                menuOption = GetMenuOption();\n                // Choose a task depending on the menu option \n                switch (menuOption)\n                {\n                    case 1:\n                        // Change the secret word\n                        secretWord = ChangeSecretWord();\n                        break;\n                    case 2:\n                        // Guess the secret word\n                        GuessSecretWord(secretWord);\n                        break;\n                    case 3:\n                        // Quit the program\n                        Exit();\n                        break;\n                    default:\n                        Console.WriteLine(\"Invalid menu choice\");\n                        break;\n                }\n            }\n            while (menuOption &gt;= 1 &amp;&amp; menuOption &lt;= 2);\n        }\n\n        static int GetMenuOption()\n        {\n            Console.WriteLine(\"MAIN MENU\\n\");\n            Console.WriteLine(\"1 - Change the secret word\");\n            Console.WriteLine(\"2 - Make a guess\");\n            Console.WriteLine(\"3 - Quit\");\n            Console.Write(\"&gt; \");\n\n            // Ask the user for the menu number\n            return (GetInt());\n        }\n\n        static string ChangeSecretWord()\n        {\n            Console.WriteLine(\"What is the new secret word?\");\n            Console.Write(\"&gt; \");\n            return Console.ReadLine();\n        }\n\n        static void GuessSecretWord(string secretWord)\n        {\n            Console.Write(\"Guess the secret word: \");\n            string guess = Console.ReadLine();\n\n            // Check whether the word entered was the secret word - ignoring case\n            if (guess.ToUpper() == secretWord.ToUpper())\n            {\n                Console.WriteLine(\"Well done - you have guessed the secret word!\");\n            }\n            else\n            {\n                Console.WriteLine(\"Sorry, that is not the secret word\");\n            }\n            PressAnyKey();\n        }\n\n        static void Exit()\n        {\n            Console.WriteLine(\"Thank you for playing secret word\");\n            Environment.Exit(0);\n        }\n\n        static void PressAnyKey()\n        {\n            Console.Write(\"Press any key to continue...\");\n            Console.ReadKey();\n        }\n        static int GetInt()\n        {\n            string input = Console.ReadLine();\n            int result = 0;\n            while (!Int32.TryParse(input, out result))\n            {\n                Console.WriteLine(\"That is not a valid option, please try again.\");\n                Console.Write(\"&gt; \");\n                input = Console.ReadLine();\n            }\n            return result;\n        }\n    }\n}\n</code></pre> <p>Binary to decimal 'bitwise' converter</p> <pre><code>using System;\n\nnamespace binaryToDecimal\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Binary to decimal bitwise converter\");\n            string binary = GetBinaryValue();\n            int result = ConvertBinary(binary);\n            OutputResult(result);\n            Exit();\n        }\n\n        static string GetBinaryValue()\n        {\n            Console.WriteLine(\"Enter binary number to be converted\");\n            Console.Write(\"&gt; \");\n            return Console.ReadLine();\n        }\n\n        static int ConvertBinary(string binary)\n        {\n            int column = 128;\n            int result = 0;\n            for (int i = 0; i &lt; binary.Length; i++)\n            {                \n                int bitValue = ConvertBit(binary[i],column);\n                column /= 2;\n                result += bitValue;\n            }\n            return result;\n        }\n        static int ConvertBit(char bit, int col)\n        {\n            int result = 0;\n            if (bit == '1')\n            {\n                result += col;\n            }\n            return result;\n        }\n\n        static void OutputResult(int result)\n        {\n            Console.WriteLine(result);\n        }\n        static void Exit()\n        {\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A2_Solutions/#chapter-10-recursion","title":"Chapter 10: Recursion","text":"<p>Length of a string</p> <pre><code>using System;\n\nnamespace stringLength\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Length of a string - recursively\");\n\n            Console.Write(\"Enter a string: \");\n            string input = Console.ReadLine();\n            Console.WriteLine($\"The length of \\\"{input}\\\" is {GetLength(input)}\");\n\n            Console.Write(\"Press any key to quit...\");\n            Console.ReadKey();\n        }\n\n        static int GetLength(string input)\n        {\n            if (input == string.Empty)\n            {\n                return 0;\n            }\n            else\n            {\n                return GetLength(input.Substring(1)) + 1;\n            }\n        }\n    }\n}\n</code></pre> <p>Calculate power</p> <pre><code>using System;\n\nnamespace power\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Clear();\n            Console.WriteLine(\"Calculate Power of value recursively\");\n\n            Console.WriteLine(Convert.ToInt32(Power(2,8)));         // 256\n\n            Console.Write(\"Press any key to continue...\");\n            Console.ReadKey();\n        }\n\n        static int Power(int num, int exponent)\n        {\n            if (exponent == 0)\n                return 1;\n            else\n                return num * Power(num, exponent-1);\n        }\n    }\n\n}\n</code></pre>"},{"location":"chapters/14_appendix/A3_VisualStudio/","title":"Appendix 3 -  Using Visual Studio","text":""},{"location":"chapters/14_appendix/A3_VisualStudio/#downloading-and-installing-visual-studio","title":"Downloading and installing Visual Studio","text":"<p>Visual Studio is a professional level Integrated Development Environment (IDE) from Microsoft.  There is a free version, known as the Community Edition available from the Microsoft website.  On that page, at time of writing, there are three options:</p> <ul> <li>Visual Studio</li> <li>Visual Studio Code</li> <li>Visual Studio for Mac</li> </ul> <p>Click the download button for Visual Studio, selecting the latest Community Edition.</p> Download Visual Studio Community Edition <p>Note, to run Visual Studio you will need the following minimum specification:</p> <ul> <li>Windows operating system, anything later than Windows 7 will be OK, and 64-bit is recommended</li> <li>1.8 GHz processor (quad-core recommended)</li> <li>A minimum of 2Gb of RAM, though the more you have the better</li> <li>Up to 2Gb of storage space on your hard drive, using an SSD will impact performance significantly</li> <li>Video card supporting 1280 by 720 display resolution</li> <li>.NET Framework (this ill be installed if not present during installation)</li> <li>Latest Windows updates</li> </ul> <p>You need administrator rights to install Visual Studio.</p> <p>The installer includes everything you need to both install and customise the Visual Studio environment. Once you've clicked through the license terms and privacy statement from Microsoft you'll be presented with the installation options, or workloads.  As a minimum, for this text, select \".NET desktop development\".</p> Select the workload"},{"location":"chapters/14_appendix/A3_VisualStudio/#tour-of-the-visual-studio-ide","title":"Tour of the Visual Studio IDE","text":"<p>When you first launch Visual Studio you're presented with the following screen:</p> Load a Project in Visual Studio <p>The options should be self-explanatory.</p> <p>On selecting \"Create a New Project\" you'll be presented with a number of templates that contain the basic files and settings for a variety of different project types.  You can use the search box at the top of this page or use the drop down boxes to filter the selections:</p> Create new project in Visual Studio <p>Here, we've selected a new Console App project.</p> <p>The next window provides some options for your new project such as its name and directory etc:</p> Configure new project in Visual Studio <p>Having set those options the main IDE will start and you'll be presented with the following window:</p> Main Editor Window in Visual Studio <p>The larger pane is the code editor, here is where you write your code.</p> <p>To the right is the solution explorer that displays a graphical representation of the files and directories in your solution.  Use this to navigate and open an alternative file in your solution by double-clicking on its name.</p> <p>The menu bar is as you might expect where commands are grouped into various categories.  Spend some time exploring these commands to see what is available.  The toolbar is beneath the menu and provides shortcuts to some frequently used commands.  The one used most often perhaps will be the green play button.  This shortcut builds (compiles) your project code and then runs it within Visual Studio.</p> <p>To the bottom left are some some other useful windows:</p> <ul> <li>Error List: if there is a problem when compiling or running the error messages will appear in this window.</li> <li>Output window: shows messages from building your project files</li> <li>Task List: another useful feature, this window tracks comments and lists those that begin with <code>TODO:</code>.  Use this to remind yourself of code waiting to be written or changed.</li> </ul>"},{"location":"chapters/14_appendix/A3_VisualStudio/#using-the-code-editor","title":"Using the Code editor","text":""},{"location":"chapters/14_appendix/A3_VisualStudio/#snippets","title":"Snippets","text":"<p>The code editor provides a number of handy shortcuts for speeding up the process of writing code.  One is the use of code snippets.  You can find what these are through the Edit &gt; Intellisense &gt; Insert snippet menu.</p> <p>For example:</p> <ul> <li><code>cw</code> then pressing the tab key twice will insert <code>Console.WriteLine();</code></li> <li><code>for</code> then pressing the tab key twice will insert a for loop snippet</li> <li><code>if</code> following by double tab will insert an if statement</li> </ul>"},{"location":"chapters/14_appendix/A3_VisualStudio/#commenting","title":"Commenting","text":"<p>Commenting blocks of code can be achieved using the buttons on the toolbar:</p> Commenting code in Visual Studio <p>The first button will comment out any selected lines of code, the second reverse that process.</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#folding","title":"Folding","text":"<p>To the left of the code you'll see a small box with a minus sign, <code>-</code>.  Click any of these and the code will fold, or collapse and the indicator changes to a plus sign, <code>+</code>.</p> <p>This is handy when you have a lot of code and only want to focus on a small section.</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#intellisense","title":"Intellisense","text":"<p>As you enter code the editor's Intellisense function will kick in providing prompts for what it is expecting you to type.  Pressing tab twice on the suggestion will insert that word into your code.</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#renaming","title":"Renaming","text":"<p>Should you choose to rename a variable or method select the word to be changed and use the context menu (right click of the mouse) and select <code>Rename</code>.  In the code editor make the changes to the identifier being changed then click Apply.  Now all instances of that identifier will have been updated in your code.</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#projects-and-solutions","title":"Projects and Solutions","text":"<p>A Visual Studio Solution is a container for one or more related projects.  Think of a solution as a house and a project of rooms in that house, the rooms can be linked together.</p> <p>When starting Visual Studio one of the options is \"Create New Project\".  This is misleading as it should be \"Create New Solution\", though the solution will only have one project file.</p> <p>We can add new projects to our solution by right-clicking on the Solution Explorer pane, selecting the top-most entry labelled Solution '\\&lt;SolutionName&gt;' and clicking Add Project.  You might use this when adding a library of code, a class library, for your your application, or a project to handle a Console interface etc..</p> <p>Where one project requires code in another we need to add a reference to that project by selecting Dependencies  and using the context menu to Add Project Reference ...</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#the-debugger","title":"The Debugger","text":"<p>An essential tool in any software developer's armoury.</p> <p>We'll use the following code to demonstrate:</p> <pre><code>static void Main(string[] args)\n{\n    int a;\n    int b;\n    int result;\n    Console.Write(\"Enter a value for a: \");\n    a = Convert.ToInt32(Console.ReadLine());\n    Console.Write(\"Enter a value for b: \");\n    b = Convert.ToInt32(Console.ReadLine());\n    if (a &gt; b)\n    {\n        result = a + b;\n    }\n    else\n    {\n        result = a * b;\n    }\n    Console.WriteLine($\"The result is {result}\");\n    Console.ReadKey();\n}\n</code></pre>"},{"location":"chapters/14_appendix/A3_VisualStudio/#setting-a-breakpoint","title":"Setting a breakpoint","text":"<p>Click in the grey gutter to the left of one of the lines of code:</p> Setting a breakpoint <p>Now, when you run the code execution will stop, or break, on that line.</p> <p>From this point the degugging toolbar has a number of options:</p> Debugging Toolbar <ul> <li>Stop will cease execution ofthe program</li> <li>Restart, the next button restarts execution</li> <li>Step Into, where the code is on a method call this button will go to that method and run the next line of code</li> <li>Step Over, this runs the method call without stepping into it line by line</li> </ul>"},{"location":"chapters/14_appendix/A3_VisualStudio/#inspecting-the-state","title":"Inspecting the state","text":"<p>Once the program has been paused we can look at the state of the program i.e. the contents of its variables.  This is one of the most useful aspects of debugging and there are different ways of inspecting date.</p> <p>Hover over an object, a variable name for example, and its current value will be displayed in a pop-up:</p> Hover over an object with the mouse <p>If inspecting a complex object, such as an array, struct or object, then all properties and values can be viewed.</p> <p>Alternatively, locate the Locals and Autos window in the bottom left of the editor:</p> Locals Window <p>The Locals window shows the state of all variables currently in scope.  The Autos window shows the state of variables on the current or preceding line.</p> <p>You can also set a watch on variables byt right-clicking and selecting Add Watch and you can watch its value change as you advance the program line by line.</p> <p>Finally, the Call Stack can be used in the lower right hand corner of the IDE.  This shows the order in which methods are being called and executed.  With complex programs the Call Stack is a good was of understanding the flow of execution in your application.</p>"},{"location":"chapters/14_appendix/A3_VisualStudio/#integration-with-git-and-github","title":"Integration with Git and GitHub","text":"<p>All source code can be managed via a Git repository (see Appendix 5).</p> <p>Open the Team Explorer pane, by the Solution Explorer pane.  Under the section of the window headed GitHub click Create.  A Dialogue is displayed here details of this new repository can be set up.  This creates a new repository on GitHub so assumes you already have an account set up there.</p> <p>Once this has been created the following options are made available:</p> GitHub and Visual Studio <p>When you make changes to your code and are ready to commit those changes to the main branch of your code then click Changes from this pane.  You'll be presented with a place to comment on the changes made and then a button to commit.  This will commit changes locally.</p> <p>To synchronise changes with the GitHub repository, click sync and the Push in the Outgoing Commits pane:</p> GitHub committing changes <p>Wait a moment and a message should be posted to this pane:  \"Successfully committed to origin/main\".</p> <p>Checking your online GitHub account will confirm the code has been updated as expected.</p> <p>There are other options available for managing you code with GitHub and Visual Studio but this gets you started with the basics</p> <p>NB.  To streamline this process you might also want to take a look at GitHub Desktop which simplifies the process of managing your code considerably.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/","title":"Appendix 4: Using Visual Studio Code and Visual Studio Community","text":"<p>Visual Studio Code (VSCode) is a lightweight alternative to Visual Studio.  It is first and foremost a source code editor rather than an IDE but is available for Windows. Mac and Linux making it an ideal solution for those without access to a Windows machine.  It's also a brilliant text editor - this text was written entirely using VS Code.  It also runs as a portable application so you can carry the editor with on a USB device.  </p> <p>VSCode will not build and run C# code out of the box, it requires an extension to be added.  There are dozens (hundreds?) of different extensions available for VSCode for multiple langauges that makes it almost a one-stop shop for development.  It's a great tool for C# development, and Python.  It's an excellent HTML editor and great for Javascript too.</p> <p>In addition, your system will need to have the .NET Core SDK installed.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#install-net","title":"Install .NET","text":"<p>Go to Microsoft Downloads and select the latest recommended version of .NET for your target machine, the SDK not the run-time.  At time of writing this was .NET 5.0.  Then install it as you would other software for your computer.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#install-visual-studio-code","title":"Install Visual Studio Code","text":"<p>Visual Studio Code is available from Microsoft and download the version for your target machine.  Install as usual.</p> <p>If you want to make it portable, add a directory named <code>data</code> into the installation directory.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#install-the-c-extension","title":"Install the C# Extension","text":"<p>Run Visual Studio Code and select the Extensions icon from the toolbar on the left hand side.  Search for C# and select \"C# for Visual Studio Code (powered by Omnisharp) from the list of extensions displayed.  Select install.</p> <p>That's it!  Now you're ready to code in C# using Visual Studio Code</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#the-vscode-gui","title":"The VSCode GUI","text":"VSCode interface <p>There are 5 main parts to the interface:</p> <ol> <li>Menu</li> <li>Code Editor</li> <li>File Explorer</li> <li>Sidebar</li> <li>Terminal </li> </ol> <p>Each of these should hold no surprises, the sidebar is particularly useful.  Spend some time getting familiar with teh various elements of the GUI, the options in the menu system, working with the terminal and opening/closing files and directories.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#creating-a-console-application","title":"Creating a console application","text":"<p>Creating new projects, build those projects and running them is done via a terminal window using commands.  Open a new terminal using the Terminal menu and navigate to the directory where you want to save your project files.  To create a new directory use:  <code>mkdir \\&lt;nameOfDirectory\\&gt;</code>. Then change into that directory using <code>cd \\&lt;nameOfDirectory\\&gt;</code></p> <p>Enter the following command:</p> <p><code>dotnet new console</code></p> <p>This instructs VSCode to create a new project using the <code>console</code> template, i.e. a new console application.  Other templates are available.</p> New Console project with VSCode <p>Click the <code>Program.cs</code> file and this will be loaded into the editor.  Write your code and save.  To build and run the code enter the command:</p> <p><code>dotnet run</code></p> <p>The code will be compiled, and if no errors found will be run in the terminal window.</p>"},{"location":"chapters/14_appendix/A4_UsingVisualStudioCode/#using-a-class-library","title":"Using a Class Library","text":"<p>The class library includes any classes used by another application.  The .NET target needs to be the same as the .NET target of the other application but in theory the class library can be distributed as a third-party component.  Or, as here, to encourage code separation.</p> <ol> <li> <p>Create a solution</p> <pre><code>dotnet new sln\n</code></pre> </li> <li> <p>Create a class library project</p> <pre><code>dotnet new classlib -o libraryName  // -o specifies the location of the generated output\n</code></pre> </li> <li> <p>Add the class library to the project</p> <pre><code>dotnet sln add libraryName/libraryName.csproj\n</code></pre> </li> <li> <p>Make changes/create the class library code</p> </li> <li> <p>Check it builds without error</p> <pre><code>dotnet build\n</code></pre> </li> <li> <p>Create the console application skeleton</p> <pre><code>dotnet new console -o &lt;ConsoleUI&gt;   // ConsoleUI = name of the console application\n</code></pre> </li> <li> <p>Add the console application to the solution</p> <pre><code>dotnet sln add ConsoleUI/ConsoleUI.csproj\n</code></pre> </li> <li> <p>Code the Console application</p> </li> <li> <p>Add a project reference so the console app has access to the class library</p> <pre><code>dotnet add ConsoleUI/ConsoleUI.csproj reference LibraryDir/LibraryName.csproj\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>dotnet run --project ConsoleUI/ConsoleUI.csproj\n</code></pre> </li> </ol>"},{"location":"chapters/14_appendix/A5_GitHub/","title":"Appendix 5 -  Git and GitHub","text":"<p>Git is a version control system used to track changes in files, manage project versions, and facilitate collaboration on software projects. It operates locally, meaning all files and their histories are stored on your computer. Git helps you keep track of code changes and makes it easy to revert to previous versions if necessary.</p> <p>GitHub is an online service that hosts Git repositories, allowing you to store your project files online, collaborate with others, and access your files from anywhere. It also provides tools for code review, project management, and documentation.</p> <p>Project files can be managed via the command-line, through a GUI or direct via the IDE (Visual Studio or Visual Studio Code) or even the GitHub site.  For now we'll use the latter to understand how Git works and learn some important vocabulary and functionality.  There are many online sites explaining how to use Git from the command-line for your given operating system. </p>"},{"location":"chapters/14_appendix/A5_GitHub/#create-a-github-account","title":"Create a GitHub account","text":"<p>Before starting with GitHub, you'll need to set up a free account. Visit github.com and follow the sign-up process. Once you've verified your email address, you'll be able to create repositories and start using GitHub.</p>"},{"location":"chapters/14_appendix/A5_GitHub/#git-repositories","title":"Git repositories","text":"<p>A repository (or repo) is a storage space for your project files and their history. It can include any type of file, but it's a good practice to include a README file, usually written in markdown, to provide information about your project.</p> <p>To create a new repository on GitHub:</p> <ol> <li>Click on the \"New\" button on your GitHub dashboard.</li> <li>Give your repository a meaningful name, set the access to Public or Private, and check the box to include a README file.</li> <li>Click \"Create repository.\"</li> </ol> <p>I've called mine:  \"MyGitHubTest\":</p> GitHub New Repository"},{"location":"chapters/14_appendix/A5_GitHub/#making-changes-with-commits","title":"Making Changes with Commits","text":"<p>When you make changes to your files, you need to commit those changes to the repository. A commit is a snapshot of your project's current state, along with a message describing what has been changed.</p> <ol> <li>Add a new file to your repository using the GitHub web interface. For example, create a simple \"Hello World\" C# source file.</li> <li>In the Commit section below the text editor, write a brief message summarizing the changes, such as \"Created Hello World file\".</li> <li>Click \"Commit New File.\"</li> </ol> <p>You should commit changes often and write clear messages that explain why the change was made.</p>"},{"location":"chapters/14_appendix/A5_GitHub/#working-with-branches","title":"Working with Branches","text":"<p>Branches allow you to work on different versions of your project at the same time. By default, a new repository has one branch named <code>main</code>.</p> <p>Think of the branch as a work in progress, a possible revision to the original code.  Changes can be made to <code>main</code> directly, or to a branch.</p> <ol> <li>To create a new branch, click the branch dropdown on the top left of the repository page and select \"New branch.\"</li> <li>Name your branch (e.g., \"feature-update\") and click \"Create branch.\"</li> </ol> Creating a branch <p>A name for the branch needs to added, then click \"Create branch ...\".</p> <p>There are now two branches, <code>main</code> and the one just created.</p> <p>We'll use this branch to make changes to the README file.  Select this file and click the pencil icon to move into edit mode.  Make changes to the README and then commit the file with a suitable commit message.</p> <p>Now we have our repository with a branch that is different to <code>main</code>.</p>"},{"location":"chapters/14_appendix/A5_GitHub/#pull-requests","title":"Pull Requests","text":"<p>A pull request lets you propose changes to a repository and discuss them with collaborators before merging. </p> <ol> <li>Click the Pull Requests tab and select \"New Pull Request.\"</li> <li>Choose the branch you want to merge into <code>main</code> and review the changes.</li> <li>If everything looks good, click \"Create pull request.\"</li> </ol> <p>Give your pull request a meaningful title and description, then click \"Create pull request\" again.</p> Pull Request <p>The final stage is to \"Merge Pull Request\" into <code>main</code> which is the next window to be displayed.  Once clicked the final stage is to delete the branch from the next window.</p> Delete branch"},{"location":"chapters/14_appendix/A5_GitHub/#using-the-command-line","title":"Using the command line","text":"<p>It is frequently easier to control your Git repository using the command line.  It's helpful to know how to use the various commands in this way to help understanding what is happening behind the scenes with a graphical tool.</p> <p>For MacOS and Linux a terminal window is all you need, for Windows there is a Unix emulator, GitBash.  For both you will need some familiarity with general Unix (Linux) commands available for the terminal and there are plenty of online sites that provide such an introduction.</p> <p>You'll need to download and install Git for your target operating system and it's useful to have a GitHub account for saving a copy online.  On a local installation we need to set our username and email address:</p> <pre><code>git config --global user.name \"Enter your name here\"\ngit config --global user.email \"Enter you email address here\"\n</code></pre> <p>To create a repository use the following sequence of commands:</p> <pre><code>cd &lt;project_directory&gt;\ngit init                                # creates the local repository in directory\ngit add .                               # tells Git to track ALL files\ngit status                              # display current status of repository\ngit commit -m \"&lt;Enter commit message&gt;\"  # Save current version of tracked files\ngit remote add origin &lt;URL of remote&gt;   # connect the local and remote repositories\ngit remote -v                           # verifies the URL\ngit push origin main                    # uploads files to remote repository\n</code></pre> <p>When you're the only person working on your project, and on a single computer, it is fair to assume your local repository is the most up to date version but using Git can still be useful to track changes and if necessary revert to a previous version.</p> <p>If working in a team, or on a different computer and have the project backed up on GitHub, issue the command <code>git pull</code> to get the latest version.</p> <p>Get into the habit of committing and pushing changes to your project often, even small changes.</p>"},{"location":"chapters/14_appendix/A5_GitHub/#using-githb-with-visual-studio","title":"Using GitHb with Visual Studio","text":"<p>Visual Studio integrates Git functionality, making it easy to manage repositories, branches, and commits directly from the IDE.</p>"},{"location":"chapters/14_appendix/A5_GitHub/#clone-an-existing-repository","title":"Clone an existing repository","text":"<ol> <li>From the Visual Studio start window, select \"Clone a Repository.\"</li> <li>Enter the URL of the GitHub repository and choose a local path to save it.</li> <li>Click \"Clone.\"</li> </ol> Clone an existing repository"},{"location":"chapters/14_appendix/A5_GitHub/#committing-changes-in-visual-studio","title":"Committing Changes in Visual Studio","text":"<ol> <li>Make changes to your project files.</li> <li>Open the Git Changes window (View -&gt; Git Changes).</li> <li>Write a commit message and click \"Commit All.\"</li> </ol>"},{"location":"chapters/14_appendix/A5_GitHub/#pushing-changes","title":"Pushing Changes","text":"<p>To push changes to GitHub:</p> <ol> <li>In the Git Changes window, click \"Push.\"</li> <li>This will upload your commits to the GitHub repository.</li> </ol>"},{"location":"chapters/14_appendix/A5_GitHub/#summary","title":"Summary","text":"<p>Git and GitHub provide powerful tools for managing code and collaborating on projects. By understanding the basics of creating repositories, making commits, using branches, and creating pull requests, you can effectively manage your projects and work with others.</p> <p>For more in-depth learning, consider exploring the official Git documentation and GitHub guides.</p>"},{"location":"chapters/14_appendix/A6_UnitTesting/","title":"Appendix 6: Unit Testing","text":"<p>Testing software can be a real challenge as there are potentially lots of different ways to test the correct working of the code we write.  This appendix looks at the process of creating unit tests in Visual Studio Code.  It is a mere glimpse into the world of creating unit tests, a topic for further exploration and self-study.</p> <p>Testing is not a trivial process, there are lots of different test cases but thinking how your code might fail, the errors that could be generated, is good software development practice.  </p>"},{"location":"chapters/14_appendix/A6_UnitTesting/#what-is-a-unit-test","title":"What is a Unit Test?","text":"<p>A Unit Test is code written to test individual parts of code from our main project, usually methods.  The test cases are written as methods (functions) that evaluate whether a returned value is the expected value or something unexpected.  Unit testing will not guarantee the absence of bugs, the test will only be as good as the code written in the unit test but thinking about how a method might fail is good practice and the writing of unit tests encourages that thinking.</p> <p>Think of the unit test as another tool for testing, it should not replace pen and paper and tracing but automating aspects of testing can be really useful. Further, plan the tests before you code.</p> <p>You can read more about unit testing on Wikipedia.</p>"},{"location":"chapters/14_appendix/A6_UnitTesting/#unit-testing-with-visual-studio-code","title":"Unit Testing with Visual Studio Code","text":"<p>Install the extension .Net Core Test Explorer</p> <p>Adds a new icon to the sidebar, Testing</p> <p>We'll need a separate library of code for the unit tests and we'll use another library of code to which we'll apply the tests.</p> <p>First we'll create the library of code to test, a trivial set of methods to carry out basic mathematical operations.  At the terminal enter the following command in a fresh directory:</p> <p><code>dotnet new classlib -n MyMaths</code></p> <p>Then in the <code>Class1.cs</code> code file add the following:</p> <pre><code>using System;\n\nnamespace MyMaths\n{}\n    public class Class1\n    {\n        public static int Add(int first, int second)\n            return first + second;\n        }\n    }\n}\n</code></pre> <p>Make sure the project builds with the command <code>dotnet build</code>.</p> <p>We'll now add a test library for this method.  Back at the terminal enter:</p> <p><code>dotnet new xunit -n MyMathsTests</code></p> <p>In the <code>Unittest1.cs</code> file insert the following test code:</p> <pre><code>using System;\nusing Xunit;\nusing MyMaths;\n\nnamespace MyMathsTests\n{\n    public class UnitTest1\n    {\n        [Fact]\n        public void Test1()\n        {\n            var actual = Class1.Add(2,3);\n            Assert.Equal(5, actual);\n        }\n    }\n}\n</code></pre> <p>Check this builds too with the <code>dotnet build</code> command.  (It should as we've not altered the boilerplate code)</p> <p>If you click on the Testing icon in the VSCode sidebar a message will appear saying no tests have been found.</p> <p>At the Terminal go into the root directory of the project and create a reference between the two projects:</p> <p><code>dotnet add .\\MyMathsTests\\MyMathsTexts.csproj reference .\\MyMaths\\MyMaths.csproj</code></p> <p>Now, clicking the Testing icon in the sidebar the tests in the test library will be displayed, by name.  Clicking the \"Play\" button will now run the tests.  If is passes a green tick will be shown against the name of the test.</p> <p>Try adding a second test, using the same format but use data you'd expect to fail.  Running the <code>dotnet test</code> command again will show one test has passed but another failed (as you'd expect).</p>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/","title":"Appendix 7 - From Python to C#","text":"<p>If you've done any programming before, it's likely you've used Python, as its popularity in schools as a first programming language has grown significantly in recent years. This section summarizes some of the key differences between Python and C# by comparing simple code snippets and highlighting key concepts.</p>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#basic-syntax-comparison","title":"Basic Syntax Comparison","text":"<p>Python Example</p> <pre><code># Python\nuserName = input(\"Enter your name &gt; \")\nprint(\"Your name is \", userName)\n</code></pre> <p>C# Example</p> <pre><code>using System;\nnamespace printName\n{\n    public class PrintName\n    {\n        static void Main(string[] args)\n        {\n            string userName;\n            userName = Console.ReadLine();\n            Console.WriteLine(\"Your name is \" + userName);\n        }\n    }\n}\n</code></pre>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#key-differences","title":"Key Differences","text":"<ul> <li>Every C# program must define a class, and code is written inside that class.</li> <li>Every variable and method must be assigned a data type.</li> <li>The entry point for a C# program must be a method named <code>Main()</code>.</li> </ul> <p>The Python code can be structured similarly to C#:</p> <pre><code>def main():\n    userName = input(\"Enter your name &gt; \")\n    print(\"Your name is \", userName)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Notice in C#:</p> <ul> <li>Every project will be in a <code>namespace</code> to organize code.</li> <li>Curly braces <code>{ ... }</code> define code blocks, unlike Python\u2019s indentation.</li> <li>Each statement ends with a semi-colon, <code>;</code>.</li> </ul>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#data-typing","title":"Data Typing","text":"<p>Python is dynamically typed, meaning variable types are determined at runtime and can change during the program. C# is statically typed, meaning variable types are set before compilation and cannot change. </p> <p>Example</p> <pre><code># Python\nmyVar = 5\nmyVar = \"Hello\"  # Now myVar is a string\n</code></pre> <pre><code>// C#\nint myVar = 5;\n// myVar = \"Hello\"; // Error: cannot assign a string to an int\n</code></pre> <p>In C#, you must declare variable types explicitly, and they cannot change type.</p>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#comments","title":"Comments","text":"<ul> <li>Single-line comments: Use <code>//</code></li> <li>Multi-line comments: Use <code>/* ... */</code></li> </ul> <pre><code>// This is a single-line comment\n/* \n * This is a multi-line comment \n * spanning multiple lines\n */\n</code></pre>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#flow-of-control","title":"Flow of Control","text":"<ul> <li>C# uses curly braces <code>{ ... }</code> for code blocks instead of indentation.</li> <li>Conditions must be enclosed in parentheses <code>(...)</code>.</li> <li>Use <code>else if</code> instead of <code>elif</code>.</li> <li>C# includes a <code>switch</code> statement for multi-way branching.</li> </ul> <p>Example</p> Python C# <code>if x &gt; 0:</code> <code>if (x &gt; 0) { ... }</code> <code>elif x == 0:</code> <code>else if (x == 0) { ... }</code> <code>for i in range(5):</code> <code>for (int i = 0; i &lt; 5; i++) { ... }</code> <code>for item in list:</code> <code>foreach (var item in list) { ... }</code>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#boolean-expressions","title":"Boolean Expressions","text":"<ul> <li>C# uses <code>true</code> and <code>false</code> instead of <code>True</code> and <code>False</code>.</li> <li>Boolean operators:</li> <li><code>and</code> -&gt; <code>&amp;&amp;</code></li> <li><code>or</code> -&gt; <code>||</code></li> <li><code>not</code> -&gt; <code>!</code></li> </ul>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#data-structures","title":"Data Structures","text":"<ul> <li>C# arrays have fixed sizes, whereas <code>List</code> is used for dynamic sizes.</li> <li>Lists in C# must specify the data type:</li> </ul> <pre><code>List&lt;int&gt; numbers = new List&lt;int&gt;();\nnumbers.Add(5);\n</code></pre>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#classes","title":"Classes","text":"<p>C# supports creating user-defined classes with their own properties and methods. It also supports inheritance and access modifiers.</p> <p>Python</p> <pre><code>class MyClass(BaseClass):\n    def __init__(self, x):\n        self.x = x\n\nMyObject = MyClass(42)\n</code></pre> <p>C#</p> <pre><code>class MyClass : BaseClass\n{\n    public MyClass(int x)\n    {\n        this.x = x;\n    }\n}\nMyClass MyObject = new MyClass(42);\n</code></pre>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#access-modifiers","title":"Access Modifiers","text":"Modifier Visibility <code>public</code> Accessible from anywhere <code>internal</code> Accessible only within the project <code>protected</code> Accessible within class and subclasses <code>private</code> Accessible only within the class"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#memory-management","title":"Memory Management","text":"<p>C# uses garbage collection for automatic memory management. However, for non-memory resources like files or network connections, you should manually release them using the <code>Dispose</code> pattern or the <code>using</code> statement.</p> <pre><code>using (StreamWriter writer = new StreamWriter(\"file.txt\"))\n{\n    writer.WriteLine(\"Hello, World!\");\n}\n</code></pre> <p>In Python, this is similar to using the <code>with</code> statement.</p> <pre><code>with open('file.txt', 'w') as writer:\n    writer.write(\"Hello, World!\")\n</code></pre>"},{"location":"chapters/14_appendix/A7_FromPythonToCSharp/#summary","title":"Summary","text":"<p>Both Python and C# have their strengths and weaknesses. Understanding the differences in syntax, data types, and control structures will help you transition smoothly between these two languages.</p>"}]}